# 使用共享变量实现并发

## 竞争条件

在只有一个`goroutine`的程序中，程序的执行顺序只由程序的逻辑来决定。比如，在一系列语句中，第一句在第二句之前执行，以此类推。当一个程序有两个或者多个`goroutine`时，每个`goroutine`内的语句也是按照顺序去执行的，但一般情况下我们无法知道两个`goroutine`的事件
`x`和`y`的执行顺序，`x`是在`y`之前还是之后还是同时发生是无法判断的。如果我们无法自信地说一个事件是在另一个事件的前面或者后面发生的话，就说明这两个事件是并发的。

考虑一个能在串行程序中正确工作的函数。如果这个函数在并发调用时依然可以正确地工作，那么这个函数时是并发安全的，并发安全的函数不需要额外的同步工作。我们可以把这个概念概括为一个特定类型的一些方法和操作函数，对于某个类型来说，如果其所有可访问的方法和操作都是并发安全
的话，那么该类型便是并发安全的。

让一个程序并发安全并不需要其中的每一个具体类型都是并发安全的。实际上，并发安全的类型其实是特例而不是普遍存在的，所以仅在文档指出类型是安全的情况下，才可以并发地访问一个变量。对于大部分变量，如要回避并发访问，要么限制变量只存在一个`goroutine`中，要么维护一个更高层的
**互斥**不变量。接下来我们详细解释这些概念。

相反，包级别的导出函数一般情况下都是并发安全的，由于`package`级的变量无法被限制在单一的`goroutine`，所以修改这些变量必须使用互斥条件。

一个函数在并发调用时无法工作的原因太多了，比如死锁（deadlock）、活锁（livelock）和资源耗尽（resource starvation）。我们无法一一讨论所有的问题，这里我们只聚焦在竞争条件上。

**竞争条件** 上指的是程序在多个`goroutine`交叉执行操作时，没有给出正确的结果。竞争条件时很恶劣的一种场景，因为这种问题会一直潜伏在程序中，然后在非常少见的情况下蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编辑器、某一种平台或者某一架构的时候
才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。

下面来用一个经济损失的隐喻来解释竞争条件的严重性，看下面的例子：

```go
var balance int

func Deposit(amount int) {
 balance = balance + amount
}

func Balance() int {
 return balance
}
```

对于这个简单的程序来说，一眼就能看出，以任意顺序调用函数`Deposit`和`Balance`都能得到正确的结果。也就是说，`Balance`会输出之前存入的金额总数。但如果这些函数的调用顺序不是串行而是并行，`Balance`就再也无法保证结果正确了。如下两个`goroutine`:

```go
func main() {
  // 图图：
  go func() {
    Deposit(200) // A1
    fmt.Println("=", Balance()) // A2
  }()

  // 小美：
  go Deposit(100) // B
}
```

图图存入200块，然后查询他的余额，此时小美存入100块。A1、A2和B是并发进行的，我们无法预测实际的执行顺序。直觉来看，可能存在三种可能性：“图图先”，“小美先”以及“图图/小美/图图”。下面表格展示每个步骤之后`balance`变量的值。带引号的字符串表示输出的账户余额。

|图图先|小美先|图图/小美/图图|
|----|----|----|
|0         |0         |         0|
|A1  200   |B      100|A1     200|
|A2  "=200"|A1     300|B      300|
|A1  300   |A2 "= 300"|A2 "= 300"|

所有情况下最终的账户余额都是300块。唯有不同的是图图看到的账户余额是否包含了小美的交易，但客户对所有情况都不会有不满。

这种直觉是错的。还有第四种可能，小美的存款在图图的存款操作中间执行，在余额被读到（balance+amount）之前，在余额被更新之前（balance=...），这样会导致小美的交易丢失。这是因为图图的存款操作A1实际上是串行的两个操作，读部分和写部分，可以称之为A1r和A1w。下面是
交叉时产生的问题：
|数据竞争| |
|----|----|
|0         |...=balance + amount|
|A1r      0||
|B      100||
|A1w    200|balance = ...|
|A2 "= 200"||

在A1r之后，表达式`balance + amount`求值结果为200，这个值在A1w步骤中用于写入，完全没有理会中间的存款操作。最终的余额为200块。银行从小美手上挣了100块。

这种状况是竞争条件中的一种，叫作数据竞争（data race）。数据竞争发生于两个`goroutine`并发读写同一个变量，且其中一个是写入时会发生数据竞争。
