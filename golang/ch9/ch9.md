# 包和go工具

## 导入路径

每一个包都通过一个唯一的字符串进行标识，它称为导入路径，它们用在`import`声明中。

```go
import (
  "fmt"
  "math/rand"
  "encoding/json"
  "golang.org/x/net/html"
  "github.com/go-sql-driver/mysql"
)
```

对于共享或公开的包，导入路径需要全局唯一。为了避免冲突，除了标准库中的包之外，其他包的导入路径应该以互联网域名作为路径，这样也方便查找包。比如上面的例子导入Go团队维护的一个HTML解析器和一个流行的第三方MySQL数据驱动程序。

## 包的声明

在每一个Go源文件的开头都要进行包声明。主要的目的是当该包被其他包引入时作为其默认的标识符（叫做包名）。

例如，`math/rand`包中每个文件的开头都是`package rand`，这样当你导入这个包时，可以访问它的成员，比如`rand.Int`、`rand.Float64`等。

```go
package main

import (
  "fmt"
  "math/rand"
)

func main() {
  fmt.Println(rand.Int())
}
```

通常，包名是导入路径的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，`math/rand`包和`crypto/rand`包的包名都是`rand`。稍后将看到如果同时导入两个有相同包名的包。

关于“最后一段”的惯例，有三个例外。第一个例外是，包对应一个可执行程序，也就是`main`包，这时`main`包本身的导入路径是无关紧要的。名为`main`的包是给`go build`构建命令的一个信息，这个包编译完之后必须调用
连接器生成一个可执行程序。

第二个例外是：目录中可能有一些文件名以`_test.go`结尾，包名中会出现以`_test`结尾。这样一个目录中有两个包：一个普通包，加上一个外部测试包。`_test`后缀告诉`go test`两个包都要构建，并且指明文件属于哪个包。
外部测试包用来避免测试代码中的循环导入依赖。

第三个例外，一些依赖管理工具会在包导入路径的尾部追加版本号后缀，如`gopkg.in/yaml.v2`。包名不包含后缀，因此这个情况下包名为`yaml`。

## 导入声明

可以在一个Go源文件包声明语句之后，其他非导入声明语句之前，包含零到多个导入包声明语句。每个导入可以单独指定一条导入路径，也可以通过圆括号括起来的列表一次导入多个包。下面两种方式是等价的，但第二种更常见。

```go
import "fmt"
import "os"

import (
  "fmt"
  "os"
)
```

导入的包可以通过空行进行分组；这类分组通常表示不同领域和方面的包。导入顺序不重要，但按照惯例每一组都按照字母进行排序。

```go
import (
  "fmt"
  "html/template"
  "os"

  "golang.org/x/net/html"
  "golang.org/x/net/ipv4"
)
```

如果需要把两个名字一样的包（如`math/rand`和`crypto/rand`）导入到第三个包中，导入声明就必须至少为其中一个指定一个代替名字来避免冲突。这叫**重命名导入**。

```go
import (
  "crypto/rand"
  mrand "math/rand"
)
```

代替名字仅影响当前文件。其他文件（即便是同一个包中的文件）可以使用默认名字来导入包，或者一个替代名字也可以。

重命名导入在没有冲突时也是非常有用的。如果有时用到自动生成的代码，导入的包名非常长，使用一个替代名字可能更方便。同样的缩写名字要一直用下去，以避免产生混淆。使用一个替代名字有助于规避常见的局部变量冲突。
例如，如果一个文件可以包含许多以`path`命名的变量，我们就可以使用`pathpkg`这个名字导入一个标准的`path`包。

每个导入声明从当前包向导入的包建立一个依赖。如果这些依赖形成一个循环，`go build`工具会报错。