## 复合数据类型

### 数组

数组是具有固定长度且拥有`0`个货多个相同数据类型元素的序列。由于数组的长度固定，所以在`go`里面很少直接使用。`slice`的长度可以增长和缩短，在很多场合下使用得跟过。在理解`slice`前，我们先来了解`go`中的数组。

数组中的每个元素是通过索引来访问的，索引从0到数组长度减1。`go`内置的函数`len`可以返回数组中的元素个数。

```go
package main

import "fmt"

func main() {
 var a [3]int // 3个整数的数组
 fmt.Println(a[0]) // 获取数组的第一个元素
 fmt.Println(a[len(a) - 1]) // 获取数组的最后一个元素，也就是a[2]

 // 获取数组的索引和元素
 for i, v := range a {
  fmt.Printf("%d %d\n", i, v)
 }

 // 获取数组中的元素
 for _, v := range a {
  fmt.Printf("%d\n", v)
 }
}
```

默认情况下，一个新数组中的元素初始值为元素类型的零值，对于数字来说，就是`0`。也可以使用**数组字面量**根据一组值来初始化一个数组。

```go
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // 0
```

在数组字面量中，如果省略号`...`出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定。以上数组的`r`的定义可以简化成：

```go
r:=[...]int {1, 2, 3}
fmt.Printf("%T\n", r) // [3]int
```

数组的长度数组类型的一部分，所以`[3]int`和`[4]int`是两种不同的数组类型。数组的长度必须是常量表达式，也就是说，这个表达式的值在编译阶段就可以确定。

```go
r:= [3]int{1, 2, 3}
r:= [4]int{1, 2, 3, 4} // 编译错误： 不可以将[4]int 赋值给 [3]int
```

数组、`slice`、`map`和结构体的字面量语法都是相似的。以上的例子是按顺序给出一组值；也可以像下面这样给出一组值，这组值同样具有索引和索引对应的值：

```go
type Currency int
const (
  USD Currency = iota
  EUR
  GBP
  RMB
)
symbol := [...]string {USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB,symbol[RMB]) // 3 ￥
```

在这种情况下，索引可以按照任意顺序出现，并且有的时候还可以省略。和上面一样，没有指定值的索引位置的元素默认被赋予数组元素类型的零值。例如，

```go
r := [...]int{99 : -1}
```

定义了一个有100个元素的数组`r`，除了最后一个元素值是`-1`外，其他的元素值都为`0`。

如果一个数组的元素类型是可比较的，那么这个数组也是可比较的，这样就可以直接用`==`操作符来比较两个数组，比较的结果是两边元素的值是否完全相同。用`!=`来比较两个数组是否不同。

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // true false false

d := [3]int{1, 2}
fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int
```

当调用一个函数时，每个传入的参数都会创建一个副本，然后复制给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数。使用这种方式传递大的数组会变得很低效，并且在函数内部对数组的任何修改都只会影响副本，而不是原数组。这种情况下，go把数组和其他的类型都看成值传递。而在其他的语言中，数组是隐式地使用引用传递。

当然，也可以显式地传递一个数组的指针给函数，这样在函数内部对数组的任何修改都会反映到原始数组上面。下面来展示如何将一个数组`[32]byte`的元素清零：

```go
func zero(ptr *[32]byte)  {
 for _, v := range ptr {
  ptr[v] = 0
 }
}
```

数组字面量`[32]byte{}`可以生成一个拥有`32`个字节元素的数组。数组中每个元素的值都是字节类型的零值，即`0`。可以利用这一点来写另一个版本的数组清零程序：

```go
func zero(ptr *[32]byte)  {
 *ptr = [32]byte{}
}
```

使用数组指针是高效的，同时允许被调函数修改调用方数组中的元素，但是因为数组长度是固定的，所以数组本身是不可变的。例如上面的`zero`函数不能接受一个`[16]byte`这样的数组指针，同样，也无法为数组添加或者删除元素。由于数组的长度不可变的特性，除了在特殊情况之外，我们很少使用数组。
