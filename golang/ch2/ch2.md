## 基础数据类型

### 整型

Go中的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。

Go同时提供了有符号和无符号类型的整数运算。有`int8`、`int16`、`int32`和`int64`四种不同大小的有符号整数类型，分别对应`8`、`32`、`64`bit大小的有符号整数。与此对应的是`uint8`、`uint6`、`uint32`、`uint64`四种无符号整数类型。

`UniCode`字符`rune`类型是和`int32`等价的类型，通常用于表示一个`UniCode`码点。这两个名称可以互换使用。同时`byte`也是`uint8`类型的等价类型，`byte`类型一般用于强调数值是一个原始的数据而不是一个小的整数。

最后，还有一种无符号的整数类型`uintptr`，没有指定具体的`bit`大小。但是足以容纳指针。`uintptr`类型只有在底层编程时才需要，特别是Go和C函数库或操作系统接口相交互的地方。

不管它们的具体大小。`int`、`uint`和`uintptr`是不同类型的兄弟类型。其中`int`和`int32`是不同的类型，即使`int`的大小也是`32`bit，在需要将`int`当作`int32`类型的地方需要一个显式的类型转换操作。

其中有符号整数采用`2`的补码形式表示，也就是最好bit位用来表示符号位，一个`n-bit`的有符号数的值域是从`$-2^{n-1}$`到`$2^{n-1}-1$`。无符号整数的所有bit位都用于表示非负数，值域是`0`到`$2^n-1$`。例如，`int8`类型整数的值域是从`-128`到`127`，而`uint8`类型整数的值域是从`0`到`255`。

下面列出Go中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的循序排序：

```golang
*     /     %      <<     >>    &     &^
+     -     |      ^
==    !=    <      <=     >     >=
&&
||
```

二元运算符有五种优先级。在同一个优先级，使用左优先结合规则。但是使用括号可以明确优先顺序，同时可以提升优先级，例如`remark & (1 << 28)`。

算术运算符`+`、`-`、`*`和`/`可以适用于整数、浮点数和复数。但取模运算`%`仅用于整数间的运算，这个行为和被取模数的符号总是一致的。比如`-5%3`和`-5%-3`结果都为`-2`。除法运算符`/`的行为则依赖操作数是否全为整数，比如`5.0/4.0`的结果为`1.25`，但是`5/4`的结果是`1`，因为整数除法会向`0`方向截取余数。

不管是有符号数或者无符号数，如果算术运算结果所需的超出了该类型的范围，说明计算结果溢出了。溢出的高位部分会被丢弃。如果原本的计算结果是有符号类型，且最左侧位是`1`，最终结果为负值。

```golang
func main() {
 var u uint8 = 255
 fmt.Println(u, u+1, u*u) // 255 0 1

 var i int8 = 127
 fmt.Println(i, i+1, i*i) // 127 -128 1
}
```

两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式本身的类型为布尔型。

```golang
==  等于
!=  不等于
<   小于
<=  小于等于
>   大于
>=  大于等于
```

全部基本类型的值（布尔值、数值、字符串）都可以比较，意味着两个相同类型的值可用`==`和`!=`运算符比较。整数、浮点数和字符串还能根据比较运算符排序。许多其他类型的值是不可比较的，也无法排序。

加法和减法运算符对于整数，`+x`是`0+x`的简写，而`-x`则为`0-x`的简写。对于浮点数和复数，`+x`就是`x`，`-x`为`x`的负数。

```golang
+ 一元加法   - 负数
```

以下为Go中的位操作运算符。

```golang
& 位运算AND   | 位运算OR   ^ 位运算XOR   &^ 位清空   << 左移   >> 右移
```

### 浮点数

Go中提供了两种精度浮点数`float32`和`float64`，浮点数类型的取值范围可以从微小到巨大。浮点数的范围极限值可从`math`包找到。

`float32`类型的浮点数可以提供大约6个十进制数的精度，而`float64`则可以提供约15个十进制数的精度。通常优先使用`float64`类型，因为`float32`类型的接力计算误差很容易扩散，并且`float32`能精确表示的整数并不大（`float32`的有效bit位只有23个，其他的bit为用于指数和符号；当整数大于23bit能表达的范围时，`float32`的表示将出现误差）。

```golang
func main() {
 var f float32 = 16777216
 fmt.Println(f == f+1) // true
}
```

浮点数的字面值可以直接写小数部分：

```golang
const e = 2.71828
```

小数点前面或后面的数字都可以被省略（例如`.707`或`1.`）。很小或很大的数最好用科学计数法书写，通过`e`或`E`来指定指数部分：

```golang
func main() {
 const Avogadro = 6.02214129e23
 const Planck = 6.62606957e-34
 fmt.Println(Avogadro)
 fmt.Println(Planck)
}
```

### 复数

Go中有两种精度的复数类型：`complex64`和`complex128`。对应`float32`和`float64`两种浮点数精度。内置的`complex`函数用于构建复数，内建的`real`和`imag`函数分别返回复数的实部和虚部：

```golang
func main() {
 var x complex128 = complex(1, 2)
 var y complex128 = complex(3, 4)
 fmt.Println(x * y)       // (-5+10i)
 fmt.Println(real(x * y)) // -5
 fmt.Println(imag(x * y)) // 10
}
```

如果一个浮点数面值或一个十进制整数面值后面跟着一个`i`，例如`3.141592i`或`2i`。它将勾陈给一个复数的虚部，复数的实部为0：

```golang
fmt.Println(1i * 1i) // (-1+0i)
```

在常量算术规则下，一个复数常量可以加到另一个普通树脂常量（整数或浮点数、实部或虚部）。我们可以用自然的方式书写复数，就像`1+2i`或与之等价的写法`2i+1`。上面的`x`和`y`的声明语句还可以简化：

```golang
x := 1 + 2i
y := 3 + 4i
```

复数可以用`==`和`!=`进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的。

`math/cmplx`包提供了许多处理复数的函数，比如求复数的平方根函数和求幂函数。

### 布尔型

Go中的布尔类型的值只有两种：`true`跟`false`。布尔值可以和`&&`和`||`操作符组合运算，并具有短路行为：如果运算符左边值已经确定整个布尔值表达式的值，那么运算符右边的值将不会求值。

```golang
s != "" && s[0] == 'x'
```

其中`s[0]`操作如果应用于空字符串将会导致宕机异常。

由于`&&`比`||`优先级要高，所以像下面形式的条件不用加圆括号：

```golang
func main() {
 if 'a' <= c && c <= 'Z' ||
  'A' <= c && c <= 'Z' ||
  '0' <= c && c <= '9' {
  // 进入
 }
}
```

布尔值不会隐式转换为数字值`0`或`1`。如果有需要做类似的转换，可以包装成一个函数更方便。

```golang
func btoi(b bool) int {
 if b {
  return 1
 }
 return 0
}
```

### 字符串

字符串是不可变的字节序列，它可以包含任何数据，包括`0`值字节。文本字符串通常被解读成按UTF-8编码的Unicode码点（文字符号）序列。

内置的`len`函数返回字符串的字节数（并非文字符号的数目），索引访问操作`s[i]`返回第`i`个字符的字节值，`i`必须满足`0≤i<len(s)`。

```golang
func main() {
 s := "hello, world"
 fmt.Println(len(s))     // 12
 fmt.Println(s[0], s[7]) // 104 119
}
```

如果访问超出字符串索引范围以外的字节会导致宕机异常：

```golang
c := s[len(s)]
fmt.Println(c) // panic: runtime error: index out of range [12] with length 12
```

字符串的第`i`个字节不一定就是第`i`个字符，因为非`ASCII`字符的`UTF-8`码点需要两个字节或多个字节。

子字符串操作`s[i:j]`会基于原始的`s`字符串的第`i`个字节开始到第`j`个字节（不包含`j`本身）生成一个新字符串。生成的字符串中包含`j-i`个字节。

```golang
fmt.Println(s[0:6]) // hello,
```

如果索引超出字符串范围或者`j`小于`i`的话会导致宕机异常。

`i`和`j`的默认值都为`0`（字符串起始位置）和`len(s)`（字符串终止位置），如果省略`i`或`j`，或者两者，分别取默认值。

```golang
fmt.Println(s[:5]) // hello
fmt.Println(s[7:]) // world
fmt.Println(s[:]) // hello, world
```

加号运算符连接两个字符串会生成一个新的字符串：

```golang
fmt.Println("再见" + s[5:]) // 再见, world
```

字符串可以用`==`和`<`进行比较，比较运算按字节进行，比较的结果是字符串自然编码的顺序。

字符串的值是不可变的：字符串值本身所包含的字节序列永远都不会变。当然我们可以给一个字符串变量分配一个新的字符串值。像下面这样：

```golang
s := "hello, world"
t := s
s += ", hello, human"
```

这样并不会改变`s`原有的字符串值，只是把`+=`语句生成的新字符串赋给`s`。`t`还是保留旧的字符串值。

```golang
fmt.Println(s) // hello, world, hello, human
fmt.Println(t) // hello, world
```

因为字符串是不可改变的，所以字符串内部的数据不允许修改：

```golang
s[1] = 'E' // cannot assign to s[1] (strings are immutable)
```

#### 字符串字面量

字符串的值可以直接写成**字符串字面量**，也就是带双引号的字节序列：

```golang
"hello, human"
```

在带双引号的字符串字面量中，转义序列以反斜杠（\）开始，可以把任何值的字节插到字符串中。下面列出一组转义符。

```
\a   "警告"或响铃
\b   退格
\f   换页
\n   换行
\r  回车
\t  制表符
\v  垂直制表符
\'  单引号（只用于文字字符字面量'\''）
\"  双引号（只用于“...”字面量中）
\\  反斜杠
```

还有一个原生的**字符串字面量**，书写形式和JS的字符串模板一样（``），用反引号。原生的字符串字面量中，没有转义操作；全部的内容都是字面意思，包括退格和换行。因此在一个程序中的原生字符串字面量可能跨越多行。唯一的特殊处理是会删除回车以保证在所有平台上的值都一样。包括那些把回车也放到文本文件的系统。

正则表达式通常会含有大量的反斜杠，可以方便地写成原生的字符串字面量。原生的字面使用于HTML模板、JSON字面量、命令行提示信息，以及需要多行文本表达的场景。

#### 字符串和字节slice

`bytes`、`strings`、`strconv`和`unicode`这四个标准包对字符串操作极其重要。`strings`包提供了许多函数，用于搜索、替换、比较、修整、切分与连接字符串等功能。

`bytes`包也有类似的函数，用于操作字节`slice`（`[]byte`类型，其某些属性和字符串相同）。由于字符串是不可变的，因此逐步构建字符串会导致多次内存分配和复制。在这种情况下，使用`bytes.Buffer`类型会更高效。

`unicode`包提供了判别文字符号值特性的函数，如`IsDigit`、`IsLetter`、`IsUpper`和`IsLower`。每个函数以单个文字符号值作为参数，并返回布尔值。如果文字符号值是英文字母，转换函数将其转换成指定的大小写。

`path`包和`path/filepath`包提供了一组更加使用的函数，用来操作文件路径等具有层次结构的名字。`path`包处理以斜杠`/`分段的路径字符串。它不适用于处理文件名，却适合其他一些领域，比如`URL`地址的路径部分。`path/filepath`包则使用操作系统本身的路径规则。

如果字符串包含一个字节数组，创建之后就是不可变的。相比之下，字节`slice`的元素可以随意修改。

字符串可以和字节`slice`相互转换：

```golang
s := "abc"
b := []byte(s)
s2 := string(b)
fmt.Println(b) // [97 98 99]
fmt.Println(s2) // abc
```

从概念上讲，`[]byte(s)`转换操作会分配新的字节数组，用于保存字符串数据的拷贝，然后引用这个底层的`byte`数组。编译器的优化可以避免在一些场景下分配和复制字符串数据。但总的来说，需要确保`b`变量的字节被改的情况下，原始的`s`字符串也不会改变。将一个字节`slice`转换到字符串的`string(b)`操作则是构造一个字符串拷贝，以确保`s2`字符串为只读的。

### 字符串和数字的相互转换

除了字符串、文字符号和字节之间的转换，我们还需要相互转换数值以及其字符串表示形式。这由`strconv`包的提供这些转换功能。

把一个整数转为字符串，一种选择是用`fmt.Sprintf`，另一种是用函数`strconv.Itoa`。

```golang
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x)) // 123 123
```

`FormatInt`和`FormatUint`函数可以按不同的进位制格式化数字：

```golang
fmt.Println(strconv.FormatInt(int64(x), 2)) // 1111011
```

`fmt.Printf`方法中的`%b`、`%d`、`%o`和`%x`要比`Format`函数方便。特别是在需要包含数字以外的附加信息。

```golang
s := fmt.Sprintf("x=%b", x)
fmt.Println(s) // x=1111011
```

使用`strconv`包中的`Atoi`函数或`ParseInt`函数可以把一个字符串解析为整数。`ParseUint`用于无符号整数：

```golang
x, err := strconv.Atoi("123") // x是整型
y, err := strconv.ParseInt("123", 10, 64) // 十进制，最长为64位
fmt.Println(x, y, err) // 123 123 <nil>
```

`ParseInt`函数的第三个参数是用于指定整数的大小；例如`16`表示`int16`，`0`表示`int`。在任何情况下，结果`y`的类型总是`int64`，你可以通过强制类型转换把它转成更小的整数类型。
