<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Funciton类型</title>
  <script>
    /**
     * 每个函数都是function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数
     * 是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常
     * 是使函数声明语法定义的，如下面的例子所示。
     * function sum (num1, num2) {
     *   return num1 + num2;
     * };
     * 这与下面使用函数表达式定义函数的方式几乎相差无几。可以通过变量sum即可以引用函数。
     * var sum = function (num1, num2) {
     *   return num1 + num2;
     * };
    */

    /**
     * 由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换
     * 句话说，一个函数可能会有多个名字，如下面的例子所示。
     * 
     * function sum (num1, num2) {
     *   return num1 + num2;
     * }
     * console.log(sum(10,10)); // 20
     * 
     * var anotherSum = sum;
     * console.log(anotherSum(10, 10)); // 20
     * 
     * sum = null;
     * console.log(anotherSum(10, 10)); // 20
     * 
     * 以上代码首定义了一个名为sum()的函数，用于求两个值的和。然后，又声明了变量anotherSum，
     * 并将其设置为与sum相等（将sum的值赋给anotherSum）。注意，使用不带圆括号的函数名是访问函
     * 数指针，而非调用函数，此时，anotherSum和sum就都指向了同一个函数，因此anotherSum()也
     * 可以被调用并返回结果。即使sum设置为null，让它与函数"断绝关系"，但仍然可以正常调用anotherSum()
    */

    /**
     * 没有重载(深入理解)
     * 将函数名想象为指针，也有助于理解为什么ECMAscript中没有函数重载的概念。以下是之前已经
     * 使用过的例子。
     * 
     * function addSomeNumber (num) {
     *   return num + 100;
     * }
     * function addSomeNumber (num) {
     *   return num + 200;
     * }
     * var result = addSomeNumber(100); // 300
     * console.log(result);
     * 
     * 显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上
     * 与下面的代码没有什么区别。
     * 
     * var addSomeNumber = function (num) {
     *  return num + 100;
     * }
     * addSomeNumber = function (num) {
     *  return num + 200;
     * }
     * var result = addSomeNumber(100);
     * console.log(result); // 300
     * 
     * 通过观察重写之后的代码，很容易看清楚到底是怎么回事儿----在创建第二个函数时，实际上覆盖
     * 了引用第一个函数的变量addSomeNumber。
    */


    /**
     * 函数声明与函数表达式
     * 
     * 目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环境中加载
     * 数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代
     * 码之前可用(就是可以访问)；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正
     * 被解释执行。请看下面的例子。
     * 
     * console.log(sum(10, 10));
     * function sum (num1, num2) {
     *   return num1 + num2;
     * }
     * 
     * 以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升的
     * 过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并
     * 将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能
     * 把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价的函数表达式，就会在
     * 执行期间导致错误。
     * 
     * console.log(sum(10,10)); // Uncaught TypeError: sum is not a function
     * var sum = function (num1, num2) {
     *   return num1 + num2;
     * }
     * 
     * 以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。
     * 换句话说，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；而且，由于第一行代
     * 码就会导致"Uncaught TypeError: sum is not a function"错误，实际上也不会执行到下一行。
     * 
     * 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。
    */
    
    // ---------------作为值的函数-------------------
    /**
      因为ECMAscript中的函数名本身就是变量；所以函数也可以作为值来使用。也就是说，不仅可以像传递
      参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回，请看下面的函数。

      function callSomeFunction (someFounction, someArgument) {
        return someFounction(someArgument)
      }

      这个函数接收两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，
      就可以像下面的例子一样传递函数了。

      function callSomeFunction(someFounction, someArgument) {
        return someFounction(someArgument)
      }
      function add (num) {
        return num + 10;
      }
      var result = callSomeFunction(add,10);
      console.log(result); // 20

      function getGreeting (name) {
        return "hello" + name;
      }
      var result2 = callSomeFunction(getGreeting, "Nicholas");
      console.log(result2); // helloNicholas

      这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第
      一个参数后的结果，还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后面的那个对大括号。
      因此上面例子中传递给callSomeFunction()的是add和getGreeting，而不是执行它们之后的结果。
    */
    /**
      当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有个对象数组，我们
      想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数接收两个参数，即要比较的值。
      可是，我们需要一种方式指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，
      然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。

      function createComparisonFunction (propertyName) {
        return function (object1, object2) {
          var value1 = object1[propertyName];
          var value2 = object2[propertyName];
          console.log('value1',value1)
          console.log('value2',value2)
          if(value1 < value2){
            return -1;
          }else if (value1 > value2) {
            return 1;
          } else {
            return 0;
          }
        }
      }
      var data = [{ name: "xiaoyan", age:28 },{ name:"xiaoli",age: 18 }];
      data.sort(createComparisonFunction("name"));
      console.log(data[0].name); // xiaoli
      data.sort(createComparisonFunction("age"));
      console.log(data[0].name); // xiaoyan

      这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个age属性。
      在默认情况下，sort()方法会调用每个对象的toString()方法以确定它们的次序；但得到的结果往往
      并不符合人类的思维习惯。因此我们调用createComparisonFunction("name")方法创建了一个比较
      函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项name为"xiaoyan"，age是28
      的对象。然后我们又使用了createComparisonFunction("age")返回的比较函数，这次是按照对象的age
      属性排序。得到的结果是name值为"xiaoyan"，age值是28的对象排在了第一位。
    */

    /** -------------函数内部属性---------------- */
    /**
      在函数内部，有两个特殊的对象：arguments和this。其中，arguments在之前已经介绍过了，它是一个
      类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有
      一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
      请看下面这个非常经典的阶乘函数。

      function factorial (num) {
        if (num <= 1) {
          return 1;
        } else {
          return num * factorial(num-1);
        }
      }

      定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，
      这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合
      的现象，可以像下面这样使用arguments.callee。

        function factorial (num) {
          if(num <= 1) {
            return 1;
          } else {
            return num * arguments.callee(num -1);
          }
        };
        var trueFactorial = factorial;
        factorial = function () {
          return 0;
        };
        console.log(trueFactorial);
        console.log(factorial(5))
      
      在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，
      我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，
      调用trueFactorial()就会返回0。可是，解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()
      仍然能够正常地计算阶乘，至于factorial()，它现在只是一个返回0的函数。
    */

    /**
      函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数执行
      的环境对象----或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。
    */

    /**
      window.color = "red";
      var o = { color: "blue" };
      function sayColor () {
        console.log(this.color); // red;
      }
      sayColor();

      o.sayColor = sayColor;
      o.sayColor(); // blue

      上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前，this的值并
      不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引
      用的是全局对象window；换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了
      "red"。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值
      会转换成对o.color求值，结果就返回了"blue"。
      ！切记，函数的名字仅仅是一个包含指针的变量而已，因此，即使是在不同的环境执行，全局的sayColor()
      函数与o.sayColor()指向的仍然是同一个函数。
    */

    /**
      ECMAScript5也规范化了另一个函数对象的属性:caller。这个属性中保存着调用当前函数的函数的引用，如果
      是在全局作用域中调用当前函数，它的值为null。例如：

      function outer() {
        inner();
      }
      function inner() {
        alert(inner.caller);
      }
      outer();

      以上代码会导致警告框中显示outer()函数的源码。因为outer()调用了inner()，所以inner.caller就指向
      outer()。为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息。

      function outer () {
        inner();
      };
      function inner () {
        alert(arguments.callee.caller);
      }
      outer();

      当函数在严格模式下运行时，访问arguments.callee会导致错误。ECMAScript5还定义了arguments.caller
      属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义了arguments.callee
      属性是为了分清arguments.caller和函数caller属性。
      严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。
    */

    /**-------------函数属性和方法----------------*/
    /**
      前面提到过ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。
      其中，length属性表示函数希望接收的命名参数的个数。
      function sayName (name) {
        console.log(name);
      };
      function sum (num1, num2) {
        return num1 + num2;
      }
      function sayHi () {
        console.log("hi");
      }
      console.log(sayName.length); // 1
      console.log(sum.length); // 2
      console.log(sayHi.length); // 0

      以上代码定义了3个函数，但每个函数接收的命名参数个数不同。首先，sayName()函数定义了一个参数，因此其length
      属性的值为1。类似地，sum()函数定义了两个参数，结果其length属性中保存的值为2。而sayHi()没有命名参数，所以
      其length值为0。
    */

    /**
        在ECMAScript核心所定义的全部属性中，最耐人寻味的就是数prototype属性了。对于ECMAScript中的引用类型而言，
      prototype是保存它们所有实例方法的真正所在。换句话，诸如toString()和valueOf()等方法实际上都保存在prototype
      名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承是，prototype属性的作用是极为重要
      的（后续会详情介绍）。在ECMAScript5中，prototype属性是不可枚举的，因此使用for-in无法发现。
        每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上
      等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。
      其中，第二个参数可以是Array的实例，也可以是arguments对象。例如：

      function sum (num1, num2) {
        return num1 + num2;
      }
      function callSum1 (num1, num2) {
        return sum.apply(this, arguments);
      }
      function callSum2 (num1, num2) {
        return sum.apply(this, [num1,num2]);
      }
      console.log(callSum1(10,10)); // 20
      console.log(callSum2(10,10)); // 20

      在上面的这个例子中：callSum1()在执行sum()函数时传入了this作为this值（因为是在全局作用域中调用的，所以传入
      的就是window对象）和arguments对象。而callSum2同样也调用了sum()函数，但它传入的则是this和一个参数数组。这
      两个函数都会正常执行并返回正确的结果。
      在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()
      或call()，否则this值将是undefined。
    */

    /**
      call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this
      值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，
      如下面的例子所示。

      function sum (num1, num2) {
        return num1 + num2;
      }
      function callSum (num1, num2) {
        return sum.call(this, num1,num2);
      }
      console.log(callSum(10,10)); // 20

      在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于使用apply()
      还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中
      先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，
      使用哪个方法都无所谓。）
    */

    /**
      事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来
      看一个例子。
        window.color = "red";
        var o = { color: "blue" };
        function sayColor () {
          console.log(this.color);
        }
        sayColor(); // red
        sayColor.call(this); // red
        sayColor.call(window); // red
        sayColor.call(o); // blue
      
      这个例子是在前面说明this对象的示例基础上修改而成。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用
      域中调用它时，它确实会显示"red"---因为对this.color的求值会转换成对window.color的求值。而sayColor.call(this)
      和sayColor.call(window)，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示"red"。但是，当运行
      sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是"blue"。
          使用call()（或者apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一版本
      中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；而在这里重写的例子中，就不需要先前两个多余的
      步骤了。
    */

    /**
      ECMAScript5还定义了一个方法：bind()。这个方法创建一个函数的实例，其this值会被绑定到传给bind()函数的值。例如：
      window.color = "red";
      var o = { color: "blue" };
      function sayColor () {
        console.log(this.color);
      }
      var objectSayColor = sayColor.bind(o);
      objectSayColor(); // blue

      在这里，sayColor()调用bind()并传入对象o，创建了objecSayColor()函数。objec-SayColor()函数的this值等于o，
      因此即使是在全局作用域中调用这个函数，也会看到"blue"。
    */
  </script>
</head>
<body>
</body>
</html>