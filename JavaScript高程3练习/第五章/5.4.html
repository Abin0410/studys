<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>RegExp类型</title>
  <script>
    /**
    * 通过RegExp类型来支持正则表达式
    * 其中的模式部分可以是通过简单或者复杂的正则表达式，可以包含字符类、限定符、分组
    * 向前查找以及反向引用。每个正则表达式都可带有一或多个标志，用以标明正则表达式的
    * 行为。正则表达式的匹配模式支持下面3个标志。
    *   1. g：表示全局模式，即模式将应用于所有字符串，而非在发现第一个匹配项时立即停止；
    *   2. i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写；
    *   3. m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项
    * 因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同的结果，如下面的
    * 例子所示。
    * var pattern1 = /at/g
    * var pattern2 = /[bc]/at/i;
    * var pattern3 = /.at/gi;
    * 与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括
    * ( [ { \ ^ $ | ) ? * + . ] } 
    */

    /**
     * 匹配第一个"bat"或"cat"，不区分大小写
     * var pattern1 = /[bc]at/i;
     */

    /** 
     * 匹配第一个" [bc]at",不区分大小写
     * var pattern2 = /\[bc\]at/i;
     */

    /**
     * 匹配所有以"at"结尾的3个字符串的组合，不区分大小写
     * var pattern3 = /.at/gi;
    */

    /**
     * 匹配所有".at"，不区分大小写
     * var pattern4 = /\.at/gi;
    */
    
    /**
     * 前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是
     * 使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志
     * 字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示。
     * 
     * 匹配第一个"bat"或"cat",不区分大小写
     * var pattern1 = /[bc]at/i;
     * 
     * 使用RegExp构造函数创建  这里完全等价上面的例子
     * var pattern2 = new RegExp("[bc]at","i");
    */

    /**
     * 使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAscript3中，
     * 正则表达式字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例
     * 都是一个新实例。来看下面的例子。
     * var re = null,
     *  i;
     * for(i=0;i < 10; i++){
     *  re = /cat/g;
     *  console.log(re.test("catastrophe")) //true
     * }
     * 
     * for (i=0; i < 10; i++) {
     *  re = new RegExp("cat", "g");
     *  console.log(re.test("catastrophe")); // true
     * }
     * 
     * 在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于
     * 实例属性不会重置，所以在循环中再次调用test()方法会失败。这是因为第一次调用test()找
     * 到了"cat",但第二次调用时从索引为3的字符(上一次匹配的末尾)开始的，所以就找不到他了。
     * 由于会测试字符串末尾，所以下一次再调用test()就又从开头开始了。
     * 
     * 第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的
     * RegExp实例，所以每次调用test()都会返回true。
    */

    /**---------------------RegExp实例--------------------*/
    /**
     * RegExp的每一个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
     *  global：布尔值，表示是否设置了g标志。
     *  ignoreCase：布尔值，表示是否设置了i标志。
     *  lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起
     *  multiline：布尔值，表示是否设置了m标志。
     *  source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符创模式返回。
     * var pattern1 = /\[bc\]at/i;
     * console.log(pattern1.global); // false
     * console.log(pattern1.ignoreCase); // true
     * console.log(pattern1.multiline); // false
     * console.log(pattern1.lastIndex); // 0
     * console.log(pattern1.source);// \[bc\]at
     * 
     * var pattern2 = new RegExp("\\[bc\\]at","i")
     * console.log(pattern2.global); //false
     * console.log(pattern2.ignoreCase); //true
     * console.log(pattern2.multiline); //false
     * console.log(pattern2.lastIndex); //0
     * console.log(pattern2.source) // \[bc\]at
     * 
     * 我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了RegExp构造函数，但是它们的
     * source属性是相同的。可见，source属性保存的是规范形式的字符串，即字面量形式所用的字符串
    */
  
    /**--------------------RegExp实例方法--------------*/
    /**
     * RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即
     * 要应用模式的字符串，然后返回包含第一匹配项信息的数组；或者在没有匹配项的情况下返回null。
     * 返回的数组虽然是Array的实例，但包含两个额外的属性:index和input。其中，index表示匹配项
     * 在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的
     * 字符串，其他项是与模式中的捕获匹配的字符串
     * 
     * var text = "mom and dad and baby";
     * var pattern = /mom( and dad( and baby)?)?/gi;
     * var matches = pattern.exec(text);
     * console.log(matches)
     * console.log(matches.index); // 0
     * console.log(matches.input); // mom and dad and baby
     * console.log(matches[0]); // mom and dad and baby
     * console.log(matches[1]); // and dad and baby
     * console.log(matches[2]); // and baby
     * 
     * 这个例子中的模式包含两个捕获组。最内部的捕获组匹配"and baby"，包含它的捕获组匹配"and
     * dad"或者"mom and dad and baby"。当把字符串传入exec()方法中之后，发现了一个匹配项。
     * 因为整个字符串本身与模式匹配，所以返回的数组matches的index属性值为0。数组中的第一项是
     * 匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容
    */

    /**
     * 对于exec()方法而言，即使在模式中设置了全局标志(g),它每次也只会返回一个匹配项。在不设置
     * 全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置
     * 全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。
     * var text = "cat, bat, sat, fat";
     * var pattern1 = /.at/;
     * var matches = pattern1.exec(text);
     * console.log(matches.index); // 0
     * console.log(matches[0]); // cat
     * console.log(pattern1.lastIndex); // 0
     * 
     * matches = pattern1.exec(text);
     * console.log(matches.index); // 0
     * console.log(matches[0]); // cat
     * console.log(pattern1.lastIndex); // 0
     * 
     * var pattern2 = /.at/g;
     * var matches = pattern2.exec(text);
     * console.log(matches.index); // 0
     * console.log(matches[0]); // cat
     * console.log(pattern2.lastIndex); // 3
     * 
     * matches = pattern2.exec(text);
     * console.log(matches.index); // 5
     * console.log(matches[0]); //bat
     * console.log(pattern2.lastIndex); // 8
     * 
     * 这个例子中的第一个模式 pattern1 不是全局模式，因此每次调用exec()返回的都是第一个匹配
     * 项("cat")。而第二个模式pattern2是全局模式，因此每次调用exec()都会返回字符串中的下一
     * 个匹配项，直至搜索到字符串末尾为止，此外，还应该注意模式的lastIndex属性的变化情况。在
     * 全局匹配模式下，lastIndex的值在每次调用exec()后都会增加，而在非全局模式则始终保持不变。
    */
  
    /**
     * 正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；
     * 否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，
     * 使用这个方法非常方便。因此，test()方法经常被用在if语句中，如下面的例子所示。
     * 
     * var text = "000-00-0000";
     * var pattern = /\d{3}-\d{2}-\d{4}/;
     * if(pattern.test(text)) {
     *   console.log("the pattern was matched"); // the pattern was matched
     * }
     * 
     * 在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示一条
     * 信息。这种用法经常出现在用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效
     * 就无关紧要了。
    */

    /**
     * RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则
     * 表达式的方式无关。例如
     * var pattern = new RegExp("\\[bc\\]at","gi");
     * console.log(pattern.toString()); // /\[bc\]at/gi
     * console.log(pattern.toLocaleString());// /\[bc\]at/gi
     * 
     * 即使上例中的模式是通过调用RegExp构造函数创建的，但toLocaleString()和toString()方法仍然
     * 会像它是以字面量形式创建的一样显示其字符串表示。
     * 正则表达式的valueOf()方法返回正则表达式本身。
    */


    /**
     * RegExp构造函数包含一些属性(这些属性在其他语言中被看成是静态属性)。这些属性适用于作用域中
     * 的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之
     * 处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和短属性名(Opera是例
     * 外，它不支持短属性名)。请看images文件夹的RegExp.png
     * 
     * 使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息。注意，在某些浏览器对这些
     * 属性名是不支持的可能会抛出undefined
     * 
     * var text = "this has been a short summer";
     * var pattern = /(.)hort/g;
     * if(pattern.test(text)){
     *   console.log(RegExp.input); // this has been a short summer
     *   console.log(RegExp.leftContext); // this has been a
     *   console.log(RegExp.rightContext); // summer
     *   console.log(RegExp.lastMatch); // short
     *   console.log(RegExp.lastParen); // s
     *   console.log(RegExp.multiline); // undefined 这里得到的是undefined是因为浏览器不支持该属性
     * }
     * 
     * 以上代码创建了一个模式，匹配任何一个字符串后跟着hort，而且把第一个字符放在了捕获组中。RegExp
     * 构造函数的各个属性返回了下列值：
     *  input属性返回了原始字符串；
     *  leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串；
     *  lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short。
     *  lastParen属性返回最近一次匹配的捕获组，即例子中的s。
    */

    /**
     * 如前所述，例子使用的长属性名都可以用对应的短属性名来代替。只不过，由于这些短属性名大都不是有效
     * 的ECMAscript标识符，因此必须通过方括号语法来访问它们，如下所示。
     *  var text = "this has been a short summer";
     * var pattern = /(.)hort/g;
     * if(pattern.test(text)){
     *  console.log(RegExp.$_);
     *  console.log(RegExp["$`"]); // this has been a short summer
     *  console.log(RegExp["$'"]); // this has been a
     *  console.log(RegExp["$&"]); // summer
     *  console.log(RegExp["$+"]); // short
     *  console.log(RegExp["$*"]);  // undefined 这里得到的是undefined是因为浏览器不支持该属性
     * }
    */

    /**
     * 除了上面介绍的几个属性之外，还有多达9个用于储存捕获组的构造函数属性。访问这些属性的语法是
     * RegExp.$1、RegExp.$2...RegExp.$9，分别用于储存第一、第二一直到第九个匹配的捕获组。在调
     * 用exec()或test()方法时，这些属性会被自动填充。然后，我们可以像下面这样来使用它们。
     * 
     * var text = "this has been a short summer";
     * var pattern = /(..)or(.)/g;
     * if (pattern.test(text)) {
     *  console.log(RegExp.$1); // sh
     *  console.log(RegExp.$2); // t
     * }
     * 
     * 这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。即使test()方法只返回一个
     * 布尔值，但RegExp构造函数的属性$1和$2也会被匹配相应捕获组的字符串自动填充。
    */
   

  </script>
</head>
<body>
  
</body>
</html>