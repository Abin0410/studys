<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>基本包装类型</title>
  <script>
    /*
      为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。
      这些类型与之前介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，
      每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调
      用一些方法来操作这些数据。来看下面的例子。

      var s1 = "some text";
      var s2 = s1.substring(2);
      console.log(s2); // me text

      这个例子中的变量s1包含一个字符串，字符串当然是基本类型值。而下一行调用了s1的substring()
      方法，并将返回的结果保存在了s2中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该
      有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自
      动完成了一系列的处理。当第二行代码访问s1时，访问过程处于一种读取模式，也就是要从内存中读
      取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。
        创建String类型的一个实例；
        在实例上调用指定的方法；
        销毁这个实例。
      可以将以上三个步骤想象成是执行了下列代码：

      var s1 = new String("some text");
      var s2 = s1.substring(2);
      var s1 = null;

      经过此番处理，基本的字符串就变得跟对象一样了。而且，上面这三个步骤也分别适用于Boolean和
      Number类型对应的布尔值和数字值。
      引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在
      执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一
      行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来
      看下面的例子：

      var s1 = "some text";
      s1.color = "red";
      console.log(s1.color); // undefined

      在此，第二行代码试图为字符串s1添加一个color属性。但是，当第三行代码再次访问s1时，其color
      属性不见了。问题的原因就是第二行创建的String对象在执行第三行代码时已经被销毁了。第三行代
      码又创建自己的String对象，而该对象没有color属性。
      当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必
      要的情况下再这样做，因为这种做法很容易让人分不清自己在处理基本类型还是引用类型的值。对基
      本包装类型的实例调用typeof会返回"object"，而且所有基本包装类型的对象在转换为布尔类型时
      值都是true。

      Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：
      var obj = new Object("some text");
      console.log(obj instanceof String); // true

      把字符串传给Object构造函数，就会创建String的实例；而传入数值参数会得到Number的实例，传
      如布尔值参数就会得到Boolean的实例。

      要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如：
      var value = "25";
      var number = Number(value); // 转型函数
      console.log(typeof number); // number

      var obj = new Number(value); // 构造函数
      console.log(typeof obj); // object

      在这个例子中，变量number中保存的是基本类型的值25，而变量obj中保存的是Number的实例。
      尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。
      而每个基本包装类型都提供了操作相应值的便捷方法。
    */

    /* Boolean类型不常用所以这里不讲了 */

    /* ----------------Number类型-------------- */
    /*
      Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递
      相应的数值。下面是一个例子。

      var numberObject = new Number(10);

      Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法
      返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。之前还介绍过，可以为
      toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，如下面的例子所示：
      var num = 10;
      console.log(num.toString()); // 10
      console.log(num.toString(2)); // 1010
      console.log(num.toString(8)); // 12
      console.log(num.toString(10)); // 10
      console.log(num.toString(16)); // a

      除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。
      其中，toFixed()方法会按照指定的小数返回数值的字符串表示，例如：

      var num = 10;
      console.log(num.toFixed(2)); // 10.00

      这里给toFixed()方法传入了数值2，意思就是显示几位小数。于是，这个方法返回了"10.00"，即
      以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的
      值就会舍入，如下面的例子所示：
      var num = 10.005;
      console.log(num.toFixed(2)); // 10.01
      能够自动舍入的特性，使得toFixed()方法很合适处理货币值。

      Number对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化Number
      类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用typeof和instanceof操作符测试
      基本类型数值与引用类型数值时，得到的结果完全不同，如下面的例子所示。

      var numberObject = new Number(10);
      var numberValue = 10;
      console.log(typeof numberObject); // object
      console.log(typeof numberValue); // number
      console.log(numberObject instanceof Number); // true
      console.log(numberValue instanceof Number); // false

      在使用typeof操作符测试基本类型数值时，始终会返回"number"，而在测试Number对象时，则会返回"object"。
      类似地，Number对象时Number类型的实例，而基本类型的数值则不是。
    */
  
    /* -----------String类型------------- */
    /* 
      String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。

      var stringObject = new String("hello world");
      console.log(stringObject);

      String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocaleString()
      和toString()方法，都返回对象所表示的基本字符串值。
      String类型的每个实例都有一个length属性，表示字符串中包含多个字符。来看下面的例子。
      var stringObject = new String("hello world");
      console.log(stringObject.length); // 11

      这个例子输出了字符串"hello world"中的字符数量，即"11"。应该注意的是，即使字符串中包含双字节字符，
      每个字符也仍然算一个字符。

      String类型提供了巨多方法，用于辅助完成对ECMAScript中字符串的解析和操作。

      --------------字符方法-------------
      两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt()。这两个方法都接收一个参数，即基于
      0的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符（ECMAScript中没有字符
      类型）。例如：
      var stringValue = "hello world";
      console.log(stringValue.charAt(1)); // e

      字符串"hello world"位置1处的字符是"e"，因此调用charAt(1)就返回了"e"。如果你想得到的不是字符而
      是字符编码，那么就要像下面这样使用charCodeAt()了。
      var stringValue = "hello world";
      console.log(stringValue.charCodeAt(1)); // 101

      这个例子输出的是"101"，也就是小写字母"e"的字符编码。
      ECMAScript5还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引来
      访问字符串中的特定字符，如下面的例子所示。

      var stringValue = "hello world";
      console.log(stringValue[1]); // e

      --------------字符串操作方法-------------
      下面介绍与操作字符串有关的几个方法。第一个就是concat()，用于将一或多个字符串拼接起来，返回拼接得
      到的新字符串。先来看个例子。

      var stringValue = "hello ";
      var res = stringValue.concat("world");
      console.log(stringValue); // hello
      console.log(res); // hello world

      在这个例子中，通过stringValue调用concat()方法返回的结果是"hello world"----但stringValue的值
      则保持不变。实际上，concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。再
      看一个例子：

      var stringValue = "hello ";
      var res = stringValue.concat("world","!");
      console.log(stringValue); // hello
      console.log(res); // hello world!

      这个例子将"world"和"!"拼接到了"hello"的末尾。虽然concat()是专门用来拼接字符串的方法，但实践中使
      用更多的还是加号操作符(+)。而且，使用加号操作符在大多数情况下都比使用concat()方法要简便易行（特别
      是在拼接多个字符串的情况下）。

      ECMAScript还提供了三个基于字符串创建新字符串的方法：slice()、substr()、和substring()。这三个方法
      都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二
      个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是
      子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传
      递第二个参数，则将字符串的末尾作为结束位置。与cancat()方法一样，slice()、substr()和substring()也不
      会修改字符串本身的值---它们只是返回一个基本类型的字符串值，对原始字符串没有任何音响。请看下面的例子：
      
      var stringValue = "hello world";
      console.log(stringValue.slice(3)); // lo world
      console.log(stringValue.substring(3)); // lo world
      console.log(stringValue.substr(3)); // lo world
      console.log(stringValue.slice(3,7)); // lo w
      console.log(stringValue.substring(3,7)); // lo w
      console.log(stringValue.substr(3,7)); // lo worl

      这个例子比较了以相同方式调用slice()、substr()和substring()得到的结果，而且多数情况下的结果是相同的。
      在指定一个参数3的情况下，这三个方法都是返回"lo world"，因为"hello"中的第一个"l"处于位置3。而在指定两
      个参数3和7的情况下，slice()和substring()返回"lo w"（"world"中的"o"处于位置7，因此结果中不包含"o"），
      但substr()返回"lo worl"，因为它的第二个参数指定的是要返回的字符个数。

      在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的
      长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方
      法会把所有负值参数都转换为0。下面来看例子。
      var stringValue = "hello world";
      console.log(stringValue.slice(-3)); // "rld"
      console.log(stringValue.substring(-3)); // "hello world"
      console.log(stringValue.substr(-3)); // "rld"
      console.log(stringValue.slice(3, -4)); // "lo w"
      console.log(stringValue.substring(3, -4)); // "hel"
      console.log(stringValue.substr(3,-4)); // ""

      这个例子清晰地展示了上述三个方法之间的不同行为。在给slice()和substr()传递一个负值参数时，它们的行为相同。
      这是因为-3会被转换为8（字符串长度加参数11+(-3)=8），实际上相当于调用了slice(8)和substr(8)。但substring()
      方法则返回了全部字符串，因为它将-3转换为0。
      当第二个参数是负值是，这三个方法的行为各不相同。slice()方法会把第二个参数转换为7，这就相当于调用了
      slice(3,7)，因此返回"lo w"。substring()方法会把第二个参数转换为0，使调用变成了substring(3,0)，而由于这个
      方法会将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了substring(0,3)。substr()也会将第
      二个参数转换为0，这也就意味着返回包含零个字符串的字符串，也就是一个字符串。

      字符串位置方法：
      有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。这两个方法都是从一个字符串中搜索给定的字
      符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法的区别在于：indexOf()方法从字符串
      的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。看一个例子：
      var stringValue = "hello world";
      console.log(stringValue.indexOf('o')); // 4
      console.log(stringValue.lastIndexOf('o')); // 7

      子字符串"o"第一次出现的位置是4，即"hello"中的"o"；最后一次出现的位置是7，即"world"中的"o"。在这个字符串中
      仅出现了一次，那么indexOf()和lastIndexOf()会返回相同的位置值。
      这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的
      位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符，
      下面的例子：

      var stringValue = "hello world";
      console.log(stringValue.indexOf("o",6)); // 7
      console.log(stringValue.lastIndexOf("o",6)); // 4

      在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于indexOf()是从位置6（字母"w"）
      开始向后搜索，结果再位置7找到了"o"，因此它返回7。而lastIndexOf()是从位置6开始向前搜索。结果找到了"hello"
      中的"o"，因此它返回4。在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的
      子字符串，如下面的例子所示：
      var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
      var positions = new Array();
      var pos = stringValue.indexOf("e");
      while (pos > -1) {
        positions.push(pos);
        pos = stringValue.indexOf("e",pos + 1);
        console.log(pos);
      }
      console.log(positions); // 3,24,32,35,52

      这个例子通过不断增加indexOf()方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找到了"e"在字符串中
      的初始位置；而进入循环后，则每次都给indexOf()传递上一次的位置加1。这样，就确保了每次新搜索都从上一次找到
      的子字符串的后面开始。每次搜索返回的位置依次被保存在数组position中，以便将来使用。

      trim()方法
      ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后
      返回结果。例如：
      var stringValue = "     hello world     ";
      var trimmeedStringValue = stringValue.trim();
      console.log(stringValue); //      hello world
      console.log(trimmeedStringValue); // hello world

      由于trim()返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。

      字符串大小写转换方法
      接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、
      toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。其中，toLowerCase()和toUpperCase()是两个经典
      的方法，借鉴自java.lang.string中的同名方法。而toLocaleLowCase()和toLocaleUpperCase()方法则是针对特定
      地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言会为Uncode大小写转换应用特殊
      的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子：
      var stringValue = "hello world";
      console.log(stringValue.toLocaleUpperCase()); // HELLO WORLD
      console.log(stringValue.toUpperCase()); // HELLO WORLD
      console.log(stringValue.toLocaleLowerCase()); // hello world
      console.log(stringValue.toLowerCase()); // hello world

      以上代码调用的toLocaleUpperCase()和toUpperCase()都返回了"HELLO WORLD"，就像调用toLocaleLowerCase()和
      toLowerCase()都返回"hello world"一样。一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使
      用针对地区的方法更稳妥一些。

      字符串的模式匹配方法
      String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上调用这个方法，本质上与
      调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。请看
      下面的例子：

        var text = "cat bat sat, fat";
        var pattern = /.at/;
        var matches = text.match(pattern);
        console.log(matches.index); // 0
        console.log(matches[0]); // cat
        console.log(pattern.lastIndex); // 0
        console.log(matches); // 自己可以打印数组看一下

      本例中的match()方法返回了一个数组；如果是调用RegExp对象的exec()方法并传递本例中的字符串作为参数，那么也
      会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的
      捕获组匹配的字符串。
      另一个用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp对象指
      定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，
      search()方法始终是从字符串开头向后查找模式。看下面的例子。

        var text = "cat, bat, sat, fat";
        var pos = text.search(/at/);
        console.log(pos) // 1
      这个例子中的search()方法返回1，即"at"在字符串中第一次出现的位置。

      为了简化替换子字符串的操作，ECMAScript提供了replace()方法。这个方法接受两个参数：第一个参数可以是一个
      RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如
      果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，
      而且要指定全局（g）标志，如下所示。
        var text = "cat, bat, sat, fat";
        var result = text.replace("at","ond");
        console.log(result); // cond, bat, sat, fat

        result = text.replace(/at/g, "ond");
        console.log(result); // cond, bond, sond, fond
      在这个例子中，首先传入replace()方法的是字符串"at"和替换用的字符串"ond"。替换的结果是把"cat"变成了"cond"，
      但字符串中的其他字符并没有影响。然后，通过将第一个参数修改为带有全局标志的正则表达式，就将全部"at"替换成了
      "ond"。如果第二个参数是字符串，还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。

      var text = "cat, bat, sat, fat";
      result = text.replace(/(.at)/g, "word ($1)");
      console.log(result); // word (cat), word (bat), word (sat), word (fat)

      在此，每个以"at"结尾的单词都被替换了，替换结果是"word"后跟一对圆括号，而圆括号中使被字符序列$1所替换的单词。
      replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传
      递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传
      递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项.....，但最后两个参数仍然分别是
      模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项。使用函数作为
      replace()方法的第二个参数可以实现更加精细的替换操作，请看下面这个例子。
      function htmlEscape(text) {
        return text.replace(/[<>"&]/g,function(match, pos, originalText){
          switch(match) {
            case "<":
              return "&lt;";
            case ">":
              return "&gt";
            case "&":
              return "&amp;";
            case "\"":
              return "&guot;";
          }
        });
      }
      console.log(htmlEscape("<p class=\"greeting\">Hello world!</p>"));
      // &lt;p class=&guot;greeting&guot;&gtHello world!&lt;/p&gt

      这里，我们为插入HTML代码定义了函数htmlEscape()，这个函数能够转义4个字符：小于号、大于号、和号以及引号。
      实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定
      HTML实体的函数。

      最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并
      将结果放到一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。
      split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。请看下面
      的例子：
        var colorText = "red,blue,green,yellow";
        var colors1 = colorText.split(",");
        var colors2 = colorText.split(",",2);
        var colors3 = colorText.split(/[^\,]+/);

        console.log(colors1); // ["red", "blue", "green", "yellow"]
        console.log(colors2); // ["red", "blue"]
        console.log(colors3); // ["", ",", ",", ",", ""]
      
      在这个例子中，colorText是逗号分隔的颜色名字符串。基于该字符串调用split(",")会得到一个包含其中颜色的
      数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可以为split()方法传递第二个参数2。
      最后，通过使用正则表达式，还可以取得包含逗号字符的数组。需要注意的是，在最后一次调用split()返回的数组
      中，第一项和最后一项是两个字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头
      （即子字符串"red"）和末尾（即子字符串"yellow"）。
    */
  </script>
</head>
<body>
  
</body>
</html>