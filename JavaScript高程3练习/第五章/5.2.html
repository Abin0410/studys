<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Array类型</title>
  <script>
    /**
     * 除了object之外，Array类型恐怕是ECMAscript中最常用的类型了，而且与其他
     * 多数语言中的数组有着相当大的区别，虽然与其他语言中的数组都是数据的有序列表
     * 但是与其他语言不同的是，ECMAscript数组的每一项可以保存任何类型的数据。也
     * 就是说，可以用数组的第一个位置保存字符串，第二个位置来保存数值，第三个位置
     * 来保存对象，ECMAscript数组的大小是可以动态调整的，即可以随着数据的添加自动
     * 增长以容纳新增数据。
    */
    
    /**
     * 创建数组的基本方式有两种。第一种是使用Array构造函数，看下面的例子:
     * var colors = new Array();
     * console.log(colors); //Array(0)
    */
    
    /**
     * 如果提前想知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会
     * 自动变成length属性的值，下面的代码将创建length值为20的数组
     * 
     * var colors = new Array(20);
     * console.log(colors) //(20);
     * 
     * 也可以向Array构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符
     * 串值的数组:
     * 
     * var colors = new Array("red","blue","green");
     * console.log(colors) //["red", "blue", "green"]
    */
  
    /**
     * 当然，给构造函数创建一个值也可以创建数组。但这时候问题就复杂一点了，因为如果
     * 传递的是数值，则会按照该数值创建包含给定项数的数组，而如果传递的是其他类型的
     * 参数，则会创建包含那个值的只有一项的数组。请看下面的例子：
     * var colors = new Array(3);  //创建一个包含3项的数组
     * var names = new Array("green"); //创建一个包含1项，即字符串"green"的数组
     * console.log(colors); //(3)
     * console.log(names); //["green"]
    */
  
    /**
     * 另外，在使用Array构造函数时也可以省略new操作符。下面这个例子等价于上面的例子
     * var colors = Array(3);
     * var names = Array("green");
     * console.log(colors);
     * console.log(names);
    */
  
    /**
     * 创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的
     * 方括号表示，多个数组项之间以逗号隔开
     * var colors = ["red","green","blue"];
     * var names = [];
     * console.log(colors);
     * console.log(names);
    */

    /**
     * 在读取和设置数组的值时，要使用方括号并提供相应值的基于0的数字索引，看下面的例子
     * var colors = ["red","green","blue"];
     * console.log(colors[0]); //显示第一项
     * colors[2] = "black"; //修改第三项
     * colors[3] = "brown"; //新增第四项 因为是从0开始 所以color[3]实际上是第四位
     * console.log(colors) //["red", "green", "black", "brown"]
    */

    /**
     * 在数组的项数保存在其length属性中，这个属性始终会返回0或更大的值。看下面的例子
     * var colors = ["red","green","blue"];
     * var names = [];
     * console.log(colors.length); //3
     * console.log(names.length); //0
    */
    
    /**
     * 数组length属性很有特点----它不只是读的。通过设置这个属性，可以从数组的末尾移
     * 除项或向数组添加新项。看下面的例子。
     * var colors = ["red","blue","green"];
     * colors.length = 2;
     * console.log(colors[2]); //undefined
     * 
     * 在这个例子中的数组一开始有3个值，将其length属性设置为2会移除最后一项，结果再
     * 访问colors[2]就会显示undefined了。如果将其length设置为大于数组项数的值，则
     * 新增的每一项都会取得undefined，如下所示:
     * 
     * var colors = ["red","blue","green"];
     * colors.length = 4
     * console.log(colors[3]); //undefined
     * 
     * 在此，虽然colors数组包含3个项，但把它的length属性设置成了4。这个数组不存在
     * 位置3，所以访问这个位置的值就得到了undefined。
    */
  
    /**
     * 利用length属性也可以方便在数组末尾添加新项，如下所示:
     * var colors = ["red","blue","green"];
     * colors[colors.length] = "black"; //在位置3添加了一种颜色
     * colors[colors.length] = "brown"; //在位置4添加了一种颜色
     * console.log(colors); // ["red", "blue", "green", "black", "brown"]
    */
  
    /**
     * 由于数组最后一项的索引始终是length-1，因此下一个新项的位置就是length。每当
     * 在数组末尾添加一项后，其length属性都会自动更新以反应这一变化。也就是说，上面
     * 的例子第二行中的colors[colors.length]为位置3添加了一个值，最后一行的colors[colors.length]
     * 则为位置4添加了一个值。当把一个值放在超出当前数组大小的位置上时，数组就会重新
     * 计算其长度值，即长度值等于最后一项的索引加1，如下面所示：
     * 
     * var colors = ["red","blue","green"];
     * colors[99] = "black";
     * console.log(colors.length); //100
     * 
     * 在这个例子中，我们向colors数组的位置99插入了一个值，结果数组新长度(length)
     * 就是100(99+1)。而位置3到位置98实际上都是不存在的，所以访问它们都将返回undefined
    */

    // ------------------检查数组--------------------
    /**
     * 确定某个对象是不是数组的经典问题。对于一个网页，或者一个全局作用域而言，使用instanceof
     * 操作符就能得到满意的结果:
     * if(value instanceof Array){
     * }
     * 还有一个Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组
    */

    //--------------------转换方法----------------------
    /**
     * 如前所述，所有对象都具有toLocaleString(),toString()和valueof()方法。其中
     * 调用valueof()返回的还是数组本身，而调用数组的toString()方法会返回由数组中
     * 每一个只的字符串形式拼接而成的一个以逗号分隔的字符串。实际上，为了创建这个
     * 字符串会调用数组每一项的toString()方法。
    */

    /**
     * 这个例子中，我们首先显式地调用toString()方法，以便返回数组的字符串表示，每个
     * 值的字符串表示拼接成了一个字符串，中间以逗号分隔。接着调用valueOf()方法，
     * 而最后一行代码直接将数组传递给了alert()。由于alert()要接收字符串参数，所以
     * 它会在后台调用toString()方法，由此会得到与直接调用toString()方法相同结果。
     * var colors = ["red","blue","green"];
     * console.log(colors.toString()); //red,blue,green
     * console.log(colors.valueOf()); //["red", "blue", "green"]
     * alert(colors); //red,blue,green
    */

    /**
     * 在这个例子里定义了两个对象:person1和person2。而且还分别为每一个对象定义了一个
     * toString()方法和一个toLocaleString()方法，这两个方法返回不同的值。然后，创建
     * 一个包含前面定义的两个对象的数组。在将数组传递给alert()时，输出结果是"xiaozhu,xiaoming"
     * 因为调用了数组每一项的toString()方法(同样，这与下一行显式调用toString()方法得
     * 到的结果相同)。而当调用数组的toLocaleString()方法时，输出结果是"xiaoli,xiaohong",
     * 原因是调用了数组每一项的toLocaleString()
     * var person1 = {
     *  toLocaleString: function () {
     *     return "xiaoli";
     *   },     
     *   toString: function () {
     *     return "xiaozhu";
     *   }
     * };
     * var person2 = {
     *   toLocaleString: function () {
     *     return "xiaohong";
     *   },
     *   toString: function () {
     *     return "xiaoming";
     *   }
     * }
     * var people = [person1,person2];
     * alert(people); //xiaozhu,xiaoming
     * alert(people.toString()); //xiaozhu,xiaoming
     * alert(people.toLocaleString()); //xiaoli,xiaohong
    */
  
    /**
     * 如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收
     * 一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。下面的例子:
     * var colors = ["red","blue","green"];
     * console.log(colors.join(",")); //red,blue,green
     * console.log(colors.join("||")); //red||blue||green
     * 
     * 这里，我们使用了join()方法重现了toString()方法输出。在传递逗号的情况下，得到了
     * 以逗号分隔的数组值。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串
     * "red||blue||green"。如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符
    */

    //----------------栈方法--------------

    // 数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种LIFO(后进先出)
    // 的数据结构，也就是最新添加的项最早被移除，而栈中项的插入(叫做推入)和移除(叫做弹出)，只发生
    // 在一个位置-----栈的顶部。ECMAscript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。

    // push()方法可以接收任何数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
    // 而pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项，请看下面的例子:
    // var colors = new Array(); //创建一个数组
    // var count = colors.push("red","blue"); //推入两项
    // console.log(count); // 2

    // count = colors.push("green"); // 推入另一项
    // console.log("count",count); //3

    // var item = colors.pop(); // 取得最后一项
    // console.log("item",item); // "green"
    // console.log(colors.length); //2

    // 数组可以看成是栈(代码本身没什么区别，而push()和pop()都是数组默认的方法)  
    // 可以将栈方法与其他数组方法连用，像下面的例子一样。
    // var colors = ["red", "blue"];
    // colors.push("brown"); // 添加一项
    // colors[3] = "black"; // 添加一项
    // console.log(colors.length); //4

    // var item = colors.pop(); // 取得最后一项
    // console.log(item); //black
    // 在此，我们首先用两个值来初始化一个数组。然后，使用push()添加第三个值，再通过直接在
    // 位值3上赋值来添加第四个值。而在调用pop()时，该方法返回了字符串"black"，即最后一个
    // 添加到数组的值

    // --------------- 队列方法 -----------
    // 队列数据结构的访问规则是(先进先出)。队列的列表的末端添加项，从列表的前端移除项。由于
    // push()是向数组末端添加项的方法，因此要模拟队列只需要一个从数组前端取得项的方法。使用
    // shift()就是实现这一操作的数组方法。它能够移除数组中的第一项并返回该项，同时将数组长度
    // 减1。结合使用shift()和push方法，可以像使用队列一样使用数组。

            //------------push()-------------
    // 这个例子首先使用push()方法创建了一个包含3个颜色名称的数组。代码中加粗的那一行使用
    // shift()方法从数组中取得了第一项，即"red"。在移除第一项之后，"green"就变成了第一项
    // 而"black"则变成了第二项，数组也只包含两项了。
    // var colors = new Array(); //创建一个数组
    // var count = colors.push("red","green"); //添加两项
    // alert(count); //2
    // count = colors.push("black"); // 添加一项
    // alert(count); //3
    // var item = colors.shift(); // 取得第一项
    // alert(item); //red 
    // alert(colors.length); //2

          //------------unshift()-------------
    // ECMAscript还为数组提供了一个unshift()方法。顾名思义，unshift()与shift()的用途
    // 相反:它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用unshift()和pop()方法，
    // 可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项，请看下面的例子:
    // var colors = new Array(); //创建一个数组
    // var count = colors.unshift("red","green"); //推入两项
    // console.log(count); //2

    // count = colors.unshift("black"); //推入另一项
    // console.log(count); //3

    // var item = colors.pop(); //取得最后一项
    // console.log(item); //green
    // console.log(colors.length) //2

    //------------重排序方法--------------
    // 数组中与已存在两个可以直接用来重排序的方法:reverse()和sort()。reverse()方法会
    // 反转数组项的顺序。请看下面的例子。
    // var values = [1,2,3,4,5];
    // values.reverse();
    // alert(values);// 5,4,3,2,1

            //-------------sort()--------------
    // 但是上面的reverse()方法不够灵活，因此才有了sort()方法。
    // 在默认情况下，sort()方法按升序排列数组项----即最小的值位于最前面，最大的值排在最后面。
    // 为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以
    // 确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串，如下所示。
    // var values = [0,1,5,10,15];
    // values.sort();
    // alert(values); //0,1,10,15,5
    // 可见，即使例子中值的顺序没有问题，但sort()方法也会根据测试字符串的结果改变原来的顺序。
    // 因为数组5虽然小于10，但在进行字符串比较时，"10"则位于"5"的前面，于是数组的顺序就被修改了。
    // 因此sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。

    // 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等
    // 则返回0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数:
    // function compare (value1,value2) {
    //   if (value1 < value2) {
    //     return -1;
    //   } else if (value1 > value2) {
    //     return 1;
    //   } else {
    //     return 0;
    //   }
    // }
    // var values = [0,1,5,10,15];
    // values.sort(compare);
    // alert(values) // 0,1,5,10,15
    // 上面的比较函数可以适用于大多数数据类型，只要将其作为参数传递给sort()方法即可

    // 在将比较函数传递到sort()方法之后，数值仍然保持了正确的升序。当然，也可以通过比较函数
    // 产生降序排序的结果，交换比较函数返回值就ok了。
    // function compare (value1, value2) {
    //   if (value1 < value2) {
    //     return 1;
    //   } else if (value1 > value2) {
    //     return -1;
    //   } else {
    //     return 0;
    //   }
    // }
    // var values = [0,1,5,10,15];
    // values.sort(compare);
    // alert(values); //15,10,5,1,0


    // 当然，如果只想反转数组原来的顺序，使用reverse()方法更快一些。对于数值类型或者其valueOf()
    // 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一
    // 个值即可。
    // function compare(value1, value2) {
    //   return value2 - value1;
    // }
    // var values = [0,1,5,10,15];
    // values.sort(compare);
    // console.log(values)

    //----------------操作方法---------------

    // concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前
    // 数组一个副本，然后将接收的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()
    // 方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一个或多个
    // 数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会
    // 被简单地添加到结果数组的末尾。
    
          //--------------concat()-------------------
    //下面的例子中开始定义了一个包含3个值的数组colors。然后基于colors调用了concat()方法，并
    // 传入字符串"yellow"和一个包含"black"和"brown"的数组。最终，结果数组colors2包含了"red"
    // "green","blue","yellow","black"和"brown"。至于原来的数组colors，其值仍然保持不变。
    // var colors = ["red","green","blue"];
    // var colors2 = colors.concat("yellow",["black", "brown"]);
    // alert(colors); // red,green,blue
    // alert(colors2); // red,green,blue,yellow,black,brown

          //--------------slice()-------------------
    // slice()方法，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或
    // 两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数
    // 指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项
    // -----但不包括结束位置的项。注意，slice()方法不会影响原始数组。


    // 在这个例子中，开始定义的数组colors包含5项。调用slice()并传入1会得到包含4项的新数组；
    // 因为是从位置1开始复制，所以会包含"green"而不会包含"red"。这个数组colors2中包含的是
    // "green","blue","yellow","purple"。接着，我们再次调用slice()并传入了1和4，表示复制
    // 从位置1开始，到位置3结束。结果数组colors3中包含了"green","blue","yellow"
    // var colors = ["red","green","blue","yellow","purple"];
    // var colors2 = colors.slice(1);
    // var colors3 = colors.slice(1,4);
    // alert(colors2); //green,blue,yellow,purple
    // alert(colors3); //green,blue,yellow
    // 最后补充一点如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。
    // 例如，在一个包含5项的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同的。如果
    // 结束位置小于起始位置，则返回空数组。

          //----------------splice()----------------
    // 我们来介绍splice()方法，这个方法恐怕算是最强大的数组方法了，它有很多种用法。splice()
    // 的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。
      // 1.删除:可以删除任意数量的项，只需指定2个参数:要删除的第一项的位置和要删除的项数。
          //例如，splice(0,2)会删除数组中的前两项。
      // 2.插入:可以向指定位置插入任意数量的项，只需提供3个参数:起始位置，0(要删除的项数)
          // 和要插入的项，如果要插入多个项，可以再传入第4、第5，以至任意多个项。例如，
          // splice(2,0,"red","green")会从当前数组的位置2开始插入字符串"red"和"green"。
      // 3.替换:可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数:
          // 起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。
          // 例如，splice(2,1,"red","green")会删除当前数组位置2的项，然后再从位置2开始
          // 插入字符串"red"和"green"。
    
    // splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何
    // 项，则返回一个空数组)。
    // var colors = ["red","green","blue"];
    // var removed = colors.splice(0,1); //删除第一项
    // console.log(colors); // ["green", "blue"]
    // console.log(removed); // ["red"] 返回的数组中只包含一项

    // removed = colors.splice(1,0,"yellow","orange"); // 从位置1开始插入两项
    // console.log(colors); // ["green", "yellow", "orange", "blue"]
    // console.log(removed); // 返回的是一个空数组

    // removed = colors.splice(1,1,"red","purple");
    // console.log(colors); // ["green", "red", "purple", "orange", "blue"]
    // console.log(removed); // ["yellow"]

    // 上面的例子首先定义了一个包含3项的数组colors。第一次调用splice()方法只是删除了这个
    // 数组的第一项，之后colors还包含"green"和"blue"两项。第二次调用splice()方法时在位置1
    // 插入了两项，结果colors中包含了"green", "yellow", "orange", "blue"。这一次操作没
    // 有删除项，因此返回了一个空数组。最后一次调用splice()方法删除了位置1处的一项，然后又
    // 插入了"red"和"purple"。在完成以上操作之后，数组colors中包含的是"green", "red", 
    // "purple", "orange", "blue"

          //--------------位置方法---------------
    //indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
    // ECMAscript为数组实例添加了两位置方法:indexOf()和lastIndexOf()。这两个方法都接收
    // 两个参数:要查找的项和(可选的)表示查找起点位置的索引。其中，indexOf()方法从数组的开头
    // (位置0)开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。
    // 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数
    // 与数组中的每一项时，会使用全等操作符;(===)
    // var numbers = [1,2,3,4,5,4,3,2,1];
    // console.log(numbers.indexOf(3)); //2
    // console.log(numbers.lastIndexOf(4)); //5

    // var person = { name:"xiaoli" };
    // var people = [{name:"xiaohong"}];

    // var morePeople = [person]; 

    // console.log(people.indexOf(person)); //-1
    // console.log(morePeople.indexOf(person)); //0
  </script>
</head>
<body>
</body>
</html>