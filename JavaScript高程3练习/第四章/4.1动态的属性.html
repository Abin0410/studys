<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>动态的属性</title>
  <script>
    // 定义基本类型和引用类型值的方式是类似的:创建一个变量并为该变量赋值。
    // 但是当这个值保存到变量中以后，对不同类型值可以执行的操作则相差很远，大不相同
    // 对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除属性
    // 和方法。

    /**
     *以下的代码创建一个对象并将其保存在了一个变量person中，然后我们为该对象
     *添加了一个名为name的属性，并将字符串值"xiaoli"赋给了这个属性。紧接着通过
     *console.log()函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除
     *则这个属性将一直存在
     * let person = new Object();
     * person.name = "xiaoli";
     * console.log(person.name) //xiaoli
    **/
    
    /**
     *!切记只能给引用类型动态的添加属性，在这个例子中，我们为字符串name定义了
     *一个名为age的属性，并为该属性赋值27。但是在下面一行访问这个属性时，发现
     *该属性不见了。所以切记只有引用类型才能动态的添加属性
     * let name = "xiaoli";
     * name.age = 27;
     * console.log(name.age); //undefined
    **/
//----------------------------------------------------------------------------------------------
    /**
     * 复制变量值
     * 在从一个变量从另外一个变量复制基本类型值和引用类型值时,也存在不同，如果
     * 从一个变量向另外一个变量复制基本类型的值，会在变量对象上创建一个新值，然后
     * 把该值复制到位新变量分配的位置上
     * **/
    
    /**
     * 下面的例子中num1中保存的值时5，当使用num1的值来初始化num2时，num2中也保存了值5。
     * 但num2中的5与num2中的5是完全独立的，该值只是num1中5的副本。两个变量可以参与任何操作
     * 而不会相互影响。
     *  var num1 = 5;
     *  var num2 = num1;
     * **/

    /**
     * 从另外一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量
     * 分配的空间中。不同的是这个值的副本实际上是一指针，而这个指针指向存储在堆中的一个对象
     * 复制操作结束后，两个变量实际上将引用同一个对象。因此改变其中一个变量，就会影响另外一变量
     * var obj1 = new Object();
     * var obj2 = obj1;
     * obj1.name = "xiaoli";
     * console.log(obj2.name);
     * **/

    //-----------------------------------------------------------------------------------
    /**
     * 传递参数
     * JavaScript中所有函数的参数都是按值传递的。也就说是把函数外部的值复制给函数内部的参数和
     * 复制变量值一样。访问变量由按值和按引用两种方式，而参数只能按值传递。
     * 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数,或者arguments对象中的一个元素)。
     * 在向参数传递引用类型的值时，会把这个值的内存中的地址复制给一个局部变量，因此这个局部变量的变化
     * 会反映在函数的外部。
     * **/
    /**
     * 下面的例子addTen()函数有一个参数num，而参数实际上就是函数的局部变量。在调用这个函数时，变量count
     * 作为参数被传递给函数，这个变量的值是20。于是数值20被复制给参数num以便在addTen()中使用。在函数内部，
     * 参数num的值被加上了10。但这一个变化不会影响函数外部的count变量。num与变量count是互不相识的，它们
     * 仅仅是具有相同的值。
     * function addTen(num){
     *  num += 10;
     *  return num
     * }
     * var count = 20;
     * var result = addTen(count);
     * console.log(count); //20
     * console.log(result); //30
     * **/

    /**
     * 下面的例子中创建一个对象，并将其保存在了变量person中。然后，这个变量被传递到serName()函数中之后就
     * 被复制给了obj。在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，
     * obj也会按引用来访问同一个对象。于是，当在函数内部为obj添加name属性后，函数外部的person也将有所放映
     * 因为person指向的对象在堆内存中只有一个，而且是全局对象
     * 
     * function setName(obj) {
     *  obj.name = "xiaoli";
     * }
     * var person = new Object();
     * setName(person);
     * console.log(person.name); //xiaoli
     * 
    */
    /**
     * 这个例子与前一个例子的唯一区别就是在setName()函数中添加了两行代码，在把person传递给setName()后，
     * 其name属性被设置为"xiaoli"。然后又将一个对象赋给变量obj，同时将其name属性设置为"xiaoyan"。如果
     * person是按引用传递的，那么person就会自动修改为指向其name属性值为"xiaoyan"的新对象，但是，接下来
     * 再访问person.name时，显示的值仍然是"xiaoli"。这说明即使在函数内部修改了参数的值，但是原始的引用
     * 仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在
     * 函数执行完毕后立即销毁
     * 
     * function setName(obj) {
     *  obj.name = "xiaoli";
     *  obj = new Object(); //重新定义了一个对象
     *  obj.name = "xiaoyan" //为该对象定义了一个带不同值的name属性
     * }
     * var person = new Object;
     * setName(person);
     * console.log(person.name) //xiaoli
     * */

    // 可以把JavaScript函数的参数想象成局部变量
  </script>
</head>
<body>
  
</body>
</html>