<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>没有块级作用域</title>
  <script>
    // ---------------没有块级作用域----------------
    /**
     * JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，
     * 由花括号封闭的代码块都有自己的作用域(在JavaScript来讲的话，就是它们自己的执行环境)
     * 因而支持根据条件来定义变量。例如下面的代码
     * if (true) {
     *  var color = "blue";
     * }
     * console.log(color);
     * 这里是一个if语句中定义了变量color。如果在其他强类型语言中，color会在if语句执行
     * 完毕后被销毁。但在js中，if语句中的变量声明会将变量添加到当前的执行环境(在这里是全局环境)
     * 中。
    */
  
    /**
     * 在使用for语句时尤其要牢记这一差异。看下面的例子，对于有块级作用域的语言来说，for语句
     * 初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于js来说，由for语句创建
     * 的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中
     * for (var i = 0; i<10; i++) {
     *  // doSomething(i);
     * }
     * console.log(i); //10
    */
    
    // ----------------声明变量-----------------
    /** 
     * 使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部
     * 环境中。 在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量
     * 会自动被添加到全局环境。
     */

    /**
     * 下面的例子中函数add()定义了一个名为sum的局部变量，该变量包含加法操作的结果。虽然结果值
     * 从函数中返回了，但变量sum在函数外部是访问不到的。
     * function add(num1, num2) {
     *  var sum = num1 + num2;
     *  return sum;
     * }
     * var result = add(10 ,20);
     * console.log(result); //30
     * console.log(sum) //报错
    */
  
    /**
     * 如果省略这个例子中的var关键字，那么当add()执行完毕后，sum也将可以访问到
     * 在这个例子中的变量sum在被初始化赋值时没有使用var关键字。于是当调用完add()
     * 之后，添加到全局环境中的变量sum将继续存在，即使函数已经执行完毕，后面的代码
     * 依旧可以访问它，！切记 不声明而直接初始化变量是一个常见的错误做法，可能会导致
     * 意外。建议在初始化变量之前，一定要先声明。
     * function add(num1, num2) {
     *  sum = num1 + num2
     *  return sum;
     * }
     * var result = add(10, 20);
     * console.log(result); //30
     * console.log(sum); //30
    */
    //-----------------查询标识符-------------------- 
    /**
     * 当在某个环境中为了读取或者写入而引用一个标识符时，必须通过搜索来确定该标识符实际
     * 代表什么。搜索过程从作用域链的前端开始，向上逐级查询与定名字匹配的标识符。如果在
     * 局部环境中找到了该标识符，搜索过程停止，变量就绪。如果局部环境中没有找到该变量名
     * 则继续沿作用域向上搜索。搜索过程一直追溯到全局环境的变量对象。如果在全局环境中也
     * 没有找到这个标识符，那证明这个变量没有声明
    */
    
    /**
     * 调用下面例子中的函数getColor()时会引用变量color。为了确定变量color的值，将开始
     * 一个两步的搜索过程。首先，搜索getColor()的变量对象，查找其中是否包含一个名为color
     * 的标识符。在没有找到的情况下，搜索继续到下一个变量对象(全局环境的变量对象)，然后在
     * 那里找到了名为color的标识符。因为搜索到了定义这个变量的变量对象，所以搜索过程宣告结束！
     * var color = "blue";
     * function getColor () {
     *   return color;
     * }
     * console.log(getColor()); //blue
    */
  
    /**
     * 在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量
     * 对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。请看
     * 下一个例子
    */
    /**
     * 修改后的代码在getColor()函数中声明了一个名为color的局部变量。调用函数时，该变量会被声明
     * 而当函数中的第二行代码执行时，意味着必须找到并返回变量color的值。搜索过程首先从局部
     * 环境中开始，而且在这里发现了一个名为color的变量，其值为"red"。因为变量已经找到了
     * 所以搜索就停止了，return语句就使用这个局部变量，并为函数返回"red"。也就是说任何位于
     * 局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。
     * ！访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链
     * var color = "blue";
     * function getColor () {
     *  var color = "red";
     *  return color;
     * }
     * console.log(getColor()); //red 
    */
  </script>
</head>
<body>
  
</body>
</html>