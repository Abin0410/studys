/*
  js给出错误信息是在真正运行时，而ts是在输入代码的过程中，编辑器就会给出错误信息。

  ## 编译器
  程序都是由文件所构成，这些文件由一个特殊的程序解析，也就是编译器。转换成抽象语法树（`AST`）。`AST`是去掉了空白、注释和缩进用的
  进制符或空格之后的数据结构。编译器把`AST`转换成一种叫做字节码的底层表示。字节码再传给运行时计算，得到最终结果。也就是说，运行程序
  就是让运行时计算由编译器从源码解析得来的`AST`生成的字节码。

  步骤如下：
  1. 把程序解析为`AST`（抽象语法树）。
  2. 把`AST`编译成字节码。
  3. 运行时计算字节码。

  `TS`并不是直接编译成字节码，而是先编译成`JS`代码。那么`TS`又是如何保证代码变得更安全的呢？

  `TS`编译器生成`AST`之后，真正运行代码前，`TS`会对代码做类型检查。如果加入类型检查和运行`JS`代码，`TS`的编译过程大致如下图。
  ![]("../images/1.png");

  `TSC`把`TS`编译成`JS`代码时，是不会考虑类型。类型只在类型检查这步使用。

  ### 类型系统
  类型系统有两种：一种通过显式句法告诉编译器所有值的类型，另一种自动推导值的类型。`TS`具备这两种类型系统，可以显式注解类型，也可以让`TS`推导多数类型。
  ```js
  // 显式注解类型
  let num: number = 1
  let isBoolean: boolean = false
  let str: string = "1"

  // 推导多数类型
  let num = 1
  let isBoolean = false
  let str = "1"

  ### 类型字面量
  类型字面量仅表示一个值的类型，例如：
  ```js
  let num: 123 = 235
  let bool: true = false
  ```


  ### 明确赋值
  在`TS`中声明一个变量时，需要给这个变量赋上明确的值。不然就会出现报错。`TS`会检测在使用该变量时是否已经明确的为该变量赋值了。例如：
  ```js
  let num: number
  let j = num + 1  // 抛出错误 Variable 'num' is used before being assigned
  ```
  这种情况在`JS`中是完全允许的，但在`TS`中不能这么操作。即便`num`没有显式注解类型，`TS`也会抛出错误。
*/


