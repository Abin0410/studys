<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## Generator函数

      ### 协程
      传统的编程语言中早有异步编程解决方案（其实是多任务的解决方案），其中一种叫作“协程”，意思是
      多个线程互相协作，完成异步任务。

      协程有点像函数，又有点像线程。它的运行流程大致如下。
      * 第一步，协程A开始执行。
      * 第二步，协程A执行到一半，进入暂停状态，执行权转移到协程B中。
      * 第三步，（一段时间后）协程B交还执行权。
      * 第四步，协程A恢复执行。
      上面流程的协程A就是异步任务，因为它分成两段执行。

      举例来说，读取文件的协程写法如下。
      ```js
      function *asyncJob() {
        // ...
        let f = yield readFile(fileA);
        // ...
      }
      ```
      上面代码的函数`asyncJob`是一个协程，它的奥妙在于其中的`yield`命令。它表示执行到此处时，执行权交给其他协程。也就是说，
      `yield`命令是异步两个阶段的分界线。

      协程遇到`yield`命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点是，代码的写法非常像同步操作，如果
      去掉`yield`命令，是一模一样的。

      ### 协程的Generator函数实现
      Generator函数是协程在ES6中的实现，最大特点就是可以交出函数的执行权（即暂停执行）。

      整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方都用`yield`语句注明、Generator函数
      的执行方法如下。
      ```js
      function* gen(x) {
        let y = yield x + 2;
        return y;
      }

      let g = gen(1);

      console.log(g.next()); // {value: 3, done: false}
      console.log(g.next()); // {value: undefined, done: true}
      ```
      上面的代码中，调用Generator函数会返回一个内部指针（即遍历器）`g`。这是Generator函数和普通函数的另一个地方，就是执行它不会返回
      结果，而是返回指针对象。调用指针`g`的`next`方法可以移动内部指针（即执行异步任务的第一段），指向第一个遇到的`yield`语句，上例
      是执行到`x + 2`为止。

      换句话说，`next`方法的作用是分阶段执行Generator函数。每次调用`next`方法都会返回一个对象，表示当前阶段的信息（`value`属性和`done`属性）。
      `value`属性是`yield`语句后面表达式的值，表示当前阶段的值；`done`属性是一个布尔值，表示Generator函数是否执行完毕，也就是是否还有下一个阶段。

      ### Generator函数的数据交换和错误处理

      Generator函数可以暂停和恢复执行，这是它能封装异步任务的根本原因。除此之外，还有两个特性使它可以作为异步编程的完整解决方案：函数体内外的
      数据交换和错误处理机制。

      `next`返回值的`value`属性是Generator函数向外输出数据；`next`方法还可以接收参数，向Generator函数体内输入数据。
      ```js
      function* gen(x) {
        let y = yield x + 2;
        return y;
      }

      let g = gen(1);

      console.log(g.next()); // {value: 3, done: false}
      console.log(g.next(2)); // {value: 2, done: true}
      ```
      上面的代码中，第一个`next`方法的`value`属性返回表达式`x + 2`的值`3`，第二个`next`方法带有参数`2`，这个参数可以传入Generator函数，作为上个
      阶段异步任务的返回结果，被函数体内的变量`y`接收。因此，这一步的`value`属性返回的就是`2`（变量y的值）。

      Generator函数内还可以部署错误处理代码，捕获函数体外抛出的错误。
      ```js
      function* gen(x) {
        try {
          let y = yield + 2;
        } catch (e) {
          console.log(e);
        }
        return y;
      }

      let g = gen(1);
      console.log(g.next());
      g.throw('出错了');
      // 出错了
      ```
      上面代码的最后一行中，Generator函数体外使用指针对象的`throw`方法抛出的错误可以被函数体内的`try...catch`代码块捕获。这意味着，出错的代码
      和处理错误的代码实现了时间和空间上的分离，这对于异步编程来说是很重要的。

      ### 异步任务的封装
      下面看看如何使用Generator函数执行一个真实的异步任务。
      ```js
      let fetch = require('node-fetch');

      function* gen() {
        let url = 'https://api.github.com/users/github';
        let result = yield fetch(url);
        console.log(result.bio);
      }
      ```
      上面的代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据中解析信息。这段代码非常像同步操作，除了增加
      `yield`命令以外。

      执行这段代码的方法如下。
      ```js
      let g = gen();
      let result = g.next();

      result.value.then(function(data) {
        return data.json();
      }).then((data) => {
        g.next(data);
      });
      ```
      上面的代码中首先执行Generator函数获取遍历器对象，然后使用`next`方法（第二行）执行异步任务的第一阶段。由于Fetch模块返回一个Promise对象，因此
      要用`then`方法调用下一个`next`方法。

      可以看到，虽然Generator函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。
    */
    
  </script>
</body>
</html>