<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## 基本概念

      ### 异步
      所谓的异步，就是一个任务不是连续完成的，可以理解成这个任务被分成两段，先执行第一段，然后执行其他的任务，等
      做好准备后再回来执行第二段。

      比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，
      等到操作系统返回文件后再接着执行任务的第二段（处理文件）。这种不连续的执行叫作异步。

      相应地，连续执行叫作同步，由于连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能等待。

      ### 回调函数
      JavaScript语言对异步编程的实现就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里，等到重新执行
      第二个任务时直接调用这个函数。回调函数的英文名字`callback`。
      ```js
      fs.readFile('/etc/password', 'utf-8', function(err, data) {
        if (err) {
          throw err;
          console.log(data);
        }
      });
      ```
      上面的代码中，`readFile`函数的第三个参数就是回调函数，也就是任务的第二段。等到操作系统返回`/etc/password`文件
      以后，回调函数才会执行。

      ### Promise
      回调函数本身并没有问题，它的问题出现在多个回调函数嵌套上，假设读取A文件之后再读取B文件，代码如下。
      ```js
      fs.readFile(fileA, 'utf-8', function(err, data) {
        fs.readFile(fileB, 'utf-8', function(err, data) {
          // ...
        });
      });
      ```
      如果依次读取以上两个文件的话，就会出现多重嵌套。代码不是纵向发展，而是横向发展，就会乱成一团，没办法管理。因为
      多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数都要跟着修改。这种情况被称为“回调函数地狱”。

      Promise对象就是为了解决这个问题被提出的。它并不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套改写为链式调用。采用
      Promise连续读取多个文件的写法如下。
      ```js
      let readFile = require('fs-readfile-promise');

      readFile(fileA)
      .then((data) => {
        console.log(data.toString());
      })
      .then(() => {
        return readFile(fileB);
      })
      .then((data) => {
        console.log(data.toString());
      })
      .catch((err) => {
        console.log(err);
      });
      ```
      上面的代码中，使用了`fs-readfinle-promise`模块，它的作用就是返回Promise版本的`readFile`函数。Promise提供`then`方法加载回调函
      数，`catch`方法捕捉执行过程中抛出的错误。
      
      可以看到，Promise的写法只是回调函数的改进，使用`then`方法以后，异步任务的两段执行更清楚了，除了这些之外，并没有什么新意。

      Promise最大的问题就是代码冗余，原来的任务被Promise包装之后，无论什么操作，一眼看去都是一堆`then`的堆积，原来的语义变得很不清楚。
    */
    
  </script>
</body>
</html>