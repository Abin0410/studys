<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## Promise.allSettled()
      `Promise.allSettled()`方法也是接受一组Promise实例作为参数，包装成一个新的Promise实例。只有等到所有的参数实例都返回结果，
      不管`fulfilled`还是`rejected`，包装实例才会结束。 
      ```js
      const p1 = new Promise((resolve, reject) => {
        setTimeout(() => resolve(1), 1000);
      });

      const p2 = new Promise((resolve, reject) => {
        setTimeout(() => resolve(2), 2000);
      });

      const p3 = new Promise((resolve, reject) => {
        setTimeout(() => reject('哎呀，出bug了'), 3000);
      });

      const p = Promise.allSettled([p1, p2, p3]);

      p.then((res) => {
        console.log(res);
      });
      // [
      //   {status: "fulfilled", value: 1}, 
      //   {status: "fulfilled", value: 2}, 
      //   {status: "rejected", reason: "哎呀，出bug了"}
      // ]
      ```
      上面的代码有三个Promise实例，都设置了不同毫秒的定时器，然后3秒后在` Promise.allSettled`的回调函数`then`中打印出结果。
      这是因为`Promise.allSettled`要等这三个`Promise`实例执行完后才会得到结果。

      该方法会返回新的Promise实例，一旦结束，状态总会是`fulfilled`，并不会变成`rejected`。状态变成`fulfilled`后，Promise的监听函数
      接收的参数是一个数组，每个成员对应一个传入`Promise.allSettled()`的Promise实例。
      ```js
      const resolved = Promise.resolve(1);
      const reject = Promise.reject(-100);
      
      const allSettled = Promise.allSettled([resolved, reject]);

      allSettled.then(res => {
        console.log(res);
      });
      // [
      //   {status: "fulfilled", value: 1},
      //   {status: "rejected", reason: -100}
      // ]
      ```
      上面的代码中，`Promise.allSettled()`的返回值`allSettled`，状态只能变成`fulfilled`。它的监听函数接收的参数是一个数组`res`。该
      数组的每个成员都是一个对象，对应传入`Promise.allSettled()`的两个Promise实例。每个对象都有`status`属性，这个属性的值只能是字符串
      `fulfilled`或`rejected`。当`fulfilled`时，对象有一个`value`属性，如果时`rejected`就有`reason`属性。对应两种状态的返回值。

      有时候不关异步操作的结果，只关心这些操作有没有结束。`Promise.allSettled()`方法就显得很有用。
    */
    
  </script>
</body>
</html>