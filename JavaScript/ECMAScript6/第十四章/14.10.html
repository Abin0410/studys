<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## Promise.resolve()

      `Promise.resolve()`方法返回一个以给定解析后的`Promise`对象。也就是说，将现有的对象转为Promise对象。
      ```js
      const promise1 = Promise.resolve('foo');
      // 等于
      const promise2 = new Promise(resolve => resolve('foo'));
      ```
      `Promise.resolve()`方法的参数分成四种情况。

      #### 参数是一个Promise实例
      如果参数是Promise实例，`Promise.resolve`不会做任何修改，原封不动地返回这个实例。

      #### 参数是一个`thenable`对象
      `thenable`对象也就是包含有`then`方法的对象，例如下面的对象。
      ```js
      let thenable = {
        then(resolve, reject) {
          resolve(100);
        }
      };
      ```
      `Promise.resolve()`方法会把这个对象转成Promise对象，然后立即执行`thenable`对象的`then()`方法。
      ```js
      let thenable = {
        then(resolve, reject) {
          resolve(100);
        }
      };

      let p = Promise.resolve(thenable);
      
      p.then(res => { 
        console.log(res);
      });
      // 100
      ```
      上面的代码中，`thenable`对象的`then()`方法执行后。对象`p`的状态就变成了`resolved`，然后立即执行最后那个`then`方法，输出了`100`。

      #### 参数不是含有`then()`方法的对象，或者是根本不是对象
      如果参数是一个原始值，或者是一个不含`then()`方法的对象，则`Promise.resolve()`方法返回一个新的Promise对象，状态是`resolved`。
      ```js
      const p = Promise.resolve('Hello');

      p.then(res => {
        console.log(res);
      });
      // Hello
      ```
      上面的代码生成一个新的Promise对象实例`p`。由于字符串`Hello`不属于异步操作，返回Promise实例的状态从一生成就是`resolved`，所以
      回调函数会立即执行。`Promise.resolve()`方法的参数，也会传给回调函数。

      #### 不带有任何参数
      `Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的Promise对象。

      如果希望得到一个Promise对象，直接调用`Promise.resolve()`方法。
      ```js
      const p = Promise.resolve();

      p.then(() => {
        console.log('Hello Wrold');
      });

      // Hello Wrold
      ```
      上面的代码中，变量`p`就是一个Promise对象。

      要注意的是，立即`resolve()`的Promise对象，是在本轮“事件循环”结束时执行，而不是在下一轮“事件循环”的开始执行。
      ```js
      setTimeout(() => {
        console.log(1);
      }, 0);

      Promise.resolve().then(() => {
        console.log(2);
      });

      console.log(3);

      // 3
      // 2
      // 1
      ```
      上面的代码中，`setTimeout(fn, 0)`在下一轮“事件循环”开始时执行，`Promise.resolve()`是在本轮“事件循环”结束时执行，`console.log('one')`则
      是立即执行，因此最先输出。
    */
    
  </script>
</body>
</html>