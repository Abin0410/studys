<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## Math对象的扩展
      ES6在Math对象上新增了17个跟数学有关的方法。这些方法都是静态方法，只能在Math对象上调用。

      ### Math.trunc()
      `Math.trunc`方法用于去除一个数的小数部分，返回整数部分。
      ```js
      console.log(Math.trunc(4.1)); // 4
      console.log(Math.trunc(4.9)); // 4
      console.log(Math.trunc(-4.1)); // -4
      console.log(Math.trunc(-4.9)); // -4
      console.log(Math.trunc(-0.1234)); // -0
      ```
      对于非数值，`Math.trunc`内部使用`Number`方法将其转为数值。
      ```js
      console.log(Math.trunc('123.456')); // 123
      console.log(Math.trunc(true)); // 1
      console.log(Math.trunc(false)); // 0
      console.log(Math.trunc(null)); // 0
      ```
      对于空值和无法截取整数的值，返回`NaN`。
      ```js
      console.log(Math.trunc(NaN)); // NaN
      console.log(Math.trunc('foo')); // NaN
      console.log(Math.trunc()); // NaN
      console.log(Math.trunc(undefined)); // NaN
      ```
      对于没有部署这个方法的环境，可以用下面的代码模拟。
      ```js
      Math.trunc = Math.trunc || function(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
      }
      ```

      ### Math.sign()
      `Math.sign`方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。会返回五种值。
      * 参数为正数，返回`+1`;
      * 参数为负数，返回`-1`;
      * 参数为0，返回0;
      * 参数为-0，返回-0;
      * 其他值，返回`NaN`。
      
      ```js
      console.log(Math.sign(-5)); // -1
      console.log(Math.sign(5)); // 1
      console.log(Math.sign(0)); // 0
      console.log(Math.sign(-0)); // -0
      console.log(Math.sign(NaN)); // NaN
      ```
      如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回`NaN`。
      ```js
      console.log(Math.sign('')); // 0
      console.log(Math.sign(true)); // 1
      console.log(Math.sign(false)); // 0
      console.log(Math.sign(null)); // 0
      console.log(Math.sign('9')); // 1
      console.log(Math.sign('foo')); // NaN
      console.log(Math.sign()); // NaN
      console.log(Math.sign(undefined)); // NaN
      ```
      对于没有部署这个方法的环境，可以用下面的代码模拟。
      ```js
      Math.sign = Math.sign || function(x) {
        x =+ x;
        if (x === 0 || isNaN(x)) {
          return x;
        }
        return x > 0 ? 1 : -1;
      }
      ```

      ### Math.cbrt()

      `Math.cbrt()`方法用于计算一个数的立方根。
      ```js
      console.log(Math.cbrt(-1)); // -1
      console.log(Math.cbrt(0)); // 0
      console.log(Math.cbrt(1)); // 1
      console.log(Math.cbrt(2)); // 1.2599210498948732
      ```
      对于非数值，`Math.cbrt()`方法内部也是先使用`Number()`方法将其转为数值。
      ```js
      console.log(Math.cbrt('8')); // 2
      console.log(Math.cbrt('hello')); // NaN
      ```
      对于没有部署这个方法的环境，可以用下面的代码模拟。
      ```js
      Math.cbrt = Math.cbrt || function(x) {
        var y = Math.pow(Math.abs(x), 1/3);
        return x < 0 ? -y : y;
      }
      ```

      ### Math.clz32()
      `Math.clz32()`方法将参数转为32位无符号整数的形式，然后返回这个32位值里面有多少个前导0。
      ```js
      console.log(Math.clz32(0)); // 32
      console.log(Math.clz32(1)); // 31
      console.log(Math.clz32(1000)); // 22
      console.log(Math.clz32(0b01000000000000000000000000000000)); // 1
      console.log(Math.clz32(0b00100000000000000000000000000000)); // 2
      ```
      上面代码中，0的二进制形式全为0，所以有32个前导0；1的二进制形式是0b1，只占1位，所以32位
      之中有31个前导0；1000的二进制形式是`0b1111101000`，一共有10位，所以32位之中有22个前导0。

      左移运算符（`<<`）与`Math.clz32`方法直接相关。
      ```js
      console.log(Math.clz32(0)); // 32
      console.log(Math.clz32(1)); // 31
      console.log(Math.clz32(1 << 1)); // 30
      console.log(Math.clz32(1 << 2)); // 29
      console.log(Math.clz32(1 << 29)); // 2
      ```
      对于小数，`Math.clz32`方法只考虑整数部分。
      ```js
      console.log(Math.clz32(3.2)); // 30
      console.log(Math.clz32(3.9)); // 30
      ```
      对于空值或其他类型的值，`Math.clz32`方法会将它们先转为数值，然后再计算。
      ```js
      console.log(Math.clz32()); // 32
      console.log(Math.clz32(NaN)); // 32
      console.log(Math.clz32(Infinity)); // 32
      console.log(Math.clz32(null)); // 32
      console.log(Math.clz32('foo')); // 32
      console.log(Math.clz32([])); // 32
      console.log(Math.clz32({})); // 32
      console.log(Math.clz32(true)); // 31
      ```

      ### Math.imul()
      `Math.imul`方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。
      ```js
      console.log(Math.imul(2, 4)); // 8
      console.log(Math.imul(-1, 8)); // -8
      console.log(Math.imul(-2, -2)); // 4
      ```
      如果只考虑最后32位，大多数情况下，`Math.imul(a, b)`和`a * b`的结果相同的，即该方法等同于`(a * b)|0`的效果。
      之所以需要部署这个方法，是因为js有精度限制，超过2的53次方的值无法精确表示。这就是说，对于那些很大的数的乘法，
      地位数值往往都是不精确的，`Math.imul`方法可以返回正确的低位数值。

      ### Math.fround()
      `Math.fround`方法返回一个数的32位但精度浮点数形式。

      对于32位单精度格式来说，数值精度是24个二进制位（1位隐藏与23位有效位），所以对于-2的24次方到2的24次方之间的整数
      （不含两个端点），返回结果与参数本身一致。
      ```js
      console.log(Math.fround(0)); // 0
      console.log(Math.fround(1)); // 1
      console.log(Math.fround(2 ** 24 - 1)); // 6.7.html:159 16777215
      ```
      如果参数的绝对值大于2的24次方，返回结果开始丢失精度。
      ```js
      console.log(Math.fround(2 ** 24)); // 16777216
      console.log(Math.fround(2 ** 24 + 1)); // 16777216
      ```
      `Math.fround`方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会
      不同于值，否则返回值不变（即与64位双精度值一致）。
      ```js
      // 未丢失有效精度
      console.log(Math.fround(1.125)); // 1.125
      console.log(Math.fround(7.25)); // 7.25

      // 丢失有效精度
      console.log(Math.fround(0.3)); // 0.30000001192092896
      console.log(Math.fround(0.7)); // 0.699999988079071
      console.log(Math.fround(1.0000000123)); // 1
      ```
      对于`NaN`和`Infinity`，此方法返回原值。对于其它类型的非数值，`Math.fround`方法会先将其转为数值，再返回单精度浮点数。
      ```js
      console.log(Math.fround(NaN)); // NaN
      console.log(Math.fround(Infinity)); // Infinity

      console.log(Math.fround('5')); // 5
      console.log(Math.fround(true)); // 1
      console.log(Math.fround(null)); // 0
      console.log(Math.fround([])); // 0
      console.log(Math.fround({})); // NaN
      ```
      对于没有部署这个方法的环境，可以用下面的代码模拟。
      ```js
      Math.fround = Math.fround || function(x) {
        return new Float32Array([x])[0];
      }
      ```

      ### Math.hypot()
      `Math.hypot`方法返回返回参数的平方和平方根。
      ```js
      console.log(Math.hypot(3, 4)); // 5
      console.log(Math.hypot(3, 4, 5)); // 200 7.0710678118654755
      console.log(Math.hypot()); // 0
      console.log(Math.hypot(NaN)); // NaN
      console.log(Math.hypot(3, 4, 'foo')); // NaN
      console.log(Math.hypot(3, 4, '5')); // 204 7.0710678118654755
      console.log(Math.hypot(-3)); // 3
      ```
      上面代码中，3的平方加上4的平方，等于5的平方。

      如果参数不是数值，`Math.hypot`方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。

      ### 对数方法
      ES6新增了4个对数相关方法。

      #### Math.expm1()
      `Math.expm1(x)`返回e的x次方-1，即`Math.exp(x) - 1`。
      ```js
      console.log(Math.expm1(-1)); // -0.6321205588285577
      console.log(Math.expm1(0)); // 0
      console.log(Math.expm1(1)); // 1.718281828459045
      ```
      对于没有部署这个方法的环境，可以用下面的方法模拟。
      ```js
      Math.expm1 = Math.expm1 || function(x) {
        return Math.exp(x) - 1;
      }
      ```

      #### Math.log1p()
      `Math.log1p(x)`方法返回`1 + x`的自然对数，即`Math.log(1 + x)`。如果`x`小于-1，返回`NaN`。
      ```js
      console.log(Math.log1p(1)); // 0.6931471805599453
      console.log(Math.log1p(0)); // 0
      console.log(Math.log1p(-1)); // -Infinity
      console.log(Math.log1p(-2)); // NaN
      ```
      对于没有部署这个方法的环境，可以用下面的代码模拟。
      ```js
      Math.log10 = Math.log10 || function(x) {
        return Math.log(x) / Math.LN10;
      }
      ```
      #### Math.log2()
      `Math.log2(x)`返回以2为底的`x`的对数。如果`x`小于0，则返回`NaN`。
      ```js
      console.log(Math.log2(3)); // 1.584962500721156
      console.log(Math.log2(2)); // 1
      console.log(Math.log2(1)); // 0
      console.log(Math.log2(0)); // -Infinity
      console.log(Math.log2(-2)); // NaN
      console.log(Math.log2(1024)); // 10
      console.log(Math.log2(1 << 29)); // 29
      ```
      对于没有部署这个方法的环境，可以用下面的代码模拟。
      ```js
      Math.log2 = Math.log2 || function(x) {
        return Math.log(x) / Math.LN2;
      }
      ```

      ### 双曲函数方法
      ES6新增了6个双曲函数方法。
      * `Math.sinh(x)`返回`x`的双曲正弦（hyperbolic sine）
      * `Math.cosh(x)`返回`x`的双曲余弦（hyperbolic cosine）
      * `Math.tanh(x)`返回`x`的双曲正切（hyperbolic tangent）
      * `Math.asinh(x)`返回`x`的反双曲正弦（inverse hyperbolic sine）
      * `Math.acosh(x)`返回`x`的反双曲余弦（inverse hyperbolic cosine）
      * `Math.atanh(x)`返回`x`的反双曲正切（inverse hyperbolic tangent）
    */
    
  </script>
</body>
</html>