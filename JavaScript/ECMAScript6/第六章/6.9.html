<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>

<body>
  <script>
    /*
      ## BigInt类型
      JavaScript所有数字都保存成64位浮点数，这给数值的表示带来了两个限制。一是数值的精度只能到53个二进制位
      （相当于16个十进制位），大于这个范围的整数，JavaScript是无法精确表示的，这使得JavaScript不适合进行
      科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript无法表示，会返回`Infinity`。
      ```js
      // 超过53个二进制位的数值，无法保持精度
      console.log(Math.pow(2, 53) === Math.pow(2, 53) + 1); // true

      // 超过2的1024次方的数值，无法表示
      console.log(Math.pow(2, 1024)); // Infinity
      ```

      ES2020引入了一种新的数据类型BigInt（大整数），来解决这个问题，这是ECMAScript的第八种数据类型。BigInt
      只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。
      ```js
      const a = 2172141653n;
      const b = 15346349309n;

      // BigInt 可以保持精度
      console.log(a * b); // 33334444555566667777n

      // 普通整数无法保持精度
      console.log(Number(a) * Number(b)); // 33334444555566670000
      ```
      为了与Number类型区别，BigInt类型的数据必须添加后缀`n`。
      ```js
      console.log(123); // 普通整数
      console.log(123n); // BigInt

      // BigInt的运算
      console.log(1n + 2n); // 3n
      ```
      BigInt同样可以使用各种进制表示，都要加上后缀`n`。
      ```js
      console.log(0b1101n); // 二进制 13n
      console.log(0o777n); // 八进制 511n
      console.log(0xFFn); // 十六进制 255n
      ```
      BigInt与普通整数是两种值，它们之间并不相等。
      ```js
      console.log(42n === 42); // false
      ```
      `typeof`运算符对于BigInt类型的数据会返回`bigint`。
      ```js
      console.log(typeof 123n); // bigint
      ```
      BigInt可以使用负号（-），但是不能使用正号（+），因为会和asm.js冲突。
      ```js
      console.log(-42n); // 这是正确的
      console.log(+42n); // 报错了
      ```
      JavaScript以前不能计算70的阶乘，因为超出了可以表示的精度。
      ```js
      let p = 1;
      for (let i = 1; i <= 70; i++) {
        p *= i;
      }
      console.log(p); // 1.197857166996989e+100
      ```
      现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就可以了。
      ```js
      let p = 1n;
      for (let i = 1n; i <= 70n; i++) {
        p *= i;
      }
      console.log(p);
      // 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000n
      ```

      ### BigInt对象
      JavaScript原生提供`BigInt`对象，可以用作构造函数生成BigInt类型的数值。转换规则基本与`Number()`一致，将其他类型
      的值转为BigInt。
      ```js
      console.log(BigInt(123)); // 123n
      console.log(BigInt('123')); // 123n
      console.log(BigInt(false)); // 0n
      console.log(BigInt(true)); // 1n
      ```
      `BigInt()`构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。
      ```js
      console.log(new BigInt()); // Uncaught TypeError: BigInt is not a constructor
      console.log(BigInt(undefined)); // Uncaught TypeError: Cannot convert undefined to a BigInt
      console.log(BigInt(null)); // Uncaught TypeError: Cannot convert null to a BigInt
      console.log(BigInt('123n')); // Uncaught SyntaxError: Cannot convert 123n to a BigInt
      console.log(BigInt('abc')); // Uncaught SyntaxError: Cannot convert abc to a BigInt
      ```
      上面代码中，尤其值得注意字符串`123n`无法解析成Number类型，所以会报错。

      参数如果是小数，也会报错。
      ```js
      console.log(BigInt(1.5));
      // Uncaught RangeError: The number 1.5 cannot be converted to a BigInt because it is not an integer
      console.log(BigInt('1.5'));
      // Uncaught SyntaxError: Cannot convert 1.5 to a BigInt
      ```
      BigInt对象继承了Object对象的两个实例方法。
      * `BigInt.prototype.toString()`
      * `BigInt.prototype.valueOf()`
      它还继承了Number对象的一个实例方法。
      * BigInt.prototype.toLocaleString()
      此外，还提供了三个静态方法。
      * `BigInt.asUintN(width, BigInt)`：给定的BigInt转为0到2的width次方-1之间对应的值。
      * `BigInt.asIntN(width, BigInt)`：给定的BigInt转为-2的width-1次方到2的width-1次方-1之间对应的值。
      * `BigInt.parseint(string, [radix])`：和`Number.parseInt()`类似，将一个字符串转成指定进制的BigInt。
      ```js
      const max = 2n ** (64n - 1n) - 1n;

      console.log(BigInt.asIntN(64, max));
      // 9223372036854775807n
      console.log(BigInt.asIntN(64, max + 1n));
      // -9223372036854775808n
      console.log(BigInt.asUintN(64, max + 1n));
      // 9223372036854775808n
      ```
      上面代码中，`max`是64位带符号的BigInt所能表示的最大值。如果对这个值加`1n`，`BigInt.asIntN()`将会
      返回一个负值，因为这时新增的一位将被解释为符号位。而`BigInt.asUintN()`方法由于不存在符号位，所以可以
      正确返回结果。

      如果`BigInt.asIntN()`和`BigInt.asUintN()`指定的位数，小于数值本身的位数，那么头部的位将被舍弃。

      下面
    */
  </script>
</body>

</html>