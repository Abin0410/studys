<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>

<body>
  <script>
    /*
      ## BigInt类型
      JavaScript所有数字都保存成64位浮点数，这给数值的表示带来了两个限制。一是数值的精度只能到53个二进制位
      （相当于16个十进制位），大于这个范围的整数，JavaScript是无法精确表示的，这使得JavaScript不适合进行
      科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript无法表示，会返回`Infinity`。
      ```js
      // 超过53个二进制位的数值，无法保持精度
      console.log(Math.pow(2, 53) === Math.pow(2, 53) + 1); // true

      // 超过2的1024次方的数值，无法表示
      console.log(Math.pow(2, 1024)); // Infinity
      ```

      ES2020引入了一种新的数据类型BigInt（大整数），来解决这个问题，这是ECMAScript的第八种数据类型。BigInt
      只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。
      ```js
      const a = 2172141653n;
      const b = 15346349309n;

      // BigInt 可以保持精度
      console.log(a * b); // 33334444555566667777n

      // 普通整数无法保持精度
      console.log(Number(a) * Number(b)); // 33334444555566670000
      ```
      为了与Number类型区别，BigInt类型的数据必须添加后缀`n`。
      ```js
      console.log(123); // 普通整数
      console.log(123n); // BigInt

      // BigInt的运算
      console.log(1n + 2n); // 3n
      ```
      BigInt同样可以使用各种进制表示，都要加上后缀`n`。
      ```js
      console.log(0b1101n); // 二进制 13n
      console.log(0o777n); // 八进制 511n
      console.log(0xFFn); // 十六进制 255n
      ```
      BigInt与普通整数是两种值，它们之间并不相等。
      ```js
      console.log(42n === 42); // false
      ```
      `typeof`运算符对于BigInt类型的数据会返回`bigint`。
      ```js
      console.log(typeof 123n); // bigint
      ```
      BigInt可以使用负号（-），但是不能使用正号（+），因为会和asm.js冲突。
      ```js
      console.log(-42n); // 这是正确的
      console.log(+42n); // 报错了
      ```
      JavaScript以前不能计算70的阶乘，因为超出了可以表示的精度。
      ```js
      let p = 1;
      for (let i = 1; i <= 70; i++) {
        p *= i;
      }
      console.log(p); // 1.197857166996989e+100
      ```
      现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就可以了。
      ```js
      let p = 1n;
      for (let i = 1n; i <= 70n; i++) {
        p *= i;
      }
      console.log(p);
      // 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000n
      ```

      ### BigInt对象
      JavaScript原生提供`BigInt`对象，可以用作构造函数生成BigInt类型的数值。转换规则基本与`Number()`一致，将其他类型
      的值转为BigInt。
      ```js
      console.log(BigInt(123)); // 123n
      console.log(BigInt('123')); // 123n
      console.log(BigInt(false)); // 0n
      console.log(BigInt(true)); // 1n
      ```
      `BigInt()`构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。
      ```js
      console.log(new BigInt()); // Uncaught TypeError: BigInt is not a constructor
      console.log(BigInt(undefined)); // Uncaught TypeError: Cannot convert undefined to a BigInt
      console.log(BigInt(null)); // Uncaught TypeError: Cannot convert null to a BigInt
      console.log(BigInt('123n')); // Uncaught SyntaxError: Cannot convert 123n to a BigInt
      console.log(BigInt('abc')); // Uncaught SyntaxError: Cannot convert abc to a BigInt
      ```
      上面代码中，尤其值得注意字符串`123n`无法解析成Number类型，所以会报错。

      参数如果是小数，也会报错。
      ```js
      console.log(BigInt(1.5));
      // Uncaught RangeError: The number 1.5 cannot be converted to a BigInt because it is not an integer
      console.log(BigInt('1.5'));
      // Uncaught SyntaxError: Cannot convert 1.5 to a BigInt
      ```
      BigInt对象继承了Object对象的两个实例方法。
      * `BigInt.prototype.toString()`
      * `BigInt.prototype.valueOf()`
      它还继承了Number对象的一个实例方法。
      * BigInt.prototype.toLocaleString()
      此外，还提供了三个静态方法。
      * `BigInt.asUintN(width, BigInt)`：给定的BigInt转为0到2的width次方-1之间对应的值。
      * `BigInt.asIntN(width, BigInt)`：给定的BigInt转为-2的width-1次方到2的width-1次方-1之间对应的值。
      * `BigInt.parseint(string, [radix])`：和`Number.parseInt()`类似，将一个字符串转成指定进制的BigInt。
      ```js
      const max = 2n ** (64n - 1n) - 1n;

      console.log(BigInt.asIntN(64, max));
      // 9223372036854775807n
      console.log(BigInt.asIntN(64, max + 1n));
      // -9223372036854775808n
      console.log(BigInt.asUintN(64, max + 1n));
      // 9223372036854775808n
      ```
      上面代码中，`max`是64位带符号的BigInt所能表示的最大值。如果对这个值加`1n`，`BigInt.asIntN()`将会
      返回一个负值，因为这时新增的一位将被解释为符号位。而`BigInt.asUintN()`方法由于不存在符号位，所以可以
      正确返回结果。

      如果`BigInt.asIntN()`和`BigInt.asUintN()`指定的位数，小于数值本身的位数，那么头部的位将被舍弃。
      ```js
      const max = 2n ** (64n -1n) - 1n;

      console.log(BigInt.asIntN(32, max)); // -1n
      console.log(BigInt.asUintN(32, max)); // 4294967295n
      ```
      上面代码中，`max`是一个64位的BigInt，如果转为32位，前面的32位都会舍弃。

      下面是`BigInt.parseInt()`的例子。
      ```js
      // Number.parseInt()和BigInt.parseInt()的对比
      console.log(Number.parseInt('9007199254740993', 10));
      // 9007199254740992
      console.log(BigInt.parseInt('9007199254740993', 10));
      // 9007199254740992n
      ```
      上面代码中，由于有效数字超出了最大限度，`Number.parseInt`方法返回的结果是不精确的，而`BigInt.parseInt`方法
      正确返回了对应的BigInt。

      对于二进制数组，BigInt新增了两个类型`BigUint64Array`和`BigInt64Array`，这两种数据类型返回的都是64位BigInt。
      `DataView`对象的实例方法`DataView.prototype.getBigInt64()`和`DataView.prototype.getBigUint64()`，返回的也是
      BigInt。

      ### 转换规则
      可以使用`Boolean()`、`Number()`和`String()`这两个方法，将BigInt可以转为布尔值、数值和字符串类型。
      ```js
      console.log(Boolean(0n)); // false
      console.log(Boolean(1n)); // true
      console.log(Number(1n)); // 1
      console.log(String(1n)); // 1
      ```
      上面代码中，最后一个例子，转为字符串时后缀`n`会消失。

      另外，取反运算符（`!`）也可以将BigInt转为布尔值。
      ```js
      console.log(!0n); // true
      console.log(!1n); // false
      ```

      ### 数学运算
      数学运算方面，BigInt类型的`+`、`-`、`*`和`**`这四个二元运算符，与Number类型的行为一致。除法运算`/`会舍去小数
      部分，返回一个整数。
      ```js
      console.log(9n / 5n); // 1n
      ```
      几乎所有的数值运算符都可以用在BigInt，但是有两个例外。
      * 不带符号的右移位运算符`>>>`
      * 一元的求正运算符`+`
      上面两个运算符用在BigInt会报错。前者是因为`>>>`运算符是不带符号的，但是BigInt总是带有符号的，导致该运算无意义，完全
      等同于右移运算符`>>`。后者是因为一元运算符`+`在asm.js里面总是返回Number类型，为了不破坏asm.js就规定`+1n`会报错。

      BigInt不能与普通树脂进行混合运算。
      ```js
      console.log(1n + 1.3);
      // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions
      ```
      上面代码报错是因为无论返回的是BigInt或者Number，都会导致丢失精度信息。比如`(2n**53n + 1n) + 0.5`这个表达式，如果返回
      BigInt类型，`0.5`这个小数部分会丢失；如果返回Number类型，有效精度只能保持53位，导致精度下降。

      同样的原因，如果一个标准库函数的参数预期是Number类型，但是得到的是一个BigInt，就会报错。
      ```js
      // 错误的写法
      console.log(Math.sqrt(4n)); // 报错

      // 正确的写法
      console.log(Math.sqrt(Number(4n))); // 2
      ```
      上面代码中，`Math.sqrt`的参数预期是Number类型，如果是BigInt就会报错，必须先用`Number`方法转一下类型，才能进行计算。

      asm.js里面，`|0`跟在一个数值的后面会返回一个32位整数。根据不能和Number类型混合运算的规则，BigInt如果和`|0`进行运算会报错。
      ```js
      console.log(1n | 0);
      // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions
      ```

      ### 其他运算
      BigInt对应的布尔值，和Number类型一致，即`0n`会转为`false`，其他值转为`true`。
      ```js
      if (0n) {
        console.log('111');
      } else {
        console.log('222');
      }
      // 222
      ```
      上面代码中，`0n`对应`false`，所以会进入`222`子句。

      比较运算符（比如`>`）和相等运算符（`==`）允许BigInt和其他类型的值混合计算，因为这样做不会损失精度。
      ```js
      console.log(0n < 1); // true
      console.log(0n < true); // true
      console.log(0n == 0); // true
      console.log(0n == false); // true
      console.log(0n === 0); // false
      ```
      BigInt和字符串混合运算时，会先转为字符串，再进行运算。
    */
    
  </script>
</body>

</html>