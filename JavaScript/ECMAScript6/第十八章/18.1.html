<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /* 
      # async函数
      
      ## 含义
      async函数是Generator函数的语法糖。来看个例子。
      ```js
      function* gen() {
        yield 1;
        yield 2;
      }

      let g = gen();

      console.log(g.next()); // {value: 1, done: false}
      console.log(g.next()); // {value: 2, done: false}

      async function number() {
        let num1 = await 1;
        let num2 = await 2;
        console.log(num1);
        console.log(num2);
      }

      number();
      ```
      一比较就会发现，`async`函数把Generator函数的星号（`*`）替换成`async`，把`yield`替换成`await`。

      `async`函数对Generator函数的改进，有以下四点。

      #### 1.内置执行器 
      Generator函数的执行必须靠执行器，所以才有`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，和普通的函数一模一样，
      只要一行。
      ```js
      number();
      ```
      上面的代码调用了`number`函数，然后就会自动执行，输出最后结果。这完全不像Generator函数，需要调用`next`方法，或者用`co`模块，才能
      真正执行，得到最后结果。

      #### 2. 更好的语义。
      `async`和`await`，比起星号和`yield`，语义更加清楚。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。

      #### 3. 更广的实用性
      `co`模块约定，`yield`命令后面只能是Thunk函数或Promise对象，而`async`函数的`await`命令后面，可以是Promise对象和原始类型的值（数值、
      字符串和布尔值，但这时会自动转成立即resolved的Promise对象）。

      #### 4. 返回值时Promise
      `async`函数的返回值时Promise对象，这比Generator函数的返回值时Iterator对象方便多了。可以用`then`方法指定下一步的操作。

      进一步说，`async`函数完全可以看作多个异步操作，包装成的一个Promise对象，而`await`命令就是内部`then`命令的语法糖。
    */
    
  </script>
</body>
</html>