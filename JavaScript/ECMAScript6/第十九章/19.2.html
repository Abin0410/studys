<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## 静态方法
      类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会
      被实例继承，而是直接通过类来调用，这就称为“静态方法”。
      ```js
      class Foo {
        static classMethod() {
          return 'hello';
        }
      }

      console.log(Foo.classMethod());
      // hello

      var foo = new Foo();
      console.log(foo.classMethod());
      // Uncaught TypeError: foo.classMethod is not a function
      ```
      上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（Foo.classMethod()），
      而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。

      注意，如果静态方法包含`this`关键字，这个`this`指的是类，而不是实例。
      ```js
      class Foo {
        static bar() {
          this.baz();
        }

        static baz() {
          console.log('hello');
        }

        baz() {
          console.log('world');
        }
      }

      Foo.baz(); // hello
      ```
      上面代码中，静态方法`bar`调用了`this.baz`，这里的`this`指的是`Foo`类，而不是`Foo`的实例，等同于调用`Foo.baz`。另外，从这个
      例子还可以看出，静态方法可以与非静态方法重名。

      父类的静态方法，可以被子类继承。
      ```js
      class Foo {
        static classMethod() {
          return 'hello';
        }
      }

      class Bar extends Foo {
        constructor() {
          super();
        }
      }

      console.log(Bar.classMethod()); // hello
      ```
      上面代码中，父类`Foo`有一个静态方法，子类`Bar`可以调用这个方法。

      静态方法也可以从`super`对象上调用的。
      ```js
      class Foo {
        static classMethod() {
          return 'hello';
        }
      }

      class Bar extends Foo {
        static classMethod() {
          return super.classMethod() + ', too';
        }
      }

      console.log(Bar.classMethod()); // hello, too
      ```
    */
    
  </script>
</body>
</html>