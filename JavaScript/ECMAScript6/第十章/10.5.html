<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## Symbol.for()、Symbol.keyFor()

      有时候，希望重新使用同一个`Symbol`值，可以使用`Symbol.for`方法。它接受一个字符串作为参数，然后搜索有没有该参数作为名称
      的`Symbol`值。如果有，就返回这个`Symbol`值，否则就创建并返回一个以该字符串为名称的`Symbol`值。
      ```js
      let sym1 = Symbol.for('foo');
      let sym2 = Symbol.for('foo');

      console.log(sym1 === sym2); // true
      ```
      上面的代码中，`sym1`和`sym2`都是`Symbol`值，但它们都是同样的参数的`Symbol.for`方法生成的，实际上都是同一个值。

      `Symbol.for()`与`Symbol()`这两种写法都会生成新的`Symbol`。区别就在与，`Symbol.for()`会被登记在全局环境中供搜索，而`Symbol()`
      并不会。`Symbol.for()`不会在每次调用时返回一个新的`Symbol`类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建
      一个值。比如，如果调用`Symbol.for("cat")`30次，每次都会返回同一个`Symbol`值，但是调用`Symbol("cat")`30次则会返回30个不同的
      `Symbol`值。
      ```js
      console.log(Symbol.for("bar") === Symbol.for("bar"));
      // true

      console.log(Symbol("bar") === Symbol("bar"));
      // false
      ```
      上面的代码中，由于`Symbol()`写法没有登记机制，所以每次调用都会返回一个不同的值。

      `Symbol.keyFor`方法返回一个已登记的`Symbol`值的`key`。
      ```js
      let sym1 = Symbol.for("foo");
      console.log(Symbol.keyFor(sym1)); // foo

      let sym2 = Symbol("foo");
      console.log(Symbol.keyFor(sym2)); // undefined
      ```
      上面的代码中，变量`s2`属于未登记的`Symbol`值，然后返回`undefined`。

      :::warning
      `Symbol.for`为`Symbol`值登记的名字是全局环境的，可以在不同的`iframe`或者`service.worker`中取得到同一个值。
      :::
    */
    
  </script>
</body>
</html>