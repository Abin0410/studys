<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## 属性名遍历

      `Symbol`作为属性名，该属性就不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`
      返回。但它也不是私有的属性，有一个`Object.getOwnPropertySymbols`方法获取指定对象中的所有`Symbol`属性名。

      `Object.getOwnPropertySymbols`方法用于遍历当前对象中所有属性为`Symbol`的值。返回的是一个数组，成员是当前对象的所有属性名
      为`Symbol`值。
      ```js
      let obj = { };
      let a = Symbol('a');
      let b = Symbol('b');

      obj[a] = 'Hello';
      obj[b] = 'World';

      let objectSymbols = Object.getOwnPropertySymbols(obj);
      console.log(objectSymbols); // [Symbol(a), Symbol(b)]
      ```
      如果要得到对象里作为`Symbol`值的键名，可以使用`Object.getOwnPropertySymbols`方法。

      还有一个方法新的API----`Reflect.ownKeys`方法可以返回所有类型的键名，包括常规的键名和`Symbol`键名。
      ```js
      let sym = Symbol('sym_key');
      let obj = {
        [sym]: 1,
        enum: 2,
        nonEnum: 3
      };

      console.log(Reflect.ownKeys(obj)); 
      // ["enum", "nonEnum", Symbol(sym_key)]
      ```
      以`Symbol`值作为名称的属性不会被常规方法遍历得到。可以用这个特性为对象定义一些非私有但又希望只用于内部的方法。
      ```js
      let size = Symbol('size');

      class Collection {
        constructor() {
          this[size] = 0;
        }

        add(item) {
          console.log(item); // foo
          console.log(this[size]); // 0
          this[this[size]] = item;
          this[size]++;
        }

        static sizeOf(instance) {
          return instance[size];
        }
      }

      let x = new Collection();

      console.log(Collection.sizeOf(x)); // 0

      x.add('foo');
      console.log(Collection.sizeOf(x)); // 1

      console.log(Object.keys(x)); // ["0"]
      console.log(Object.getOwnPropertyNames(x)); // ["0"]
      console.log(Object.getOwnPropertySymbols(x)); // [Symbol(size)]
      console.log(x); // Collection {0: "foo", Symbol(size): 1}
      ```
      上面的代码中，对象`x`的size属性是一个`Symbol`值，因此`Object.keys(x)`、`Object.getOwnPropertyNames(x)`都无法获取它。
      这样就造成非私有的内部方法的效果。
    */
    
  </script>
</body>
</html>