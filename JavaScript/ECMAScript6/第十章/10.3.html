<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## Object.getOwnPropertyDescriptors()该方法返回指定对象自身所有属性的描述。
      `Object.getOwnPropertyDescriptors()`方法返回指定对象自身所有（非继承属性）属性的描述。而在ES5中有一
      个`Object.getOwnPropertyDescriptor()`方法用于返回某个对象属性的描述对象。 通俗点说，前者是用来查看
      某个对象的所有属性的描述，而后者是查看某个对象里面的某个属性的描述。来看个例子：
      ```js
      const obj = {
        foo: 123,
        get bar() { return 'hello' },
      };

      console.log(Object.getOwnPropertyDescriptor(obj, 'foo')); // {value: 123, writable: true, enumerable: true, configurable: true}
      console.log(Object.getOwnPropertyDescriptors(obj));
      // {
      //   bar: {set: undefined, enumerable: true, configurable: true, get: ƒ},
      //   foo: {value: 123, writable: true, enumerable: true, configurable: true}
      // }
      ```
      上面的例子中，`Object.getOwnPropertyDescriptor`方法返回的是`obj`对象中的`foo`属性的描述，而`Object.getOwnPropertyDescriptors()`方法则
      是返回`obj`对象中的所有属性的描述。

      这个方法的引入是为了解决`Object.assign()`无法正确拷贝`get`属性和`set`属性的问题。
      ```js
      const obj = {
        set foo(value) {
          console.log(value);
        }
      }

      const target1 = {};
      Object.assign(target1, obj);

      console.log(Object.getOwnPropertyDescriptor(target1, 'foo')); 
      // {value: undefined, writable: true, enumerable: true, configurable: true}
      ```
      上面的代码中，`source`对象的`foo`属性的值是一个赋值函数，`Object.assign`方法将这个属性拷贝给`target1`对象，结果属性的值变成了`undefined`。
      是因为`Object.assign`方法总是拷贝一个属性的值，并不会拷贝它的赋值方法或者取值方法。

      可以用`Object.getOwnPropertyDescriptors()`方法配合`Object.defineProperties()`方法实现正确的拷贝。
      ```js
      const obj = {
        set foo(value) {
          console.log(value);
        }
      }

      const target1 = {};
      Object.defineProperties(target1, Object.getOwnPropertyDescriptors(obj));
      console.log(Object.getOwnPropertyDescriptor(target1, 'foo'));
      // {
      //   get: undefined, 
      //   enumerable: true, 
      //   configurable: true, 
      //   set: foo(value)
      // }
      ```
      来优化一下上面的代码，把两个对象合并的逻辑写成一个函数。
      ```js
      const shallowMerge = (target1, source) => Object.defineProperties(
        target1, 
        Object.getOwnPropertyDescriptor(target1, 'foo')
      );
      ```
      `Object.getOwnPropertyDescriptors()`方法还有另一个用处，配合`Object.create()`方法，将对象属性克隆到一个新对象。注意，这只是浅拷贝而已。
      ```js
      const shallowClone = (obj) => Object.create(
        Object.getPrototypeOf(obj),
        Object.getOwnPropertyDescriptors(obj)
      );

      let obj1= {
        a: 1,
        b: 2,
      };

      let obj2 = shallowClone(obj1);
      obj2.b = 3;
      console.log(obj1); // {a: 1, b: 2}
      console.log(obj2); // {a: 1, b: 3}
      ```
      另外，`Object.getOwnPropertyDescriptors()`方法可以实现一个对象继承另一个对象。
      ```js
      class Person {
        constructor() {
          this.a = 1;
          this.b = 2;
        }
      }
      const prot = new Person();
      const obj = Object.create(prot, Object.getOwnPropertyDescriptors({ foo: 123 }));
      console.log(obj);
      // {
      //   foo: 123
      //   __proto__: Person
      //     a: 1
      //     b: 2
      // }
      ```
    */
    
  </script>
</body>
</html>