<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /**
      ## 尾调用优化

      ### 什么是尾调用
      尾调用是函数式编程的一个重要概念，本身非常简单，就是指某个函数的最后一步是调用另一个函数。
      ```js
      function f(x) {
        return g(x);
      }
      ```
      上面的代码中，函数f的最后一步是调用函数g，这就是尾调用。

      那不属于尾调用又是哪些呢？请看以下代码。
      ```js
      function f(x) {
        let y = g(x);
        return y;
      }

      function f(x) {
        return g(x) + 1;
      }

      function f(x) {
        g(x);
      }
      ```
      上面的代码中，情况一是调用函数g之后还有赋值操作，所以不属于尾调用，即使语义完全一样；情况二也属于调用后还有操作，
      即使写在一行内；情况三等同于下面的代码。
      ```js
      function f(x) {
        g(x);
        return undefined;
      }
      ```
      尾调用不一定出现在函数尾部，只要是最后一步操作即可。
      ```js
      function f(x) {
        if (x > 0) {
          return m(x);
        }
        return n(x);
      }
      ```
      上面的代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。

      ### 尾调用优化
      尾调用之所以与其他调用不同，就在于其特殊的调用位置。
      函数调用会在内存形成一个 “调用记录” ，又称为 “调用帧” ，保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么
      在A的调用帧上方会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有
      一个C的调用帧，以此类推。所有的调用帧就形成一个 “调用栈”。

      尾调用由于是函数的最后一步操作。所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，直接用内层
      函数的调用帧取代外层函数的即可。
      ```js
      function f() {
        let m = 1;
        let n = 2;

        return g(m + n);
      }

      f();

      // 等同于
      function f() {
        return g(3);
      }

      f();

      // 等同于
      g(3);
      ``` 
      上面的代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以
      执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。

      这就叫作 “尾调用优化”，即保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时调用帧只有一项，这将大大节省
      内存。这就是 “尾调用优化”的意义。

      :::warning
      只有不再用到外层函数的内部变量。内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行 “尾调用优化”。
      :::

      ```js
      function addOne(a) {
        var one = 1;

        function inner(b) {
          return b + one;
        }

        return inner(a);
      }

      console.log(addOne(10));
      ```
      上面的函数不会进行尾调用优化，因为内层函数inner使用了外层函数addOne的内部变量one。

      ### 尾递归
      函数调用自身称为递归，如果尾调用自身就称为尾递归。
      递归非常耗费内存，因为需要同时保存成百上千个调用帧，很容易产生 “栈溢出”错误。但对于尾递归来说，由于只存在一个调用帧，所以永远都
      不会发生 “栈溢出”错误。
      ```js
      function factorial(n) {
        if (n === 1) return 1;
        return n * factorial(n - 1);
      }

      console.log(factorial(5)); // 120
      ```
      以上的代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度为O(n)。如果改写成尾递归，只保留一个调用记录，则复杂度为O(1)。
      ```js
      function factorial(n, total) {
        if (n === 1) return total;
        return factorial(n - 1, n * total);
      }

      console.log(factorial(5, 1)); // 120
      ```
      还有一个例子----计算Fibonacci数列，也能充分说明尾递归优化的重要性。非尾递归的Fibonacci数列实现看下面的例子。
      ```js
      function Fibonacci (n) {
        if (n <= 1) {return 1};
        return Fibonacci(n - 1) + Fibonacci(n - 2);
      }

      console.log(Fibonacci(10)); // 89
      console.log(Fibonacci(100)); // 堆栈溢出 
      console.log(Fibonacci(500)); // 堆栈溢出
      ```
      上面的代码中，最后两次打印的Fibonacci函数传了100和500，可以看到浏览器控制台一直都没有结果，是因为数值太大，所以一直在计算，导致堆栈溢出。

      尾递归优化的Fibonacci数列实现如下。
      ```js
      function Fibonacci2 (n, ac1 = 1, ac2 = 1) {
        if (n <= 1) { return ac2 };
        return Fibonacci2 (n - 1, ac2, ac1 + ac2);
      }

      console.log(Fibonacci2(100));
      console.log(Fibonacci2(1000));
      console.log(Fibonacci2(10000));
      ```
      由此可见，尾调用优化对递归操作的意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现都
      必须部署尾调用优化。只要使用尾递归，就不会发生栈溢出，可以大大减少内存的占用。
    **/
    function Fibonacci2 (n, ac1 = 1, ac2 = 1) {
      if (n <= 1) { return ac2 };
      return Fibonacci2 (n - 1, ac2, ac1 + ac2);
    }

    console.log(Fibonacci2(100));
    console.log(Fibonacci2(1000));
    console.log(Fibonacci2(10000));
  </script>
</body>
</html>