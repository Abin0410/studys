<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /**
      ## 箭头函数

      ### 基本用法
      ES6引入了“箭头”（=>）定义函数。
      ```js
      let f = v => v;
      console.log(f(1)); // 1
      ```
      上面的代码相当于以下的代码。
      ```js
      let f = function(v) {
        return v;
      }
      console.log(f(1)); // 1
      ```
      如果箭头函数不需要参数或者需要多个参数，就使用圆括号代表参数部分。
      ```js
      let f = () => 5;
      console.log(f());

      // 等同于
      let f = function() {
        return 5;
      }
      console.log(f()); // 5

      let sum = (number1, number2) => number1 + number2;
      console.log(sum(2, 3)); // 5

      // 等同于
      let sum = function(number1, number2) {
        return number1 + number2;
      }
      console.log(sum(2, 3)); // 5
      ```
      如果箭头函数的代码块部分多于一条语句，就要使用大括号将其括起来，并使用return语句返回。
      ```js
      let sum = (num1, num2) => { return num1 + num2; }
      console.log(sum(1, 2)); // 3
      ```
      由于大括号被解析为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。
      ```js
      let getTempItem = id => ({id: id, name: "tutu"});
      console.log(getTempItem(1)); // {id: 1, name: "tutu"}
      ```
      箭头函数可以与变量解构结合使用。
      ```js
      const full = ({first, last}) => `${first} ${last}`;
      console.log(full({first: 1, last: 2})); // 1 2

      // 等同于
      function full(person) {
        return `${person.first} ${person.last}`;
      }
      console.log(full({first: 1, last: 2})); // 1 2
      ```
      箭头函数使得表达更加简洁。
      ```js
      const isEven = n => n % 2 == 0;
      const square = n => n * n;
      ```
      上面的代码只用了两行就定义了两个简单的工具函数，如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。

      箭头函数的一个用处是简化回调函数。
      ```js
      // 正常写法
      let arr = [1, 2, 3];
      let arr1 = arr.map(function(item) {
        return item * item;
      });
      console.log(arr1); // [1, 4, 9]

      // 箭头函数的写法
      let arr = [1, 2, 3];
      let arr1 = arr.map(item => item * item)
      console.log(arr1); // [1, 4, 9]
      ```

      结合rest参数和箭头函数使用的例子。
      ```js
      const numbers = (...nums) => nums;
      console.log(numbers(1, 2, 3, 4, 5)); // [1, 2, 3, 4, 5]

      const headAndTail = (head, ...tail) => [head, tail];
      console.log(headAndTail(1, 2, 3, 4, 5)); // [1, [2, 3, 4, 5]]
      ```

      ### 箭头函数的注意事项
      箭头函数有几个问题在使用时需要注意的，
      1. 函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象。
      2. 不可以当作构造函数，也就是说，不可以使用new操作符，否则会抛出一个错误。
      3. 不可以使用arguments对象，该对象在函数体内不存在。但是可以使用rest参数来代替。
      4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。

      其中，第一点值得注意的是。this对象的指向是可变的，但在箭头函数中它是固定的。
      ```js
      function foo() {
        setTimeout(() => {
          console.log('id', this.id);
        }, 100);
      }
      var id = 21;

      foo.call({ id: 42 });
      ```
      以上的代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义是foo函数生成时生效的，而它真正执行
      要等到100ms后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致
      this总是指向函数定义生效时所在的对象，也就是{id: 42}，所以输出了42。

      箭头函数可以让setTimeout里面的this绑定定义时所在的作用域，而不是指向运行时所在的作用域。看下面的例子。
      ```js
      function Timer() {
        this.s1 = 0;
        this.s2 = 0;

        // 箭头函数
        setInterval(() => this.s1++, 1000);

        // 普通函数
        setInterval(function() {
          this.s2++;
        }, 1000);
      }

      var timer = new Timer();

      setTimeout(() => console.log('s1：', timer.s1), 3100); // s1： 3
      setTimeout(() => console.log('s2：', timer.s2), 3100); // s2： 0
      ```
      上面的代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在
      的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100ms之后，timer.s1被
      更新了3次，而timer.s2一次都没有更新。

      this指向的固定化并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有this这一说，导致内部
      的this就是外层代码块的this。正是因为它没有this，所以不能用作构造函数。

      除了this，以下3个变量在箭头函数中也是不存在的，都是指向外层函数的对应变量：arguments、super和new.target。

      ### 嵌套的箭头函数

      箭头函数内部还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。
      ```js
      function insert(value) {
        return {into: function(array) {
          return {after: function(afterValue) {
            array.splice(array.indexOf(afterValue) + 1, 0, value);
            return array;
          }};
        }};
      }

      console.log(insert(2).into([1, 3]).after(1)); // [1, 2, 3]
      ```
      使用箭头函数改写上面的函数。
      ```js
      let insert = (value) => ({into: (array) => ({after: (afterValue) => {
        array.splice(array.indexOf(afterValue) + 1, 0, value);
        return array;
      }})});
      console.log(insert(2).into([1, 3]).after(1)); // [1, 2, 3]
      ```
    **/
  </script>
</body>
</html>