<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <div id="foo"></div>
  <div id="bar"></div>
  <script>
    /* 
      ## WeakMap
      ### 含义
      `WeakMap`的结构跟`Map`结构相似，也是用来生成键值对的集合。
      ```js
      const wm = new WeakMap();
      const key = { foo: 1 };

      wm.set(key, 2);
      console.log(wm.get(key)); // 2

      const k1 = [1, 2, 3];
      const k2 = [4, 5, 6];
      const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
      console.log(wm2.get(k2)); // bar
      ```
      `WeakMap`与`Map`的区别有两点。
      一是`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。
      ```js
      const map = new WeakMap();
      map.set(1, 2);
      // Uncaught TypeError: Invalid value used as weak map key
      map.set(Symbol(), 2);
      map.set(null, 2);
      ```
      二是`WeakMap`的键名所指向的对象，不计入垃圾回收机制。

      `WeackMap`的出现在于，有时候想在某个对象上存放一些数据，但是这会行程对于这个对象的引用。看下面的例子：
      ```js
      const e1 = document.getElementById('foo');
      const e2 = document.getElementById('bar');
      const arr = [
        [e1, 'foo元素'],
        [e2, 'bar元素']
      ];
      console.log(arr);
      // [[div#foo, "foo元素"], [div#bar, "bar元素"]]
      ```
      上面的代码中，`e1`和`e2`是两个对象，通过`arr`数组对这两个对象添加一些文字说明。这就形成了`arr`对`el`和`e2`的引用。

      但是不再需要这两个对象时，就需要手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用内存，从而导致内存泄漏。
      ```js
      const e1 = document.getElementById('foo');
      const e2 = document.getElementById('bar');
      const arr = [
        [e1, 'foo元素'],
        [e2, 'bar元素']
      ];
      console.log(arr);
      // [[div#foo, "foo元素"], [div#bar, "bar元素"]]

      // 不需要e1和e2的时候，需要手动删除引用
      arr[0] = null;
      arr[1] = null;
      ```
      上面这种写法就显得很不方便，如果忘了写，就会导致内存泄漏。

      `WeakMap`就是为了解决这类问题，它的键名所引用的对象都是弱引用，即垃圾回收机制不会考虑该引用。因此，只要所引用的对象的其他
      引用都被清除，垃圾回收机制就会释放这个对象所占用的内存。也就是说，一旦不需要，`WeakMap`里面的键名对象和所对应的键值就会自
      动消失，不用手动删除引用。

      基本上，如果你要向对象上添加数据，又不想干扰垃圾回收机制，就可以使用`WeakMap`。比较典型的应用场景就是，在网页的`DOM`元素上
      添加数据，就可以使用`WeakMap`结构。当该`DOM`元素被清除，对应的`WeakMap`记录就会自动被移除。
      ```js
      const wm = new WeakMap();
      const element = document.getElementById("foo");
      wm.set(element, 'foo元素');
      console.log(wm.get(element)); // foo元素
      ```
      上面的代码中，先新建一个`WeakMap`实例。然后，将一个`DOM`节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在`WeakMap`
      里面。这时，`WeakMap`里面对`element`的引用就是弱引用，不会被计入垃圾回收机制。

      也就是说，上面的`DOM`节点对象的引用计数是`1`，而不是`2`。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。
      `WeakMap`保存的这个键值对，也会自动消失。

      总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会将来消失。`WeakMap`结构有助于防止内存泄漏。

      但是要注意的是，`WeakMap`弱引用的只是键名，而不是键值，键值依然是可以正常引用。
      ```js
      const wm = new WeakMap();
      let key = {};
      let obj = {foo: 1};

      wm.set(key, obj);
      obj = null;
      console.log(wm.get(key)); // {foo: 1}
      ```
      上面的代码中，键值`obj`是正常引用。所以，即使在`WeakMap`外部消除了`obj`的引用，`WeakMap`内部的引用还是存在的。

      ### WeakMap的语法
      `WeakMap`和`Map`在API有两个区别，一是没有遍历操作，也没有`size`属性。因为没有办法列出所有键名，没办法预测某个键名是否存在，
      这一刻可以取到键名，下一刻垃圾回收机制运行了，这个键名就没了，为了防止出现不确定的情况，统一规定不能取到键名。二是无法清空，
      不支持`clear`方法。因此，`WeakMap`只有四个方法可以用：`get()`、`set()`、`has()`、`delete()`。
      ```js
      const wm = new WeakMap();

      console.log(wm.size); // undefined
      console.log(wm.forEach); // undefined
      console.log(wm.clear); // undefined
      ```
    */
    
  </script>
</body>
</html>