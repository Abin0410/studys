<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## Map
      总所周知，JavaScript的对象本质上是键值对的集合，但是只能用字符串作键。这样就带来了很大的限制。为了解决这个问题，
      `ES6`提供了`Map`数据结构。它类似于对象，也是键值对的集合，但是键的范围不限于字符串，可以是各种类型的值（包括对象）
      都可以当作键。也可以这么理解，`Object`结构提供了 “字符串--值”的对应，`Map`结构提供了“值--值”的对应，如果你需要
      “键值对”的数据结构，`Map`比`Object`更适合。
      ```js
      const m = new Map();
      const o = { p: 'hello world' };

      m.set(o, 'content');
      console.log(m.get(o)); // content

      for (let [key, value] of m) {
        console.log(key, value);
        // {p: "hello world"} "content"
      }

      console.log(m.has(o)); // true
      console.log(m.delete(o)); // true
      console.log(m.has(o)); // false
      ```
      上面的代码中，使用`Map`结构的方法`set`方法，将对象`o`当作`m`的一个键，然后使用`get`方法读取这个键，接着使用`delete`方法
      删除了这个键。我们使用`for...of`可以看到键为`o`对象，值就为"content"字符串。

      上面的例子展示了怎么向`Map`添加成员，作为构造函数，`Map`也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组。
      ```js
      const map = new Map([
        ['name', '张三'],
        ['title', 'Author']
      ]);
      console.log(map); // {"name" => "张三", "title" => "Author"}
      console.log(map.size); // 2
      console.log(map.has('name')); // true
      console.log(map.get('name')); // 张三
      console.log(map.has('title')); // true
      console.log(map.get('title')); // Author
      ```
      上面的代码中，在新建`Map`实例时，就指定了两个键`name`和`title`。

      `Map`构造函数接受数组作为参数，可以执行下面的算法。
      ```js
      const items = [
        ['name', '张三'],
        ['title', 'Author']
      ];

      const map = new Map();

      items.forEach(([key, value]) => map.set(key, value));
      console.log(map); // {"name" => "张三", "title" => "Author"}
      ```
      不仅仅数组，任何具有`Iterator`接口、且每个成员都是一个双元素的数组的数据结构都可以作`Map`构造函数的参数。也就是说，`Set`
      和`Map`都可以用来生成新的`Map`。
      ```js
      const set = new Set([
        ['foo', 1],
        ['bar', 2]
      ]);

      const m1 = new Map(set);
      console.log(m1.get('foo')); // 1

      const m2 = new Map([['baz', 3]]);
      const m3 = new Map(m2);
      console.log(m3.get('baz')); // 3
      ```
      上面的代码中，分别使用`Set`对象和`Map`对象，当作`Map`构造函数的参数，然后都生成了新的`Map`对象。

      如果对同一个键多次赋值，后面的值会覆盖掉前面的值。
      ```js
      const map = new Map();
      map.set(1, 'aaa').set(1, 'bbb');
      console.log(map.get(1)); // bbb
      ```
      上面代码中对键`1`连续赋值两次，后面的值覆盖了前面的值。

      如果获取一个未知的键会返回`undefined`。
      ```js
      let map = new Map();
      console.log(map.get('a')); // undefined
      ```
      要注意的是，只有对同一个对象的引用，`Map`结构才会把这对象当作同一个键。
      ```js
      const map = new Map();
      const arr = ['b'];

      map.set(['a'], 555);
      console.log(map.get(['a'])); // undefined

      map.set(arr, 666);
      console.log(map.get(arr)); // 666
      ```
      上面的代码的`set`和`get`方法，表面上是针对同一个键，但实际上这两个数组都是不同的实例，内存地址都是不一样的，所以`get`方法无法获取
      这个键，返回`undefined`。再来看上面第二个变量`arr`，然后向`map`实例添加了`arr`这个键，值且是`666`。通过`get`方法获取`arr`这个
      键，返回了`arr`的值`666`。这是因为添加和读取的都是同一个数组实例。

      同样的值的两个实例，在`Map`结构中也是当作为两个键。
      ```js
      const map = new Map();

      const k1 = ['a'];
      const k2 = ['a'];

      map.set(k1, 111).set(k2, 333);
      console.log(map.get(k1), map.get(k2)); // 111 333
      ```
      上面的代码中，变量`k1`和`k2`的值是一样的，但是在`Map`结构中被当作为两个键了。

      `Map`的键是跟内存地址绑定的，只要内存地址不一样，就被看作为两个键。这就解决了同名属性碰撞的问题，在扩展别人的库的时候，如果使用
      对象作为键名，就不用担心自己的属性与原作者的属性同名。

      如果`Map`的键是一个简单类型的值，只要两个严格相等，`Map`会看作为一个键，例如：`0`和`-0`就是一个键，布尔值`true`和字符串`true`则
      是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但`Map`会看作为同一个键。
      ```js
      let map = new Map();

      map.set(-0, 123);
      console.log(map.get(+0)); // 123

      map.set(true, 1);
      map.set('true', 2);
      console.log(map.get(true)); // 1

      map.set(undefined, 3);
      map.set(null, 4);
      console.log(map.get(undefined)); // 3

      map.set(NaN, 123);
      console.log(map.get(NaN)); // 123
      ```
      ### 实例的属性和操作方法
      以下是`Map`结构的实例属性和操作方法。

      #### size属性
      `size`属性返回`Map`结构的成员总数。
      ```js
      const map = new Map();
      map.set('foo', true);
      map.set('bar', false);
      console.log(map.size); // 2
      ```

      #### Map.prototype.set(key, value)
      `set`方法设置键名`key`对应的键值为`value`，然后返回整个`Map`结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。
      ```js
      const m = new Map();

      m.set('a', 6); // 键是一个字符串
      m.set(1, 'standard'); // 键是一个数值
      m.set(undefined, 'nah'); // 键是一个undefined
      console.log(m); // {"a" => 6, 1 => "standard", undefined => "nah"}
      ```
      `set`方法返回的是当前的`Map`对象，可以采用链式写法。
      ```js
      let map = new Map()
        .set(1, 'a')
        .set(2, 'b')
        .set(3, 'c');
      console.log(map); // {1 => "a", 2 => "b", 3 => "c"}
      ```
      #### Map.prototype.get(key)
      `get`方法获取`key`对应的键值，如果没有找到`key`，则返回`undefined`。
      ```js
      const m = new Map();

      const hello = function() { console.log('hello'); };
      m.set(hello, 'Hello world');
      console.log(m.get(hello)); // Hello world
      ```

      #### Map.prototype.has(key)
      `has`方法返回一个布尔值，表示某个键是否在当前的`Map`对象中。
      ```js
      const m = new Map();

      m.set('a', 6);
      m.set(1, 'standard');
      m.set(undefined, 'nah');

      console.log(m.has('a')); // true
      console.log('b'); // b
      console.log(m.has(1)); // true
      console.log(undefined); // undefined
      ```

      #### Map.prototype.delete(key)
      `delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。
      ```js
      const m = new Map();
      m.set(undefined, 'nah');
      console.log(m.has(undefined)); // true

      console.log(m.delete(undefined)); // true
      console.log(m.has(undefined)); // false
      ```

      #### Map.prototype.clear()
      `clear`方法清除所有成员，没有返回值。
      ```js
      let map = new Map();
      map.set('foo', true);
      map.set('bar', false);

      console.log(map.size); // 2
      map.clear();
      console.log(map.size); // 0
      ```

      ### 遍历方法
      `Map`结构有三个遍历器生成函数和一个遍历方法。
      * `Map.prototype.keys()`：返回键名的遍历器。
      * `Map.prototype.values()`：返回键值的遍历器。
      * `Map.prototype.entries()`：返回所有成员的遍历器。
      * `Map.prototype.forEach()`：遍历`Map`的所有成员。
      
      Map的遍历顺序也是插入顺序。
      ```js
      const map = new Map([
        ['F', 'no'],
        ['T', 'yes']
      ]);

      for (let key of map.keys()) {
        console.log(key);
      }
      // F
      // T

      for (let value of map.values()) {
        console.log(value);
      }
      // no
      // yes

      for (let [key, value] of map.entries()) {
        console.log(key, value);
      }
      // F no
      // T yes
      ```
      `Map`结构的默认遍历器接口（Symbol.iterator属性）就是`entries`方法。
      ```js
      console.log(new Map()[Symbol.iterator] === new Map().entries); // true
      ```
      `Map`结构转为数组结构比较快的方法就是使用扩展运算符（`...`）。
      ```js
      const map = new Map([
        [1, 'one'],
        [2, 'two'],
        [3, 'three'],
      ]);

      console.log([...map.keys()]); // [1, 2, 3]
      console.log([...map.values()]); // ["one", "two", "three"]
      console.log([...map.entries()]); // [[1, "one"], [2, "two"], [3, "three"]]
      console.log([...map]); // [[1, "one"], [2, "two"], [3, "three"]]
      ```
      可以结合数组的`map`方法、`filter`方法实现`Map`的遍历和过滤。
      ```js
      const map0 = new Map()
        .set(1, 'a')
        .set(2, 'b')
        .set(3, 'c')

      const map1 = new Map(
        [...map0].filter(([k, v]) => k < 3)
      );
      console.log(map1);
      // {1 => "a", 2 => "b"}

      const map2 = new Map(
        [...map0].map(([k, v]) => [k * 2, '_' + v])
      );
      console.log(map2);
      // {2 => "_a", 4 => "_b", 6 => "_c"}
      ```

      `Map`还有一个`forEach`方法，和数组的`forEach`方法相似，可以实现遍历。
      ```js
      const map = new Map()
        .set(1, 'a')
        .set(2, 'b')
        .set(3, 'c');
      map.forEach((value, key) => {
        console.log(value, key);
        // a 1
        // b 2
        // c 3
      });
      ```
      `forEach`方法可以接受第二个参数，用来绑定`this`。
      ```js
      const map = new Map()
        .set(1, 'a')
        .set(2, 'b')
        .set(3, 'c');

      const reporter = {
        report: function(key, value) {
          console.log(key, value);
        }
      }

      map.forEach(function(value, key) {
        this.report(key, value);
        // 1 "a"
        // 2 "b"
        // 3 "c"
      }, reporter);
      ```
      上面的代码中，`forEach`方法的回调函数的`this`，就指向`reporter`。

      ### 和其他数据结构的互相转换

      #### Map转为数组
      上面已经说了`Map`转为数组最便捷的方法，就是用扩展运算符（`...`）。

      #### 数组转为`Map`
      将数组传入`Map`构造函数，可以转为`Map`。
      ```js
      const map = new Map([
        [true, 7],
        [{foo: 3}, ['abc']]
      ]);

      console.log(map);
      // {
      //   true => 7, 
      //   Object => ["abc"]
      // }
      ```
      #### Map转为对象
      如果所有`Map`的键都是字符串，它可以无损地转为对象。
      ```js
      function strMapToObj(strMap) {
        let obj = Object.create(null);
        for (let [k, v] of strMap) {
          obj[k] = v;
        }
        return obj;
      }

      const myMap = new Map()
        .set('yes', true)
        .set('no', false);
      console.log(strMapToObj(myMap)); // {yes: true, no: false}
      ```
      如果有非字符串的键名，那么这个简明会被转成字符串，再当作对象的键名。

      #### 对象转为Map
      对象转为`Map`可以通过`Object.entries()`。
      ```js
      let obj = { "a": 1, "b": 2 };
      let map = new Map(Object.entries(obj));
      ```
      当然也可以自己写一个转换函数。
      ```js
      function objToStrMap(obj) {
        let strMap = new Map();
        for (let k of Object.keys(obj)) {
          strMap.set(k, obj[k]);
        }
        return strMap;
      }

      console.log(objToStrMap({yes: true, no: false}));
      // {"yes" => true, "no" => false}
      ```

      #### Map转为JSON
      `Map`转为`JSON`要区分两种情况，一种情况是，Map的键名都是字符串，这时可以转为对象`JSON`。
      ```js
      function strMapToJson(strMap) {
        return JSON.stringify(strMapToObj(strMap));
      }

      function strMapToObj(strMap) {
        let obj = Object.create(null);
        for (let [k, v] of strMap) {
          obj[k] = v;
        }
        return obj;
      }

      let myMap = new Map().set('yes', true).set('no', false);
      console.log(strMapToJson(myMap));
      // {"yes":true,"no":false}
      ```
      另一种情况是，`Map`的键名有非字符串的时候，可以选择转为数组`JSON`。
      ```js
      function mapToArrayJson(map) {
        return JSON.stringify([...map]);
      }

      let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
      console.log(mapToArrayJson(myMap)); // [[true,7], [{"foo":3},["abc"]] ]
      ```
      #### JSON转为Map
      JSON转为Map，正常情况下，所有的键名都是个字符串。
      ```js
      function jsonToStrMap(jsonStr) {
        return objToStrMap(JSON.parse(jsonStr));
      }

      function objToStrMap(obj) {
        let strMap = new Map();
        for (let k of Object.keys(obj)) {
          strMap.set(k, obj[k]);
        }
        return strMap;
      }

      console.log(jsonToStrMap('{"yes": true, "no": false}'));
      // {"yes" => true, "no" => false}
      ```
      有一种比较特殊的情况就是，整个`JSON`就是一个数组，并且每个数组成员本身又有两个成员的数组。这时，它可以一一对应地转成
      `Map`。这是`Map`转成数组JSON的逆向操作。
      ```js
      function jsonToMap(jsonStr) {
        return new Map(JSON.parse(jsonStr));
      }

      console.log(jsonToMap('[[true, 7], [{"foo": 3}, ["abc"]]]'));
      // {true => 7, Object => ["abc"]}
      ```
    */
    
  </script>
</body>
</html>