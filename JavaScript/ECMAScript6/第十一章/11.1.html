<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>

<body>
  <div></div>
  <div></div>
  <div></div>
  <script>
    /* 
      # Set和Map数据结构

      ## Set

      ### 基本用法
      ES6加入了一个新的数据结构`Set`。它跟数组相似，主要的区别就在于`Set`的成员的值都是唯一的，没有重复的值。

      `Set`是一个构造函数，用来生成`Set`数据结构。
      ```js
      let s = new Set();
      let arr = [1, 2, 2, 2, 3, 4, 5];
      arr.forEach(item => s.add(item));
      console.log(s); // Set(5) {1, 2, 3, 4, 5}
      ```
      上面的代码中，使用`add`方法向`Set`结构加入成员，结果`Set`结构不会添加重复的值。

      `Set`函数可以接受一个数组或者具有`iterable`接口的其他数据结构作为参数。
      ```js
      // 例子一
      const set = new Set([1, 2, 2, 3, 4]);
      console.log([...set]); // [1, 2, 3, 4]

      // 例子二
      const set = new Set(document.querySelectorAll('div'));
      console.log(set); // Set(3) {div, div, div}
      ```
      上面的代码中，例子一中的`Set`接受数组作为参数，例子二中是接受类数组的对象作为参数。

      有了`Set`数据结构，我们可以用来当作数组去重的方法。
      ```js
      let arr = [1, 2, 3, 4, 5, 5, 5, 5, 6, 6, 6, 7];
      const set = new Set(arr);
      console.log([...set]); // [1, 2, 3, 4, 5, 6, 7]
      ```
      也可以用于去除字符串里面重复的字符。
      ```js
      const str = 'ababbcccdddd';
      const set = new Set(str);
      console.log([...set].join()); // a,b,c,d
      ```
      向`Set`添加值时，不会产生类型转换，所以`5`和`"5"`是两个不同的值。`Set`内部判断两个值是否不同，内部使用了一种算法，
      类似严格相等运算符`（===）`，主要的区别是向`Set`加入值时认为`NaN`等于自身，而严格相等运算符认为`NaN`不等于自身。
      ```js
      let set = new Set();
      let a = NaN;
      let b = NaN;
      set.add(a);
      set.add(b);
      console.log(set); // {NaN}
      ```
      上面的代码中，向`Set`实例加入了两次`NaN`，但是只加入了一个。这就证明了，在`Set`内部，两个`NaN`是相等的。

      如果加入两个对象，那就不一样了。
      ```js
      let set = new Set();

      set.add({});
      console.log(set.size);

      set.add({});
      console.log(set.size);
      console.log(set); // {{0: value: {}}, {1: value: {}}}
      ```
      上面代码表示，由于两个空对象不相等，所以它们被当作两个值。

      ### Set实例的属性和方法

      `Set`结构实例的属性如下：

      * `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
      * `Set.prototype.size`：返回`Set`实例的成员总数。
      
      `Set`实例的方法分为两类：操作方法和遍历方法。如下：
      * `Set.prototype.add(value)`：添加某个值，返回`Set`结构本身。
      * `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
      * `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
      * `Set.prototype.clear()`：清除所有成员，没有返回值。
      
      ```js
      const s = new Set();

      console.log(s.add(1).add(2).add(2)); // {1, 2}

      console.log(s.size); // 2

      console.log(s.has(1)); // true
      console.log(s.has(2)); // true
      console.log(s.has(3)); // false

      console.log(s.delete(2)); // true
      console.log(s.has(2)); // false
      ```

      `Array.from`方法可以将`Set`结构转为数组。
      ```js
      const items = new Set([1, 2, 3, 4, 5]);
      const array = Array.from(items);
      console.log(array); // [1, 2, 3, 4, 5]
      ```

      这样就提供了数组去重的另外一个方法。
      ```js
      function dedupe(array) {
        return Array.from(new Set(array));
      }

      console.log(dedupe([1, 1, 1, 2, 3, 4, 4])); // [1, 2, 3, 4]
      ```

      ### 遍历操作
      `Set`结构的实例一共有四个遍历方法，可以用于遍历成员。实际上这些方法跟对象的方法一样。
      * `Set.prototype.keys()`：返回键名的遍历器。
      * `Set.prototype.vlaues()`：返回键值的遍历器。
      * `Set.prototype.entries()`：返回键值对的遍历器。
      * `Set.prototype.forEach()`：使用回调函数遍历每个成员，和数组的`forEach`方法一致。
      
      `Set`的遍历顺序就是插入顺序，这个特性有时候非常有用，比如使用`Set`保存一个回调函数列表，调用时就能保证
      按照添加顺序调用。

      #### `keys()`、`values()`、`entries()`

      `keys`方法、`values`方法、`entries`方法返回的都是遍历器对象。由于`Set`结构没有键名，只有键值，所以`keys`方法和
      `values`方法的行为完全一致。
      ```js
      let set = new Set(['red', 'green', 'blue']);

      for (let item of set.keys()) {
        console.log(item);
        // red
        // green
        // blue
      }

      for (let item of set.values()) {
        console.log(item);
        // red
        // green
        // blue
      }

      for (let item of set.entries()) {
        console.log(item);
      }
      // ["red", "red"]
      // ["green", "green"]
      // ["blue", "blue"]
      ```
      上面的代码中，`entries`方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，两个成员都是相等的。

      因为`Set`结构的实例默认是可遍历的，它的默认遍历器生成函数就是它的`values`方法。这就可以直接省略`values`方法，
      直接用`for...of`循环遍历`Set`。
      ```js
      let set = new Set([1, 4, 9]);
      set.forEach((value, key) =>  console.log(`${key} : ${value}`));
      // 1 : 1
      // 4 : 4
      // 9 : 9
      ```
      由于`Set`结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。

      另外，`forEach`方法还可以有第二个参数，表示绑定处理函数内部的`this`对象。

      #### 遍历的应用

      扩展运算符（`...`）内部使用`for...of`循环，所以可以用于`Set`结构。
      ```js
      let set = new Set(['red', 'green', 'blue']);
      let arr = [...set];
      console.log(arr); // ["red", "green", "blue"]
      ```
      扩展运算符和`Set`结构结合，可以实现数组去重方法。
      ```js
      let arr = [3, 5, 2, 2, 5, 5];
      let unique = [...new Set(arr)];
      console.log(unique); // [3, 5, 2]
      ```
      而且，数组的`map`和`filter`方法也可以间接用于`Set`了。
      ```js
      let set1 = new Set([1, 2, 3]);
      set1 = new Set([...set1].map(x => x * 2));
      console.log(set1); // {2, 4, 6}

      let set2 = new Set([1, 2, 3, 4, 5]);
      set2 = new Set([...set2].filter(x => (x % 2) == 0));
      console.log(set2); // {2, 4}
      ```
      因此使用`Set`可以容易的实现并集、交集、差集。
      ```js
      let a = new Set([1, 2, 3]);
      let b = new Set([4, 3, 2]);

      // 并集
      let union = new Set([...a, ...b]);
      console.log(union); // {1, 2, 3, 4}

      // 交集
      let intersect = new Set([...a].filter(x => b.has(x)));
      console.log(intersect); // {2, 3}

      // 差集
      let difference = new Set([...a].filter(x => !b.has(x)));
      console.log(difference); // {1}
      ```
      如果想在遍历操作中，同步改变原来的`Set`结构，可以通过两种方法。一种是利用原`Set`结构映射出一个新的结构。然后赋值给原来的`Set`结构；
      另一种是利用`Array.from`方法。
      ```js
      let set1 = new Set([1, 2, 3]);
      set1 = new Set([...set1].map(val => val * 2));
      console.log(set1); // {2, 4, 6}

      let set2 = new Set([1, 2, 3]);
      set2 = new Set(Array.from(set2, val => val * 2));
      console.log(set2); // {2, 4, 6}
      ```
    */
  </script>
</body>

</html>