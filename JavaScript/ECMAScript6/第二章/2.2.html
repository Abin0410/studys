<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>块级作用域</title>
  <script>
    /**
      # 块级作用域

      ## 为什么需要块级作用域
      ES5只有全局作用域和函数作用域，没有块级作用域，这导致很多场景不合理。
      第一种场景，内层变量可能会覆盖外层变量。

        var tmp = new Date();
        function f() {
          console.log(tmp);
          if (false) {
            var tmp = "hello world";
          }
        }
        f(); // undefined

      以上代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。
      但是，函数f执行后，输出结果为undefined，原因在与变量提升导致内层的tmp变量
      覆盖了外层的tmp变量。
      第二种场景，用来计数的循环变量泄露为全局变量。

        var s = 'hello';
        for (var i = 0; i<s.length; i ++) {
          console.log(s[i]);
        }
        console.log(i); // 5

      上面的代码中，变量i只用来控制循环，但循环结束后，它并没有消失，而是泄露成
      了全局变量。

      ### ES6的块级作用域
      let实际上为JavaScript新增了块级作用域。

        function f1() {
          let n = 5;
          if (true) {
            let n = 10;
          }
          console.log(n); // 5
        }
        f1();

      上面的函数有两个代码块，都声明了变量n，运行后输出5.这表示外层代码块不受内
      层代码块的影响。如果使用var定义变量n，最后输出的值就是10。
      ES6允许块级作用域的任意嵌套。
        {{{{{ let insane = 'Hello world' }}}}};
      上面的代码使用了一个5层的块级作用域。外层作用域无法读取内层作用域的变量。

        {{{{
          {let insane = 'Hello world'}
          console.log(insane); // ReferenceError
        }}}}

      内层作用域可以定义外层作用域的同名变量。

        {{{{
          let insane = 'Hello world';
          {let insane = 'Hello world';}
        }}}};

      块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数不再必要了。

        // 匿名函数的写法
        (function (){
          var tmp = ...;
          ...
        }());

        // 块级作用域的写法
        {
          let tmp = ...;
          ...
        }
      
      ### 块级作用域与函数声明
      函数能不能在块级作用域之中声明？这是一个相当令人困惑的问题。
      ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

        // 情况一
        if (true) {
          function f() {}
        }

        // 情况二
        try {
          function f() {}
        } catch(e) {
          // ...
        }

      上面两种函数声明在ES5中都是非法的。
      但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声
      明函数，因此上面两种情况实际上都能运行，并不会报错。
      ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，在块级作用域
      之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

        function f() { console.log('I am outside!'); };

        (function (){
          if (false) {
            // 重复声明一次函数f
            function f() { console.log('I am outside!'); }
          }

          f();
        }())

      以上代码在ES5中运行会得到“I am outside!”，因为在if内声明的函数f会被提升到函
      数头部，实际运行的代码如下。

        function f() { console.log('I am outside!'); };

        (function () {
          function f() { console.log('I am outside!'); }
          if (false) {
          }

          f();
        }())

      而在ES6中运行时完全不一样了，理论上会得到“I am outside!”。因为块级作用域内
      声明的函数类似于let，对作用域之外没有影响。但是，如果真的在ES6浏览器中运行上
      面的代码是会报错的，这是为什么呢？
      原来，如果改变了块级作用域内声明的函数的处理规则，显然对旧代码产生很大影响。
      为了减轻因此产生的不兼容问题，ES6中规定，浏览器的实现可以不遵守上面的规定，
      而有自己的行为方式，具体如下
        允许在块级作用域内声明函数。
        函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
        同时，函数声明还会提升到所在的块级作用域的头部。
      根据这3条规则，在浏览器的ES6环境中，块级作用域内声明函数的行为类似于var声明
      变量。

        // 浏览器的ES6环境
        function f() { console.log('I am outside!'); }
        (function() {
          if (false) {
            // 重复声明一次函数f
            function f() { console.log('I am outside!'); }
          }

          f();
        }());
        // Uncaught TypeError: f is not a function
      上面的代码在符合ES6的浏览器中都会报错，因为实际运行的是以下代码。

        // 浏览器的ES6环境
        function f() { console.log('I am outside!'); }
        (function() {
          var f = undefined
          if (false) {
            function f() { console.log('I am outside!'); }
          }

          f();
        }());
        // Uncaught TypeError: f is not a function

      考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也
      应该写成函数表达式的形式，而不是函数声明语句。

        // 函数声明语句
        {
          let a = 'secret';
          function f() {
            return a;
          }
        }

        // 函数表达式
        {
          let a = 'secret';
          let f = function() {
            return a;
          };
        }
    **/
  </script>
</head>
<body>
  
</body>
</html>