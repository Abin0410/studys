<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## 链判断运算符
      通常我们读取对象里面的某个属性，往往都要判断一下对象是否存在。看下面的例子：
      ```js
      let person = {
        // age: {
        //   ageNum: {
        //     num: 18
        //   }
        // }
      }

      let age = (
        person && person.age && person.age.ageNum && person.age.ageNum.num
      ) || 19;
      console.log(age); // 19
      ```
      上面的例子中，`num`属性在`person`对象里面的第四层，所以就要判断四次，判断每一层是否有值。这样看起来就很不直观。
      还有一种方法就是使用三元运算符`?:`来判断对象是否存在。
      ```js
      const obj = {
        a: {
          text: "我在这"
        }
      };

      const val = obj ? obj.a.text : "没找到";
      console.log(val); // 我在这
      ```
      上面的例子中，首先，必须判断`obj`是否存在，才能取得`text`的值。使用三元运算符要比第一个例子简洁很多。
      
      像第一个例子这样的层层判断不仅不直观不简洁，而且主要是麻烦。因此ES2020引入了“链判断运算符”`?.`，简化了第一个例子的写法。
      ```js
      let person = {
        // age: {
        //   ageNum: {
        //     num: 18
        //   }
        // }
      }

      let age = person ?. age ?. ageNum ?. num || 19;
      console.log(age); // 19
      ```
      这个例子中，使用了`?.`运算符，直接在链式调用的时候进行判断对象是否为`null`或`undefined`。如果是，就不再往下进行运算了，并返回`undefined`。

      链式运算符用来判断函数或者对象方法调用非常有用，看下面的例子：
      ```js
      let obj = {  }

      if (obj.foo?.() === false) {
        console.log("找到啦");
      } else {
        console.log("没找到");
      }
      ```
      上面的例子中，`obj`对象中是否存在`foo()`这个方法，这时`?.`运算符就返回了`undefined`，判读语句就变成了`undefined === false`，所以就执行了
      `false`分支的代码。

      链式判断运算符有三种用法：`obj?.prop`对象属性，`obj.[expr]`也是对象属性，`func?.(...args)`函数或者对象方法的调用。

      但是使用这个运算符有几点需要注意的。

      #### 短路机制

      `?.`运算符相当于一种短路机制，只要不满足条件，就不会往下执行。
      ```js
      let a = {
        x: 1
      };
      let y = "";
      y = a?.["x"];
      console.log(y); // 1
      // 上面的操作等于
      // y = a == null ? undefined : a["x"];
      ```
      上面的例子中，如果`a`是`undefined`或者`null`，那么`y`就等于`undefined`。也就是说，链式判断运算符一旦为真，右侧的表达式就不执行了。

      #### delete运算符
      ```js
      let a = {
        b: ""
      };
      delete a?.b;
      console.log(a);
      // 等同于
      // a == null ? undefined: delete a.b;
      ```
      上面的例子中，如果`a`是`undefined`或`null`，会直接返回`undefined`，而不会进行`delete`运算符。

      #### 括号影响
      如果属性链有圆括号，链判断运算对圆括号外部没有影响，只对圆括号有影响。
      ```js
      (a?.b).c
      // 等价于
      (a == null ? undefined : a.b).c
      ```
      上面代码中，`?.`对圆括号外部并没有影响，不管`a`对象存不存在，圆括号后面的`.c`总是会执行。

      这个例子说明，使用`?.`运算符的场景，不应该使用圆括号。

      #### 报错场合
      以下写法都是禁止的，会导致报错。
      ```js
      // 构造函数
      new obj?.()
      new obj?.foo()

      // 链判断运算符的右侧有模板字符串
      obj?.`{num}`
      obj?.num`{text}`
      ```

      // 链判断运算符的左侧是super
      super?.()
      super?.foo

      // 链运算符用于赋值运算左侧
      a?.b = c
    */
    
  </script>
</body>
</html>