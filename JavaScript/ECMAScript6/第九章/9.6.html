<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /* 
      ## 对象的扩展运算符
      对象的解构赋值用于一个对象取值，相当于把目标对象自身的所有可以遍历的、但未被读取的属性，分配到
      指定的对象上面去。所有的键和它们的值，都会复制到新的对象上。
      ```js
      let obj = { 
        x: 1,
        y: 2,
        a: 3,
        b: 4
      }
      const { x, y, ...z } = obj;

      console.log(x, y, z); // 1 2 {a: 3, b: 4}
      ```
      上面的例子中，变量`z`是解构赋值所在的对象。它获取等号右边的所有没有读取的键（也就是`a`和`b`），
      将它们连同值一起复制过来。

      由于解构赋值要求等号右边必须是一个对象，所以如果等号右边是`undefined`或者`null`的话就会报错。
      因为它们无法转为对象。
      ```js
      let { ...foo } = null; // Cannot destructure 'null' as it is null.
      let { ...bar } = undefined; // Cannot destructure 'undefined' as it is undefined
      ```
      还有解构赋值必须是最后一个参数，否则报错。
      ```js
      let { ...a, b, z } = someObject; // Rest element must be last element
      let { x, ...y, z } = obj; // Rest element must be last element
      ```
      上面的例子中，解构赋值不是最后一个参数，所以出现了报错。

      解构赋值的拷贝只是浅拷贝而已，即如果一个键的值是引用类型或者函数的话，解构赋值拷贝的是这个值的引用，而不是这个值的副本。
      ```js
      let obj = { a: {b: 1} };
      let { ...x } = obj;
      obj.a.b = 2;
      console.log(x.a.b); // 2
      ```
      上面的例子中，`x`是解构赋值所在的对象，拷贝了对象`obj`的`a`属性。`a`属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。

      另外，扩展运算符的解构赋值是不能复制继承自原型对象的属性的。
      ```js
      let o1 = { a: 1 };
      let o2 = { b: 2 };
      o2.__proto__ = o1;
      let { ...o3 } = o2;
      console.log(o3); // {b: 2}
      console.log(o3.a); // undefined
      ```
      上面的例子中，对象`o3`复制了o2，但是只是复制了`o2`自身的属性，并没有复制它的原型对象`o1`的属性。

      来看个例子：
      ```js
      const obj = Object.create({ x: 1, y: 2});
      obj.z = 3;

      let { x, ...newObj } = obj;
      let { y, z } = newObj;
      console.log(x); // 1
      console.log(y); // undefined
      console.log(z); // 3
      ```
      上面的例子中，变量`x`是单纯的解构赋值，所以可以读取对象`o`继承的属性; 变量`y`和`z`是扩展运算符的解构赋值，只能读取对象`o`自身
      的属性，所以变量`z`可以赋值成功，变量`y`取不到值。ES6规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，
      而不能是一个解构赋值表达式。所以上面代码引入了中间变量`newObj`，如果写成下面这样会报错。
      ```js
      let { x, ...{ y, z } } = o; // `...` must be followed by an identifier in declaration contexts
      ```
      解构赋值的一个很大的用处就是扩展函数的参数，引入其他的操作。
      ```js
      function foo({ a, b }) {
        return a + b;
      }

      function bar({x, y, ...restConfig}) {
        return foo(restConfig);
      }

      console.log(bar({x: 1, y: 2, a: 10, b: 20})); // 30
      ```
      上面的例子中，原始函数`foo`接受`a`和`b`作为参数，函数`bar`在`foo`的基础上进行了扩展，接受多余的参数，并且保留原始函数的行为。

      ### 扩展运算符
      对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，复制到当前对象中。
      ```js
      let z = { a: 3, b: 4};
      let n = { ...z };
      console.log(n);
      ```
      对象的扩展运算符也可以用于数组。
      ```js
      let foo = { ...['a', 'b', 'c'] };
      console.log(foo); // {0: "a", 1: "b", 2: "c"}
      ```
      如果扩展运算符后面是一个空对象，并不会产生什么效果。
      ```js
      let obj = { ...{}, a: 1 };
      console.log(obj); // {a: 1}
      ```
      如果扩展运算符后面不是一个对象，会自动转为对象。
      ```js
      let obj = { ...1 };
      console.log(obj); // {}
      ```
      上面的代码中，扩展运算符后面是一个整数`1`，会自动转为数值的包装对象`Number{1}`。由于该对象没有自身属性，所以返回了一个空对象。

      但是，如果扩展运算符后面是个字符串，会自动转成一个类数组的对象，因此返回的不是空对象。
      ```js
      let strting = { ...'hellotutu' };
      console.log(strting); // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o", 5: "t", 6: "u", 7: "t", 8: "u"}
      ```
      对象的扩展运算符相当于`Object.assign()`方法。
      ```js
      let a = "hello";
      let aClone = { ...a };
      console.log(aClone); // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}

      const obj = Object.assign({}, a);
      console.log(obj); // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
      ```
      上面的例子只是拷贝了对象实例的属性而已，想要完整复制一个对象，还要复制对象原型的属性，可以看下面的例子：
      ```js
      let person = { name: "tutu", age: 18, height: "180cm" };

      // 写法一
      const clone1 = {
        __proto__: Object.getPrototypeOf(person),
        ...person
      }
      console.log(clone1); // { name: "tutu", age: 18, height: "180cm" }

      // 写法二
      const clone2 = Object.assign(
        Object.create(Object.getPrototypeOf(person)),
        person
      )
      console.log(clone2); // { name: "tutu", age: 18, height: "180cm" }

      // 写法三
      const clone3 = Object.create(
        Object.getPrototypeOf(person),
        Object.getOwnPropertyDescriptors(person)
      )
      console.log(clone3); // { name: "tutu", age: 18, height: "180cm" }
      ```
      上面的代码中，写法一的`__proto__`属性在`node`环境下不一定能生效，所以推荐大家使用写法二和写法三。

      扩展运算符也可以用于合并两个对象。
      ```js
      let obj1 = { a: 1, b: 2 };
      let obj2 = { c: 3, d: 4 };
      let objConcat = { ...obj1, ...obj2 };
      console.log(objConcat); // {a: 1, b: 2, c: 3, d: 4}
      ```
      如果自定义的属性，放在扩展运算符后面，则扩展运算符内部同名的属性会被覆盖。
      ```js
      let obj = { a: 3, b: 4, c: 5 };

      let objWithOverrides1 = { ...obj, a: 1, b: 2 };
      console.log(objWithOverrides1); // {a: 1, b: 2, c: 5}

      let a = 1;
      let b = 2;
      let objWithOverrides2 = { ...obj, a, b };
      console.log(objWithOverrides2); // {a: 1, b: 2, c: 5}

      let objWithOverrides3 = Object.assign({}, obj, { a, b });
      console.log(objWithOverrides3); // {a: 1, b: 2, c: 5}
      ```
      上面代码中，`obj`对象的`x`属性和`y`属性，拷贝到新对象后会被覆盖了。

      如果把自定义属性放在扩展运算符前面的话，就变成了设置新对象的默认属性值了。就拿上面的例子。
      ```js
      let obj = { a: 3, b: 4, c: 5 };

      let objWithOverrides1 = { a: 1, b: 2, ...obj };
      console.log(objWithOverrides1); // {a: 3, b: 4, c: 5}

      let a = 1;
      let b = 2;
      let objWithOverrides2 = { a, b, ...obj };
      console.log(objWithOverrides2); // {a: 3, b: 4, c: 5}

      let objWithOverrides3 = Object.assign({ a, b }, obj);
      console.log(objWithOverrides3); // {a: 3, b: 4, c: 5}
      ```
      和数组的扩展运算符一样，对象的扩展运算符后面也可以写表达式。
      ```js
      let x = 2;
      const obj = {
        ...(x > 1 ? {a: 1} : {}),
        b: 2
      }
      console.log(obj); // {a: 1, b: 2}
      ```
      扩展运算符的参数对象之中，如果有函数`get`函数，这个函数是会执行的。
      ```js
      let a = {
        get x() {
          throw new Error('not throw yet');
        }
      }

      let withGetter = { ...a }; // Error: not throw yet
      ```
      上面的例子中，`get`函数在扩展`a`对象时会自动执行，导致报错。
    */
    
  </script>
</body>
</html>