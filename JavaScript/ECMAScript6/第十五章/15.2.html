<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <script>
    /* 
      ## 默认Iterator接口

      Iterator接口的目的是为了所有数据结构，提供一种统一的访问机制，即`for...of`循环。当使用`for...of`
      循环遍历某种数据结构时，会自动去找`Iterator`接口。

      一种数据结构只要部署了Iterator接口，这种数据结构就是“可遍历的”（iterable）。

      默认的Iterator接口部署在数据结构的`Symbol.iterator`属性，换种说法就是，一个数据结构只要有`Symbol.iterator`属性，
      就是“可遍历的”（iterable）。`Symbol.iterator`属性本身就是一个函数，就是当前数据结构默认的遍历器生成函数。执行
      这个函数，就会返回一个遍历器。
      ```js
      const myObj = {
        [Symbol.iterator]: function() {
          return {
            next: function() {
              return {
                value: 1,
                done: true
              }
            }
          }
        }
      };

      console.log(myObj[Symbol.iterator]().next());
      // {value: 1, done: true}
      ```
      上面的代码中，对象`myObj`是可遍历的（iterble），因为具有`Symbol.iterator`属性。执行这个属性，返回一个遍历器对象。
      该对象的特征就是有`next`方法，每次调用`next`方法，都会返回一个代表当前成员的信息对象，有`value`和`done`属性。

      有一些数据结构原生具有Iterator接口（例如数组），不用做任何处理，就可以被`for...of`循环遍历。因为，这些数据原生
      部署了`Symbol.iterator`属性，另外有一些数据结构没有（例如对象）。如果部署了`Symbol.iterator`属性的数据结构，就
      是部署了遍历器接口。调用这个接口就会返回一个遍历器对象。

      原生具备Iterator接口的数据结构有：`Array`、`Map`、`Set`、`String`、`TypedArray`、函数的`arguments`对象、`NodeList`对象。

      来看个例子：
      ```js
      var arr = [1, 2, 3];
      var iter = arr[Symbol.iterator]();

      console.log(iter.next()); // {value: 1, done: false}
      console.log(iter.next()); // {value: 2, done: false}
      console.log(iter.next()); // {value: 3, done: false}
      console.log(iter.next()); // {value: undefined, done: true}
      ```
      上面的代码中，变量`arr`是一个数组，原生就有遍历器接口，部署在`arr`的`Symbol.iterator`属性上。所以，调用这个属性，就
      得到遍历器对象。

      对于原生部署Iterator接口的数据结构，不用自己写遍历器生成函数，`for...of`循环会自动遍历它们。除此之外，其他数据结构
      （主要是对象）的Iterator接口，都需要在`Symbol.iterator`属性上面部署，这样做才会被`for...of`循环遍历。

      对象之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要手动指定。本质上，遍历器
      是一种线性处理，对于任何非线性的数据结构，部署遍历接口，就等于部署一种线性转换。严格的说，对象部署遍历器接口并不是很必要的，
      因为这时对象实际上被当作Map结构使用。

      一个对象如果要具备可被`for...of`循环调用的Iterator接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法。
      ```js
      class RangeIterator {
        constructor(start, stop) {
          this.value = start;
          this.stop = stop;
        }

        [Symbol.iterator]() { return this; }

        next() {
          var value = this.value;

          if (value < this.stop) {
            this.value++;
            return { done: false, value: value };
          }
          return { done: true, value: undefined };
        }
      }

      function range(start, stop) {
        return new RangeIterator(start, stop);
      }

      for (let value of range(0, 5)) {
        console.log(value);
      }
      // 0
      // 1
      // 2
      // 3
      // 4
      ```
      上面代码是一个类部署Iterator接口的写法。`Symbol.iterator`属性对应一个函数，执行后返回当前对象的遍历器对象。
      ```js
      function Obj(value) {
        this.value = value;
        this.next = null;
      }

      Obj.prototype[Symbol.iterator] = function() {
        var iterator = { next: next };
        var current = this;

        function next() {
          if (current) {
            var value = current.value;
            current = current.next;
            return { done: false, value: value };
          } else {
            return { done: true };
          }
        }
        return iterator;
      }

      let a = new Obj(1);
      let b = new Obj(2);
      let c = new Obj(3);

      a.next = b;
      b.next = c;

      for (let i of a) {
        console.log(i);
      }
      // 1
      // 2
      // 3
      ```
      上面代码首先在构造函数的原型链上部署`Symbol.iterator`方法，调用该方法会返回遍历器对象`iterator`，调用该对象的
      `next`方法，返回一个值的同时，自动将内部指针移到下一个实例。

      下面是另一个为对象添加Iterator接口的例子。
      ```js
      let obj = {
        data: ['hello', 'world'],
        [Symbol.iterator]() {
          const self = this;
          let index = 0;

          return {
            next() {
              if (index < self.data.length) {
                return {
                  value: self.data[index++],
                  done: false
                };
              } else {
                return { value: undefined, done: true };
              }
            }
          };
        }
      };

      for (let item of obj) {
        console.log(item);
      }
      // hello
      // world
      ```
      对于类似数组的对象，例如，存在数值键名和`length`属性，需要部署Iterator接口，就是`Symbol.iterator`方法直接引用数
      组的`Iterator`接口。
      ```js
      const list = document.querySelectorAll('div');

      list.__proto__[Symbol.iterator] = Array.prototype[Symbol.iterator];

      for (let item of list) {
        console.log(item);
      }

      console.log([...list]);
      ```
      NodeList对象是类数组的对象，它本身就有遍历接口，可以直接进行遍历。上面的代码中，将它的遍历接口改成数组的`Symbol.iterator`属性。
      丝毫不受影响。

      来看另一个类数组的对象调用数组的`Symbol.iterator`方法的例子：
      ```js
      let iterable = {
        0: 'a',
        1: 'b',
        2: 'c',
        length: 3,
        [Symbol.iterator]: Array.prototype[Symbol.iterator]
      };

      for(let item of iterable) {
        console.log(item);
      }

      // a
      // b
      // c
      ```
      要注意的是普通对象部署数组的`Symbol.iterator`方法，是无效的。
      ```js
      const obj = {
        x: 'x',
        y: 'y',
        n: 'n',
        length: 3,
        [Symbol.iterator]: Array.prototype[Symbol.iterator]
      };

      for (let item of obj) {
        console.log(item);
      }
      // undefined
      // undefined
      // undefined
      ```
      如果`Symbol.iterator`方法对应的不是一个遍历器生成函数，会导致报错。
      ```js
      let obj = {};
      obj[Symbol.iterator] = () => 1;

      console.log([...obj]);
      // TypeError: Result of the Symbol.iterator method is not an object
      ```
      上面的代码中，变量`obj`的`Symbol.iterator`方法对应的不是遍历器生成函数，所以导致报错了。

      有了遍历器接口就可以使用`while`循环遍历。也可以使用`for...of`循环遍历。
      ```js
      let iterator = [1, 2, 3, 4, 5, 6, 7][Symbol.iterator]();
      let result = iterator.next();

      while (!result.done) {
        console.log(result.value);
        result = iterator.next();
      }
      // 1
      // 2
      // 3
      // 4
      // 5
      // 6
      // 7
      ```
      上面的代码，`iterator`是一个数组，`result`是它的遍历器对象。遍历器对象每次移动指针，都会检查一下返回值的`done`属性，是否为`false`，
      如果遍历器没结束，就会继续遍历下去。直到`done`属性的值为`true`，就停止了。
    */
    
  </script>
</body>
</html>