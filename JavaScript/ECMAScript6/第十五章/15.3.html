<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /* 
      ## 调用Iterator接口的场景

      有些场景会默认调用Iterator（也就是`Symbol.iterator`方法），除了`for...of`循环之外，还有几个场景。

      #### 解构赋值
      对数组和Set结构进行解构赋值时，会默认调用`Symbol.iterator`方法。
      ```js
      let set = new Set().add('a').add('b').add('c');
      let [x, y] = set;

      console.log(x, y);
      // a b

      let [first, ...rest] = set;
      console.log(first, rest);
      // a ["b", "c"]
      ```

      #### 扩展运算符
      扩展运算符（...）也会调用默认的Iterator接口。
      ```js
      let string = 'hello';
      console.log([...string]); // ["h", "e", "l", "l", "o"]

      let arr = ['b', 'c'];
      console.log(['a', ...arr, 'd']); // ["a", "b", "c", "d"]
      ```
      这样就提供了一种机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以
      对它使用扩展运算符转成数组。

      #### yield*
      `yield*`后面跟的是一个可遍历的结构，就会调用该结构的遍历器接口。
      ```js
      let  generator = function* () {
        yield 1;
        yield* [2, 3, 4];
        yield 5;
      };

      var iterator = generator();

      console.log(iterator.next()); // {value: 1, done: false}
      console.log(iterator.next()); // {value: 2, done: false}
      console.log(iterator.next()); // {value: 3, done: false}
      console.log(iterator.next()); // {value: 4, done: false}
      console.log(iterator.next()); // {value: 5, done: false}
      console.log(iterator.next()); // {value: undefined, done: true}
      ```

      #### 其他场景
      由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。看下面的例子。
      * `for...of`
      * `Array.from()`
      * `Map()`、`Set()`、`WeakMap()`、`WeakSet()`
      * `Promise.all()`
      * `Promise.race()`
    */
    
  </script>
</body>
</html>