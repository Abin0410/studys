<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## Array.from()

      `Array.from`方法用于将两类对象转为真正的数组：类数组的对象和可遍历的对象（包括ES6新增的数据结构Set和Map）。

      下面是一个类数组的对象，使用`Array.from`将它转为真正的数组。
      ```js
      let arrayLike = {
        '0': 'a',
        '1': 'b',
        '2': 'c',
        length: 3
      };

      // ES5的写法
      var arr1 = [].slice.call(arrayLike);

      // ES6的写法
      var arr2 = Array.from(arrayLike);

      console.log(arr1); // ["a", "b", "c"]
      console.log(arr2); // ["a", "b", "c"]
      ```
      实际应用中，常见的类数组的对象有`DOM`操作返回的`NodeList`集合，以及函数内部的`arguments`对象。都可以用`Array.form`将其转为真正的数组。
      ```js
      let div = document.querySelectorAll('div');
      console.log(Array.from(div)); // []

      function fun() {
        let args = Array.from(arguments);
        console.log(args); // []
      }
      fun();
      ```
      上面的代码中，`querySelectAll`方法返回的是一个类数组的对象，使用`Array.from`可以将这个对象转为真正的数组。函数内部的`arguments`也是如此。

      只要是部署了 `Iterator` 接口的数据结构，`Array.from`都能将其转为数组。
      ```js
      console.log(Array.from('hello'));

      let namesSet = new Set(['a', 'b']); // ["h", "e", "l", "l", "o"]
      console.log(Array.from(namesSet)); // ["a", "b"]
      ```
      上面的代码中，字符串和Set结构都具有 `Iterator` 接口，因此可以被 `Array.from` 转为真正的数组。

      如果参数是一个真正的数组，Array.from会返回一个一摸一样的新数组。
      ```js
      console.log(Array.from([1, 2, 3])); // [1, 2, 3]
      ```
      扩展运算符 **(...)** 也可以将某些数据结构转为数组。
      ```js
      function fun() {
        let args = [...arguments];
        return args;
      }
      console.log(fun()); // []

      let div = document.querySelectorAll('div');
      console.log([...div]); // []
      ```
      扩展运算符背后调用的其实就是遍历器接口`(Symbol.iterator)`，如果一个对象没有部署这个接口，就无法转换。`Array.from`方法还支持类数组的对象。
      所谓类数组的对象，本质特征只有一点，必须有`length`属性。因此，任何有`length`属性的对象，都可以使用`Array.from`方法转为数组，而此时扩展运
      算符就无法转换。
      ```js
      console.log(Array.from({ length: 3 })); // [undefined, undefined, undefined]
      ```
      上面的代码中，`Array.from`返回了一个具有三个成员的数组，每一个位置的值都是`undefined`。扩展运算符转换不了这个对象。

      对于那些没有部署该方法的浏览器，可以使用`Array.prototype.slice`方法来代替。
      ```js
      const toArray = (() => 
        Array.from ? Array.from : obj => [].slice.call(obj)
      )();

      console.log(toArray([1, 2, 3])); // [1, 2, 3]
      console.log(toArray({ length: 3 })); // [undefined, undefined, undefined]
      ```

      `Array.from`还可以接受第二个参数，作用类似数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
      ```js
      console.log(Array.from([1, 2, 3], x => x * x)); // [1, 4, 9]
      ```
      看下面的例子，将数组中布尔值为`flase`的成员转为`0`。
      ```js
      console.log(Array.from([1, , 2, , 3,], n => n || 0)); // [1, 0, 2, 0, 3]
      ```
      另一个例子是返回各种数据的类型。
      ```js
      function typesOf() {
        return Array.from(arguments, value => typeof value);
      }

      console.log(typesOf(null, [], NaN)); // ["object", "object", "number"]
      ```
      如果`map`函数里面用到了`this`关键字，那么`Array.from`还可以传入第三个参数，用来绑定`this`。

      `Array.from()`可以将各种值转为数组，并且提供了`map`功能。这意味着，只要有一个原始的数据结构，你就可以对它的值进行处理，然后
      转成规范的数据结构，就可以使用很多的数组方法。
      ```js
      console.log(Array.from({ length: 2 }, () => 'jack')); // ["jack", "jack"]
      ```
      上面的代码中，`Array.from`的第一个参数指定了第二个参数运行的次数，这种特性可以让该方法的用法变得非常的灵活。

      `Array.from()`的另一个应用是将字符串转为数组，然后返回字符串的长度。
      ```js
      console.log(Array.from('hello')); //  ["h", "e", "l", "l", "o"]
      console.log(Array.from('hello').length); // 5
      ```
    */
    
  </script>
</body>
</html>