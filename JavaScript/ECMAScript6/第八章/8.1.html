<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <script>
    /* 
      # 数组扩展

      ## 扩展运算符
      扩展运算符是用三个点(...)来标识，就跟rest参数的逆运算一样，将一个数组转为用逗号分隔的参数序列。
      ```js
      console.log(...[1, 2, 3]); // 1 2 3
      console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5
      ```
      一般都是用在函数调用。
      ```js
      function push(array, ...items) {
        array.push(...items);
      }

      function add(x, y) {
        return x + y;
      }

      const numbers = [4, 38];
      console.log(add(...numbers)); // 42
      ```
      以上代码中，array.push(...items)和add(...numbers)这两行，都是属于函数的调用，并且都使用了扩展运算符。
      该运算符将一个数组，变为参数序列。

      扩展运算符还可以和正常的函数参数结合使用。
      ```js
      function f(v, w, x, y, z) { 
        console.log(v, w, x, y, z); // -1 0 1 2 3
      }
      const args = [0, 1];
      f(-1, ...args, 2, ...[3]);
      ```
      扩展运算符后面还可以使用表达式。
      ```js
      const x = 1;
      const arr = [
        ...(x > 0 ? ['a'] : []),
        'b',
      ];
      console.log(arr);
      ```
      如果扩展运算符后面是一个空数组的话，不会产生任何效果。
      ```js
      let arr = [...[], 1];
      console.log(arr); // [1]
      ```

      ### 代替函数的apply()方法
      由于扩展运算符可以用于展开数组，所以不再需要apply方法，将数组转为函数的参数了。
      ```js
      // 以前的写法
      function f(x, y, z) {
        console.log(x, y, z); // 0 1 2
      }

      var args = [0, 1, 2];
      f.apply(null, args); 

      // ES6的写法
      function f(x, y, z) {
        console.log(x, y, z); // 0 1 2
      }
      let args = [0, 1, 2];
      f(...args);
      ```
      扩展运算符取代apply方法的一个实际的例子，用到Math.max方法上，简化求出一个数组最大元素的写法。
      ```js
      // ES5的写法
      console.log(Math.max.apply(null, [14, 3, 77])); // 77

      // ES6的写法
      console.log(Math.max(...[14, 3, 77])); // 77

      // 等价于
      console.log(Math.max(14, 3, 77)); // 77
      ```

      ### 扩展运算符应用
      
      #### 复制数组

      数组是复合的数据类型，如果直接复制的话，只是复制了指向原数组的指针而已。而不是克隆一个全新的数组，
      引用类型都有这样的行为。看下面的例子：
      ```js
      const a1 = [1, 2];
      const a2 = a1;
      a2[0] = 2;
      console.log(a1); // [2, 2]
      ```
      上面的例子中，a2并不是克隆a1，而是指向同一个数组的另一个指针而已，修改了a2，同时会影响到a1的变化。

      在ES5中只能用变通方法来复制数组。
      ```js
      const a1 = [1, 2];
      const a2 = a1.concat();
      a2[0] = 3;
      console.log(a1); // [1, 2]
      console.log(a2); // [3, 2]
      ```
      上面的代码中，a2变量中通过concat()方法把a1的数组克隆了一份，a2修改数组的值时，a1并不会受到影响。
      不知道concat()用法的同学，可以去补补基础先。

      如果使用扩展运算符的话，也是可以复制数组的，只不过比前面的例子更加简便了。
      ```js
      const a1 = [1, 2];
      const a2 = [...a1];
      a2[0] = 4;
      console.log(a1); // [1, 2]
      console.log(a2); // [4, 2]
      ```

      ### 合并数组
      扩展运算符提供了数组合并的全新写法，在ES5可以使用concat()方法实现数组合并。
      ```js
      const arr1 = ['a', 'b'];
      const arr2 = ['c'];
      const arr3 = ['d', 'e'];

      // ES5的合并数组
      console.log(arr1.concat(arr2, arr3)); // ["a", "b", "c", "d", "e"]

      // ES6的合并数组
      console.log([...arr1, ...arr2, ...arr3]); // ["a", "b", "c", "d", "e"]
      ```
      但是这两种都是浅拷贝，使用的时候需要注意一下。
      ```js
      const a1 = [{ foo: 1 }];
      const a2 = [{ bar: 2 }];

      const a3 = a1.concat(a2);
      const a4 = [...a1, ...a2];

      console.log(a3[0] === a1[0]); // true
      console.log(a4[0] === a1[0]); // true
      ```
      上面的代码中，a3和a4是用了两种不同的方式合并的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。
      如果修改了引用指向的值，会同步反映到新数组。

      ### 与解构赋值结合
      扩展运算符可以与解构赋值一起使用，用来生成数组。
      ```js
      // ES5的写法
      const list = [1, 2, 3, 4, 5];
      const a = list[0]; 
      const rest = list.slice(1);
      console.log(a); // 1
      console.log(rest); // [2, 3, 4, 5]

      // ES6的写法
      const list = [1, 2, 3, 4, 5];
      const [a, ...rest] = list;
      console.log(a); // 1
      console.log(rest); // [2, 3, 4, 5]
      ```
      看另外一个例子。
      ```js
      const [first, ...rest] = [1, 2, 3, 4, 5];
      console.log(first); // 1
      console.log(rest); // [2, 3, 4, 5]

      const [a, ...b] = [];
      console.log(a); // undefined
      console.log(b); // []

      const [c, ...d] = ["foo"];
      console.log(c); // foo
      console.log(d); // []
      ```

      如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则报错。
      ```js
      const [...first, rest] = [1, 2, 3, 4, 5];
      // Uncaught SyntaxError: Rest element must be last element

      const [a, ...b, c] = [1, 2, 3, 4, 5];
      // Uncaught SyntaxError: Rest element must be last element
      ```

      ### 实现了Iterator接口的对象
      任何定义了 **遍历器(Iterator)** 接口的对象，都可以用扩展运算符转为真正的数组。
      ```js
      let nodeList = document.querySelectorAll('div');
      let array = [...nodeList];
      console.log(array); // [div, div, div, div]
      ```
      上面的代码中，querySelectorAll方法返回的是一个NodeList对象，它并不是一个数组，而是和arguments具有一样特征的类数组的对象。
      可以使用扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator。

      ```js
      Number.prototype[Symbol.iterator] = function*() {
        let i = 0;
        let num = this.valueOf();
        while (i < num) {
          yield i++;
        }
      }

      console.log([...5]);
      ```
      上面的代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。

      对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法其转为真正的数组。
      ```js
      let arrayLike = {
        '0': 'a',
        '1': 'b',
        '2': 'c',
        length: 3
      };

      // Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))
      let arr = [...arrayLike];
      ```
      上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以使用Array.from方法将arrayLike转为真正的数组。

      ### Map和Set结构，Generator函数
      扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。
      ```js
      let map = new Map([
        [1, 'noe'],
        [2, 'two'],
        [3, 'three'],
      ]);
      let arr = [...map.keys()];
      console.log(arr); // [1, 2, 3]
      ```
      Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。
      ```js
      const go = function*() {
        yield 1;
        yield 2;
        yield 3;
      };
      console.log([...go()]); // [1, 2, 3]
      ```
      上面的代码中，变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。

      如果对没有Iterator接口的对象，使用扩展运算符，将会报错。
      ```js
      const obj = {a: 1, b: 2};
      let arr = [...obj]; // Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))
      ```
    */
    
  </script>
</body>
</html>