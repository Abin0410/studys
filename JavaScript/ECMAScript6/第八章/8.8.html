<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      数组的includes()
      `includes()`方法是返回一个布尔值，表示数组中是否包含有给定的值。
      ```js
      const arr = ["java", "javascript", "Rudy", "C", "C++", "C#"];

      console.log(arr.includes("Rudy")); // true
      ```
      `includes()`方法的第二个参数表示搜索的开始位置，默认是`0`。如果第二个参数是负数的话，则表示倒数的位置，
      如果它大于数组的长度（例如：第二个参数为`-4`，但数组长度为`3`的时候），会重置为从`0`开始。
      ```js
      const arr = ["java", "javascript", "Rudy", "C", "C++", "C#"];

      console.log(arr.includes("C", 6)); // false
      console.log(arr.includes("C#", -1)); // true
      console.log(arr.includes("javascript", -7)); // true
      ```
      在没有这个方法之前，我们一般都是通过使用数组的`indexOf()`方法，检查数组里是否包含某个值。
      ```js
      const arr = ["java", "javascript", "Rudy", "C", "C++", "C#"];

      if (arr.indexOf("javascript") !== -1) {
        console.log("数组里面有你想要检索的值");
      }
      ```
      但是`indexOf()`方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现的位置，所以要比较是否不等于`-1`，
      二是，它内部使用严格相等运算符（`===`）进行判断的话，会导致`NaN`的误判。
      ```js
      console.log([NaN].indexOf(NaN)); // -1
      ```
      `includes`使用的是一样的判断算法，就没有问题了。
      ```js
      console.log([NaN].includes(NaN)); // true
      ```
    */
  </script>
</body>
</html>