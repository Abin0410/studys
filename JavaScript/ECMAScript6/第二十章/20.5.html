<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>

<body>
  <script>
    /*
      ## 原生构造函数的继承
      原生构造函数指的是语言内置的函数，通常用来生成数据结构。js的原生构造函数大致有下面这些。
      * Boolean()
      * Number()
      * String()
      * Array()
      * Date()
      * Function()
      * RegExp()
      * Error()
      * Object()

      以前，这些原生构造函数是无法继承的，比如，不能自己定义一个`Array`的子类。
      ```js
      function MyArray() {
        Array.apply(this, arguments);
      }

      MyArray.prototype = Object.create(Array.prototype, {
        constructor: {
          value: MyArray,
          writable: true,
          configurable: true,
          enumerable: true
        }
      });
      ```
      上面代码定义了一个继承`Array`的`MyArray`类。但这个类的行为和`Array`完全不一致。
      ```js
      let colors = new MyArray();
      colors[0] = 'red';
      console.log(colors.length); // 0

      colors.length = 0;
      console.log(colors[0]); // red
      ```
      之所以会出现这种情况，是因为子类无法获得原生构造函数的内部属性，通过`Array.apply()`或者分配
      给原型对象都不行。原生构造函数会忽略`apply`方法传入的`this`，也就是说，原生构造函数的`this`
      无法绑定，导致拿不到内部属性。

      ES5是先新建子类的实例对象`this`，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致
      无法继承原生的构造函数。比如，`Array`构造函数有一个内部属性`[[DefineOwnProperty]]`，用来
      定义新属性时，更新`length`属性，这个内部属性无法在子类获取，导致子类的`length`属性行为不正常。

      下面的例子中，我们想让一个普通对象继承`Error`对象。
      ```js
      var e = {};
      console.log(Object.getOwnPropertyNames(Error.call(e)));
      // ["stack"]

      console.log(Object.getOwnPropertyNames(e));
      // []
      ```
      上面代码中，想通过`Error.call(e)`这种写法，让普通对象`e`具有`Error`对象的实例属性。但是，`Error.call()`完全忽略传入的
      第一个参数，而是返回一个新对象的实例属性。`e`本身没有任何变化。这证明了`Error.call(e)`这种写法，无法继承原生构造函数。

      ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有
      行为都可以继承。下面是一个继承`Array`的例子。
      ```js
      class MyArray extends Array {
        constructor(...args) {
          super(...args);
        }
      }

      var arr = new MyArray();
      arr[0] = 12;
      console.log(arr.length);
      // 1

      arr.length = 0;
      console.log(arr[0]);
      // undefined
      ```
      上面代码定义了一个`MyArray`类，继承了`Array`构造函数，因此就可以从`MyArray`生成数组的实例。这意味着，ES6可以自定义原生
      数据结构（例如`Array`、`String`等）的子类，这些都是ES5做不到的。

      上面这个例子也说明，`extends`关键字不仅可以用来继承类，还可以用来继承原生的构造函数，因此可以在原生数据结构的基础上，定义
      自己的数据结构。下面就是定义了一个带版本功能的数组。
      ```js
      class VersioneArray extends Array {
        constructor() {
          super();
          this.history = [[]];
        }

        commit() {
          this.history.push(this.slice());
        }

        revert() {
          this.splice(0, this.length, ...this.history.length - 1);
        }
      }

      var x = new VersioneArray();

      x.push(1);
      x.push(2);
      console.log(x);
      // [1, 2, history: Array(1)]
      console.log(x.history);
      // [Array(0)]

      x.push(3);
      console.log(x);
      // [1, 2, 3, history: Array(1)]
      console.log(x.history);
      // [Array(0)]

      x.reverse();
      console.log(x);
      // [3, 2, 1, history: Array(1)]
      ```
      上面代码中，`VersionedArray`会通过`commit`方法，将自己的当前状态生成一个版本快照，存入`history`属性。`revert`方法
      用来将数组重置为最新一次保存的版本。除此之外，`VersionedArray`依然是一个数组，所有原生的数组方法都可以在它上面调用。

      下面是一个自定义`Error`子类的例子，可以用来定制报错时的行为。
      ```js
      class ExtendableError extends Error {
        constructor(message) {
          super();
          this.message = message;
          this.stack = (new Error()).stack;
          this.name = this.constructor.name;
        }
      }

      class MyError extends ExtendableError {
        constructor(m) {
          super(m);
        }
      }

      var myerror = new MyError('11');

      console.log(myerror.message);
      // 11
      console.log(myerror instanceof Error);
      // true
      console.log(myerror.name);
      // MyError
      console.log(myerror.stack);
      // Error
      // at new ExtendableError
      ```
      注意，继承`Error`的子类，有一个行为差异。
      ```js
      class NewObj extends Object {
        constructor() {
          super(...arguments);
        }
      }

      var o = new NewObj({ attr: true });
      console.log(o.attr === true); // false
      ```
      上面代码中，`NewObj`继承了`Object`，但是无法通过`super`方法向父类`Object`传参。这是因为
      ES6改变了`Object`构造函数的行为，一旦发现`Object`方法不是通过`new Object()`这种形式调用，
      ES6规定`Object`构造函数会忽略参数。
    */

  </script>
</body>

</html>