<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*  
      ## 含义

      ### Generator与状态机
      Generator是实现状态的最佳结构。比如，下面的`clock`函数就是一个状态机。
      ```js
      let tickting = true;
      let clock = function() {
        if (tickting) {
          console.log('开', tickting);
        } else {
          console.log('关', tickting);
        }
        tickting = !tickting;
      }

      clock(); // 开 true
      clock(); // 关 false
      ```
      上面的代码中，`clock`函数一共有两种状态（`开`和`关`），每次运行，就会改变一次状态。如果使用Generator函数改写，就是下面这样。
      ```js
      let clock = function* () {
        while (true) {
          console.log('开');
          yield;
          console.log('关');
          yield;
        }
      }

      let gen = clock();

      gen.next(); // 开
      gen.next(); // 关
      ```
      使用Generator函数写法，除了少个用来保存状态的外部变量`ticking`，这样更简洁，也安全，而且状态不会被非法篡改。从写法上看更加优雅。
      Generator之所以可以不用外部变量保存状态，是因为它本身就包含饿了一个状态信息。

      ### Generator与协程
      协程是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。单线程是一种特殊的
      子例程，多线程则是一种特殊的线程。

      #### 1.协程和子例程的差异
      传统的“子例程”采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程就不一样了，多个线程（单线程
      情况，就是多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停状态，线程（或函数）之间
      可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到之后收回执行权的时候，再
      恢复执行。这种可以并行执行、交换执行权的线程（或函数），就是协程。

      从实现上看，在内存中，子例程只使用一个栈，而协程是同时存在多个栈，但是只有一个栈是在运行状态，也就是说，协程是以多占用内存的代价，实现
      多任务的并行。

      #### 2.协程和普通线程的差异
      不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，
      同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停装填。此外，普通的线程是抢先式的，到底哪个线程先得到资源，
      必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配的。

      由于JavaScript是单线程语言，只能保持一个调用栈，引入协程之后，每个任务可以保持自己的调用栈，这样做的最大好处，就是抛出错误的时候，可以找
      到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。

      Generator函数是ES6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”，意思就是只有Generator函数的调用者，才能将程序的执行权还给
      Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。

      如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用`yield`表达式交换执行权。

      ### Generator和上下文
      JavaScript代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，
      又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前的上下文，由此形成一个上下文环境的堆栈。

      这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直到所有代码执行完成，堆栈清空。

      Generator函数不是这样的，它执行产生的上下文环境，一旦遇到`yield`命令，就会暂时退出堆栈，但是不会消失，里面的所有变量和对象会冻结在当前状态。
      等到对它执行`next`命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。
      ```js
      function* gen() {
        yield 1;
        return 2;
      }

      let g = gen();

      console.log(g.next().value, g.next().value); // 1 2
      ```
      上面代码中，第一次执行`g.next`时，Generator函数`gen`的上下文会加入堆栈，就是开始运行`gen`内部的代码。等遇到`yield 1`时，`gen`上下文退出堆栈，
      内部状态冻结。第二次执行`g.next()`时，`gen`上下文重新加入堆栈，变成当前的上下文，重新恢复执行。
    */
    
  </script>
</body>
</html>