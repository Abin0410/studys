<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## 应用
      Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。

      ### 异步操作的同步化表达
      Generator函数的暂停执行效果。意味着可以把异步操作写在`yield`语句里面，等到调用`next`方法时再往后执行。这
      实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在`yield`语句下面，反正要等到调用`next`方法时
      再执行。所以，Generator函数的一个重要实际意义就是用于处理异步操作，改写回调函数。
      ```js
      function* loadUI() {
        showLoadingScreen();
        yield loadUIDataAsynchronously();
        hideLoadingScreen();
      }

      let loader = loadUI();
      // 加载
      loader.next();

      // 卸载
      loader.next();
      ```
      上面的代码中，第一次调用`loadUI`函数时，该函数并不会执行，仅返回一个遍历器。下一次对该遍历器调用`next`方法，
      就会显示Loading界面（`showLoadingScreen`），并且异步加载数据（`loadUIDataAsynchronously`）。等到数据加载完成，
      再一次使用`next`方法，就会隐藏Loading界面。这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数里，按部
      就班非常清晰。

      AJAX是典型的异步操作，通过Generator函数部署AJAX操作，可以用同步的方式表达。
      ```js
      function* main() {
        let result = yield request('http://some.url');
        let resp = JSON.parse(result);
        console.log(resp.value);
      }

      function request(url) {
        makeAjaxCall(url, function(response) {
          it.next(response);
        });
      }

      let it = main();
      it.next();
      ```
      上面的`main`函数就是通过AJAX操作获取数据。除了多了一个`yield`，它几乎与同步操作的写法一样的。
      :::warning
      `mackAjaxCall`函数中的`next`方法必须加上`response`参数，这是因为`yield`语句构成的表达式本身就是没值的，总是等于`undefined`。
      :::
      下面是另一个例子，通过Generator函数逐行读取文本文件。
      ```js
      function* numbers() {
        let file = new FileReader("numbers.txt");
        console.log(file);
        try {
          while(!file.eof) {
            yield parseInt(file.readLine(), 10);
          }
        } finally {
          file.close();
        }
      }
      ```
      上面的代码打开文本文件，使用`yield`语句可以手动逐行读取文件。

      ### 控制流管理
      如果有一个多步操作是非常耗时的，采用回调函数可能会写成下面这样。
      ```js
      step1(function(value1) {
        step2(value1, function(value2) {
          step3(value2, function(value3) {
            //...
          });
        });
      });
      ```
      采用Promise改写上面的代码如下。
      ```js
      Promise.resolve(step1)
        .then(step2)
        .then(step3)
        .then((value3) => {
          // ...
        }, (err) => {
          // ...
        })
        .done();
      ```
      上面的代码已经把回调函数改成了直线执行的形式，但是加入了大量的Promise的语法。Generator函数可以进一步改善代码运行流程。
      ```js
      function* longRunningTask(value1) {
        try {
          let value2 = yield step1(value1);
          let value3 = yield step2(value2);
        } catch (e) {
          // ...
        }
      }
      ```
      然后，使用一个函数按次序自动执行所有步骤。
      ```js
      scheduler(longRunningTask(initialValue));

      function scheduler(task) {
        let taskObj = task.next(task.value);
        // 如果Generator函数未结束，就继续调用
        if (!taskObj.done) {
          task.value = taskObj.value
          scheduler(task);
        }
      }
      ```
      :::warning
      上面的这种做法只适合同步操作，即所有的`task`都必须是同步的，不能有异步操作。因此这里的代码一得到返回值就会继续往下执行，
      没有判断异步操作什么时候完成。
      :::

      利用`for...of`循环自动依次执行`yield`命令的特性，提供一种更一般的控制流管理的方法。
      ```js
      let steps = [step1Func, step2Func, step3Func];

      function *iterateSteps(steps) {
        for (let i=0; i < steps.length; i++) {
          let step = steps[i];
          yield step();
        }
      }
      ```
      上面的代码中，数组`steps`封装了一个任务的多个步骤，Generator函数`iterateSteps`则依次为这些步骤加上`yield`命令。

      把任务分解成步骤之后，还可以把项目分解成多个依次执行的任务。
      ```js
      let jobs = [job1, job2, job3];

      function* iterateJobs(jobs) {
        for (let i=0; i < jobs.length; i++) {
          let job = jobs[i];
          yield* iterateSteps(job.steps);
        }
      }
      ```
      上面的代码中，数组`jobs`封装了一个项目的多个任务，Generator函数`iterateJobs`则是依次为这些任务加上了`yield*`命令。

      最后，可以用`for...of`循环一次性依次执行所有任务的所有步骤。
      ```js
      for (let step of iterateJobs(jobs)) {
        console.log(step.id);
      }
      ```
      上面的做法只能用于所有步骤都是同步操作的情况，不能用异步操作的情况。
      `for...of`本质上是一个`while`循环，所以上面的代码实质上执行的是下面的逻辑。
      ```js
      let it = iterateJobs(jobs);
      let res = it.next();

      while (!res.done) {
        let result = res.value;
        // ...
        res = it.next();
      }
      ```

      ### 部署Iterator接口
      利用Generator函数可以在任意对象上部署Iterator接口。
      ```js
      function* iterEntries(obj) {
        let keys = Object.keys(obj);
        for (let i=0; i< keys.length; i++) {
          let key = keys[i];
          yield [key, obj[key]];
        }
      }

      let person = { name: 'tutu', age: 20 };

      for (let [key, value] of iterEntries(person)) {
        console.log(key, value);
      }
      // name tutu
      // age 20
      ```
      上面的代码中，`person`是一个对象，通过`iterEntries`函数就有了Iterator接口。也就是说，可以在任意对象上部署`next`方法。

      下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。
      ```js
      function* makeSimpleGenerator(arr) {
        let nextIndex = 0;

        while (nextIndex < arr.length) {
          yield arr[nextIndex++];
        }
      }

      let gen = makeSimpleGenerator(['xiaohong', 'xiaoming', 'xiaoli']);

      console.log(gen.next()); // {value: "xiaohong", done: false}
      console.log(gen.next()); // {value: "xiaoming", done: false}
      console.log(gen.next()); // {value: "xiaoli", done: false}
      console.log(gen.next().done); // true
      ```

      ### 作为数据结构
      Generator可以看作数据结构，更确切地说，可以看作一个数组结构，因为Generator函数返回一系列的值，这意味着它可以对任意表达
      式提供类似数组的接口。
      ```js
      function *doStuff() {
        yield fs.readFile.bind(null, 'hello.txt');
        yield fs.readFile.bind(null, 'world.txt');
        yield fs.readFile.bind(null, 'and-such.txt');
      }
      ```
      上面的代码依次返回3个函数，但是由于使用了Generator函数，导致可以像处理数组那样处理3个返回的函数。
      ```js
      for (task of doStuff()) {
        // task是一个函数，可以像回调函数那样使用它
      }
      ```
      实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。
      ```js
      function doStuff() {
        return [
          fs.readFile.bind(null, 'hello.txt'),
          fs.readFile.bind(null, 'world.txt'),
          fs.readFile.bind(null, 'and-such.txt')
        ];
      }
      ```
      上面的函数可以用一模一样的`for...of`循环处理，两相比较不难看出，Generator使得数据或操作具备了类似数组的接口。
    */
    
  </script>
</body>
</html>