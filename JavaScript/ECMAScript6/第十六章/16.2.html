<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## next方法的参数
      `yield`表达式本身是没有返回值的，也可以说总会返回`undefined`。`next`方法可以带一个参数，该参数就会
      被当作上一个`yield`表达式的返回值。
      ```js
      function* f() {
        for (let i = 0; true; i++) {
          let reset = yield i;
          if (reset) { i = -1; }
        }
      }

      let g = f();

      console.log(g.next()); // {value: 0, done: false}
      console.log(g.next()); // {value: 1, done: false}
      console.log(g.next(true)); // {value: 0, done: false}
      console.log(g.next()); // {value: 1, done: false}
      console.log(g.next()); // {value: 2, done: false}
      console.log(g.next()); // {value: 3, done: false}
      ```
      上面的代码中先定义了一个可以无限运行的Generator函数`f`，如果`next`方法没有参数，每次运行到`yield`表达式，变量`reset`
      的值总是`undefined`。当`next`方法带一个参数`true`时，变量`reset`就被重置为这个参数（也就是true），这时`i`就等于`-1`，
      在下一轮循环就会从`-1`开始递增。

      这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态是不变的。通过`next`方法的参数，就有办法
      在Generator函数开始运行之后，继续向函数提内部注入值。也就是说，可以在`Generator`函数运行的不同阶段，从外部向内部注入不
      同的值，从而调整函数行为。

      再来看一个例子。
      ```js
      function* foo(x) {
        const y = 2 * (yield (x + 1));
        const z = yield (y / 3);
        return (x + y + z);
      }

      let a = foo(5);
      console.log(a.next()); // {value: 6, done: false}
      console.log(a.next()); // {value: NaN, done: false}
      console.log(a.next()); // {value: NaN, done: true}
      ```
      上面代码中，第二次运行`next`方法的时候不带参数，导致`y`的值等于`2 * undefined`（即`NaN`），除以3以后还是`NaN`，因此返回
      对象的`value`属性也等于`NaN`。第三次运行`next`方法的时候不带参数，所以`z`等于`undefined`，返回对象的`value`属性等于`5 + NaN + undefined`，即`NaN`。
      ```js
      function* foo(x) {
        const y = 2 * (yield (x + 1));
        const z = yield (y / 3);
        return (x + y + z);
      }

      let b = foo(5);
      console.log(b.next()); // {value: 6, done: false}
      console.log(b.next(12)); // {value: 8, done: false}
      console.log(b.next(13)); // {value: 42, done: true}
      ```
      如果向`next`方法提供参数，返回结果那就不一样了。上面的代码第一次调用`b`的`next`方法时，返回`x+1`的值`6`；第二次调用`next`方法，将上一次
      `yield`表达式的值设为`12`，因此`y`等于`24`，返回`y / 3`的值`8`；第三次调用`next`方法，将上一次`yield`表达式的值设为`13`，因此`z`等于`13`，
      这时`x`等于`5`，`y`等于`24`，所以`return`语句的值等于`42`。

      要注意的是，由于`next`方法的参数表示上一个`yield`表达式的返回值，所以在第一次使用`next`方法时，传递参数是无效的。只有从第二次使用`next`方
      法开始，参数才是有效的。从语义上讲，第一个`next`方法用来启动遍历器对象而已，所以不需要带参数。
      ```js
      function* dataConsumer() {
        console.log('start');

        console.log(`1, ${yield}`);
        console.log(`2, ${yield}`);
      }

      let genObj = dataConsumer();

      genObj.next(); // start
      genObj.next('a'); // 1, a
      genObj.next('b'); // 2, b
      ```
      上面的代码是一个很直观的例子，每次通过`next`方法向Generator函数输入值，然后打印出来。

      如果想要第一次调用`next`方法时，就能够输入值，可以在Generator函数外面再包一层。
      ```js
      function wrapper(generatorFunction) {
        return function(...args) {
          let generatorObject = generatorFunction(...args);
          generatorObject.next();
          return generatorObject;
        };
      }

      const wrapped = wrapper(function* () {
        console.log(`First input: ${yield}`);
        return 'DONE';
      });

      wrapped().next('hello!');
      // First input: hello!
      ```
      上面代码中，Generator函数如果不用`wrapper`先包一层，是无法第一次调用`next`方法，就输入参数的。
    */
    
  </script>
</body>
</html>