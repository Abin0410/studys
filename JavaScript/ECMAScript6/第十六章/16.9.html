<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## Generator函数的this
      Generator函数总是会返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的
      `prototype`对象上的方法。
      ```js
      function* g() {
        
      }

      g.prototype.hello = function() {
        return 'hi!';
      }

      let obj = g();

      console.log(obj instanceof g); // true
      console.log(obj.hello()); // hi!
      ```
      上面代码中，`obj`就是Generator函数`g`返回的遍历器，`obj`是`g`的实例，也继承了`g.prototype`。但是，如果把`g`
      当作普通的构造函数，并不会生效，因为`g`返回的总是遍历器对象，而不是`this`对象。
      ```js
      function* g() {
        this.a = 1;
      }

      let obj = g();
      console.log(obj.next()); // {value: undefined, done: true}
      console.log(obj.a); // undefined
      ```
      上面的代码中，Generator函数`g`在`this`对象上面添加了一个属性`a`，但是`obj`对象拿不到这个属性。

      Generator函数不能和`new`操作符一起使用，会导致报错。
      ```js
      function* Func() {
        yield this.x = 2;
        yield this.y = 3;
      }

      const gen = new Func();
      // Uncaught TypeError: Func is not a constructor
      ```
      上面的代码中，`new`操作符跟构造函数`Func`一起使用，就报错了，因为F不是构造函数。

      下面是一个变通方法。首先，生成一个空对象，使用`call`方法绑定Generator函数内部的`this`。这样，构造函数调用以后，
      这个空对象就是Generator函数的实例对象了。
      ```js
      function* Func() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
      }

      let obj = {};
      let f = Func.call(obj);

      console.log(f.next()); // {value: 2, done: false}
      console.log(f.next()); // {value: 3, done: false}
      console.log(f.next()); // {value: undefined, done: true}

      console.log(obj.a); // 1
      console.log(obj); // {a: 1, b: 2, c: 3}
      ```
      上面代码中，`F`内部的`this`对象绑定`obj`对象，然后调用它返回一个Iterator对象。这个对象执行了三次`next`方法
      （因为F内部有两个`yield`表达式），完成`F`内部所有代码的运行。这时，所有内部属性都绑定在`obj`对象上了，因此
      `obj`对象也就成了`F`的实例。

      上面代码中，执行的是遍历器对象`f`，但是生成的对象实例是`obj`。为了把这两个对象统一，把`obj`换成`F.prototype`。
      ```js
      function* Func() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
      }

      let f = Func.call(Func.prototype);

      console.log(f.next()); // {value: 2, done: false}
      console.log(f.next()); // {value: 3, done: false}
      console.log(f.next()); // {value: undefined, done: true}

      console.log(f.a); // 1
      console.log(f.b); // 2
      console.log(f.c); // 3
      ```
      再把`F`改成构造函数，就可以对它执行`new`操作符。
      ```js
      function* gen() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
      }

      function Func() {
        return gen.call(gen.prototype);
      }

      let f = new Func();

      console.log(f.next()); // {value: 2, done: false}
      console.log(f.next()); // {value: 3, done: false}
      console.log(f.next()); // {value: undefined, done: true}

      console.log(f.a); // 1
      console.log(f.b); // 2
      console.log(f.c); // 3
      ```
    */
  </script>
</body>
</html>