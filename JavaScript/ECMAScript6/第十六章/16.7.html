<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## yield* 表达式
      如果在Generator函数内部，调用另一个Generator函数。需要在前者的函数体内，手动遍历。
      ```js
      function* foo() {
        yield 1;
        yield 2;
      }

      function* bar() {
        yield 3;
        for (let i of foo()) {
          console.log(i);
        }
        yield 4;
      }

      for (let v of bar()) {
        console.log(v);
      }

      // 3
      // 1
      // 2
      // 4
      ```
      上面的代码中，`foo`和`bar`都是Generator函数，在`bar`里面调用`foo`，就要手动遍历`foo`。如果说未来有多个Generator函数嵌套的话，
      这种写法就很麻烦。

      使用`yield*`可以解决这类问题，它的作用就是用来在一个Generator函数里面执行另一个Generator函数的。
      ```js
      function* bar() {
        yield 1;
        yield 2;
        yield* foo();
        yield 5;
      }

      function* foo() {
        yield 3;
        yield 4;
      }

      for (let item of bar()) {
        console.log(item);
      }
      // 1
      // 2
      // 3
      // 4
      // 5
      ```
      再来看个例子：
      ```js
      function* inner() {
        yield 'hello';
      }

      function* outer1() {
        yield '打开';
        yield inner();
        yield '退出';
      }

      let gen1 = outer1();
      console.log(gen1.next().value); // 打开
      console.log(gen1.next().value); // inner {<suspended>}
      console.log(gen1.next().value); // 退出

      function* outer2() {
        yield '打开';
        yield* inner();
        yield '退出';
      }

      let gen2 = outer2();
      console.log(gen2.next().value); // 打开
      console.log(gen2.next().value); // hello
      console.log(gen2.next().value); // 退出
      ```
      上面的例子中，`outer2`使用了`yield*`，`outer1`没使用。结果`outer1`返回了一个遍历器对象，而`outer2`返回的是该遍历器对象的内部值。

      如果`yield`表达式后面是一个遍历器对象的话，就需要在`yield`表达式后面加一个星号，表示它返回的是一个遍历器对象。这被成为`yield*`表达式。
      ```js
      let delegatedIterator = (function* () {
        yield 'hello';
        yield 'Bye!';
      }());

      let delegatingIterator = (function* () {
        yield 'Greetings!';
        yield* delegatedIterator;
        yield 'ok, bye.';
      }());

      for (let value of delegatingIterator) {
        console.log(value);
      }
      // Greetings!
      // hello
      // Bye!
      // ok, bye.
      ```
      上面代码中，`delegatingIterator`是代理者，`delegatedIterator`是被代理者。由于`yield* delegatedIterator`语句得到的值，是一个遍历器，所
      以要用幸好表示。运行结果就是使用一个遍历器，遍历了多个Generator，有递归的效果。

      `yield*`后面的Generator函数（没有return语句时），就等于在Generator函数内部，部署一个`for...of`循环。
      ```js
      function* concat(iter1, iter2) {
        yield* iter1;
        yield* iter2;
      }

      const arr1 = [1, 2, 3];
      const arr2 = [4, 5, 6];

      for (let value of concat(arr1, arr2)) {
        console.log(value);
      }
      // 1
      // 2
      // 3
      // 4
      // 5
      // 6
      
      function* concat(iter1, iter2) {
        for (let value of iter1) {
          yield value;
        }

        for (let value of iter2) {
          yield value;
        }
      } 
      ```
      上面代码说明，`yield*`后面的Generator函数（没有`return`语句时），不过是`for...of`的一种简写形式，完全可以用后者代替前者。
      反而如果在有`return`语句时，就需要`var value = yield* iterator`的形式获取`return`语句的值。

      如果`yield*`后面跟着一个数组，数组原生本来就支持遍历器，所以就会遍历数组成员。
      ```js
      function* gen() {
        yield* ['a', 'b', 'c'];
      }

      console.log(gen().next()); // {value: "a", done: false}
      ```
      上面代码中，`yield`命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。

      任何数据结构只要有Iterator接口，就可以被`yield*`遍历。
      ```js
      let read = (function* () {
        yield 'hello';
        yield* 'hello';
      })();

      console.log(read.next().value); // hello
      console.log(read.next().value); // h

      for (let item of read) {
        console.log(item);
      }
      // hello
      // h
      // e
      // l
      // l
      // o
      ```
      上面代码中，`yield`表达式返回了整个字符串，而`yield*`语句返回的是单个，这是因为字符串具有Iterator接口，所以会被`yield*`遍历。

      如果被代理的Generator函数有`return`语句的话，就可以向代理它的Generator函数返回数据。
      ```js
      function* foo() {
        yield 2;
        yield 3;
        return "foo";
      }

      function* bar() {
        yield 1;
        let f = yield * foo();
        console.log(`v：${f}`);
        yield 4;
      }

      let it = bar();

      for (let item of it) {
        console.log(item);
      }
      // 1
      // 2
      // 3
      // v：foo
      // 4
      ```
      上面代码中，使用`for...of`循环遍历`it`，在输出`3`之后就会输出Generator函数`foo`的返回值。这是因为函数`foo`的`return`语句，
      向函数`bar`提供了返回值。

      来看另一个例子。
      ```js
      function* genFuncWithReturn() {
        yield 1;
        yield 2;
        return 'The result';
      }

      function* logReturned(genObj) {
        let result = yield* genObj;
        console.log(result);
      }

      console.log([...logReturned(genFuncWithReturn())]);
      ```
      上面的代码中，存在了两次遍历。第一次是扩展运算符遍历函数`logReturned`返回的遍历器对象，第二次是`yield*`语句遍历`genFuncWithReturn`
      返回的遍历器对象。这两次遍历的效果都是叠加的，也就是扩展运算符遍历函数`genFuncWithReturn`返回的遍历器对象。最后表达式得到的值等于
      `[1, 2]`。但是函数`genFuncWithReturn`的`return`语句的返回值`The result`，会返回给函数`logReturned`内部的`result`变量，就在控制台输出。

      `yield*`命令可以方便地取出嵌套数组的所有成员。
      ```js
      function* iterTree(tree) {
        if (Array.isArray(tree)) {
          for (let i = 0; i< tree.length; i++) {
            yield* iterTree(tree[i]);
          }
        } else {
          yield tree;
        }
      }

      const tree = [1, [2, 3, 4], 5, [[6, 7]]];

      for (let item of iterTree(tree)) {
        console.log(item);
      }
      // 1
      // 2
      // 3
      // 4
      // 5
      // 6
      // 7
      ```
      扩展运算符`...`会默认调用Iterator接口，所以上面这个函数也可以用于嵌套数组拉平。
      ```js
      function* iterTree(tree) {
        if (Array.isArray(tree)) {
          for (let i = 0; i< tree.length; i++) {
            yield* iterTree(tree[i]);
          }
        } else {
          yield tree;
        }
      }

      const tree = [1, [2, 3, 4], 5, [[6, 7]]];

      console.log([...iterTree(tree)]);
      // [1, 2, 3, 4, 5, 6, 7]
      ```
    */
    
  </script>
</body>
</html>