<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /*
      ## Generator.prototype.throw()
      Generator函数返回的遍历器对象，有一个`throw`方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。
      ```js
      let gen = function* () {
      try {
          yield;
        } catch(e) {
          console.log('内部捕获错误', e);
        }
      };

      let i = gen();

      i.next();

      try {
        i.throw('a');
        i.throw('b');
      } catch (e) {
        console.log('外部捕获错误', e);
      }
      // 内部捕获错误 a
      // 外部捕获错误 b
      ```
      上面的代码中，遍历器对象`i`抛出了两个错误。第一个错误被Generator函数体内的`catch`语句捕获。`i`第二次抛出错误，是
      由于Generator函数内部的`catch`语句已经执行过了，不会再捕捉到这个错误，所以这个错误就被抛出了Generator函数体，被
      函数体外的`catch`语句捕获。

      `throw`方法接受一个参数，该参数会被`catch`语句接收，建议使用`Error`的实例。
      ```js
      let gen = function* () {
        try {
          yield;
        } catch(e) {
          // 在这里打印了throw传过来的参数
          console.log(e);
          // Error: 又有bug了
        }
      }
      
      let i = gen();
      i.next();
      i.throw(new Error('又有bug了'));
      ```
      上面的代码中，是用遍历器对象的`throw`方法抛出的，而不是用全局的`throw`命令抛出的，不要混淆遍历器对象的`throw`方法和全局`throw`命令，
      全局的`throw`只能被函数体外的`catch`语句捕获。
      ```js
      let gen = function* () {
        while (true) {
          try {
            yield;
          } catch(e) {
            console.log(e);
            if (e !== 'a')  throw e;
            console.log('内部捕获', e);
          }
        }
      };

      let i = gen();

      i.next();

      try {
        throw new Error('a');
        throw new Error('b');
      } catch (e) {
        console.log('外部捕获', e);
      }
      ```
      上面代码之所以只捕获了`a`，是因为函数体外的`catch`语句，捕获了抛出的`a`错误以后，就不会再继续`try`代码块里面剩余的语句了。

      如果Generator函数内部没有`try...catch`语句的话，使用`throw`方法抛出的错误，会被函数体外的`try...catch`代码块捕获。
      ```js
      function* gen() {
        while (true) {
          yield;
          console.log('内部捕获', e);
        }
      };

      let i = gen();
      i.next();

      try {
        i.throw('a');
        i.throw('b');
      } catch (e) {
        console.log('外部捕获', e);
      }
      // 外部捕获 a
      ```
      上面的代码中，Generator函数`gen`内部没有`try...catch`语句，所以抛出的错误就被外部的`catch`代码块捕获。

      如果Generator函数内部和外部都没有部署`try...catch`语句，会直接报错。而且会中断执行。
      ```js
      function* gen() {
        yield console.log('1');
        yield console.log('2');
      };

      let i = gen();

      i.next();
      i.throw();
      // 1
      // Uncaught undefined
      ```
      上面的代码中，`i.throw`抛出错误之后，没有任何`try...catch`语句捕获这个错误，所以导致报错，中断了执行。

      `throw`方法抛出的错误想要被内部捕获的话，前提是必须执行一次过`next`方法。
      ```js
      function* gen() {
        try {
          yield 1;
        } catch (e) {
          console.log('内部捕获');
        }
      }

      let g = gen();
      g.throw(1);
      // Uncaught 1
      ```
      上面的代码中，`g.throw(1)`执行时，`next`方法一次都没有执行。抛出的错误不会被内部捕获，而是直接在外部抛出，导致报错了。
      这是因为第一次执行`next`方法，就等于启动执行Generator函数的内部代码，不然Generator函数还没有执行，`throw`方法抛错只可
      能抛出在函数外部。

      `throw`方法被捕获之后，会附带执行下一条`yield`表达式。也就是说，捕获错误的同时，会执行一次`next`方法。
      ```js
      function* gen() {
        try {
          yield console.log('1');
        } catch (e) {
          console.log('内部捕获错误', e);
        }
        yield console.log('2');
        yield console.log('3');
      }

      let g = gen();
      g.next();
      g.throw('哎呀，又出bug了');
      g.next();
      // 1
      // 内部捕获错误 哎呀，又出bug了
      // 2
      // 3
      ```
      上面的代码中，`g.throw`方法被捕获之后，自动执行了一次`next`方法，所以打印了`2`。也可以看到，只要Generator函数内部部署了`try...catch`
      代码块，遍历器的`throw`方法抛出错误，也不会影响到下一次遍历。

      `throw`命令和`g.throw`方法是无关的。两者互不影响。
      ```js
      let gen = function* gen() {
        yield console.log('hello');
        yield console.log('world');
      }

      let g = gen();
      g.next();

      try {
        throw new Error();
      } catch (e) {
        g.next();
      }
      // hello
      // world
      ```
      上面的代码中，`throw`命令抛出的错误毫不影响到遍历器的状态，两次执行`next`方法，都进行了正确的操作。

      这种函数体内捕获错误的机制，方便了对错误的处理。多个`yield`表达式，只用一个`try...catch`代码块来捕获错误。
      如果使用回调函数的写法，想要捕获多个错误，不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部
      写一次`catch`语句就可以了。

      Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的`catch`捕获。
      ```js
      function* foo() {
        let x = yield 3;
        let y = x.toUpperCase();
        yield y;
      }

      let it = foo();

      it.next();

      try {
        it.next(42);
      } catch (err) {
        console.log(err);
      }
      // TypeError: x.toUpperCase is not a function
      ```
      上面的代码中，第二个`next`方法向函数体内传入一个参数42，而数值是没有`toUpperCase`方法，就抛出了一个错误，被函数体外的`catch`捕获。

      一旦Generator执行过程中抛出错误，如果没有被内部捕获，就不会再执行下去。如果之后再调用`next`方法，会返回一个`value`属性等于`undefined`、
      `done`属性等于`true`的对象。JavaScript引擎会认为这个Generator已经运行结束了。
      ```js
      function* g() {
        yield 1;
        console.log('throwing an exception');
        throw new Error('generator broke!');
        yield 2;
        yield 3;
      }

      function log(generator) {
        let v;
        console.log('starting generator');

        try {
          v = generator.next();
          console.log('第一次运行next方法', v);
        } catch (err) {
          console.log('捕捉错误', v);
        }

        try {
          v = generator.next();
          console.log('第二次运行next方法', v);
        } catch (err) {
          console.log('捕捉错误', v);
        }

        try {
          v = generator.next();
          console.log('第三次运行next方法', v);
        } catch (err) {
          console.log('捕捉错误', v);
        }
        console.log('caller done');
      }

      log(g());
      // starting generator
      // 第一次运行next方法 {value: 1, done: false}
      // throwing an exception
      // 捕捉错误 {value: 1, done: false}
      // 第三次运行next方法 {value: undefined, done: true}
      // caller done
      ```
      上面代码中，一共运行了三次`next`方法，第二次运行就会抛出错误，然后第三次运行的时候，Generator函数已经结束了，就不会再执行下去了。
    */
  </script>
</body>
</html>