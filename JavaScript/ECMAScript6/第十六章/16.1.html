<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /* 
      # Generator函数语法

      ## 基本概念

      Generator函数是ES6提供的一种异步编程解决方案，语法行为和传统的函数完全不一样。从语法上来说，可以把它理解成
      一个状态机，封装了多个内部状态。

      执行Generator函数会返回一个遍历器对象。也就是说，Generator函数除了是状态机，还是一个遍历器对象生成函数。返回
      的遍历器对象可以依次遍历Generator函数内部的每个状态。

      Generator函数是一个普通函数，但是有两个特性：一是`function`命令和函数名之间有一个星号；二是函数体内使用`yield`
      语句定义不同的内部状态。
      ```js
      function* namesGenerator() {
        yield 'tutu';
        yield 'xiaohong';
        return 'ending';
      };

      let names = namesGenerator();
      ```
      上面的代码中，定义了一个`Generator`函数----`namesGenerator`，它内部有两个`yield`语句“tutu”和“xiaohong”，也就是这个
      函数有3个状态：`tutu`、`xiaohong`和`return`语句。

      Generator函数调用方法和普通函数是一样的，也是在函数名后面加上一对圆括号。不同之处是，调用Generator函数后，该函数并
      不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。

      下一步，必须调用遍历器对象的`next`方法，从而使得指针移向下一个状态。也就是说，每次调用`next`方法，内部指针就从函数
      头部或上一次停下来的地方开始执行，直到遇到下一个`yield`表达式或者`return`语句为止。换句话说，Generator函数是分段执
      行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。
      ```js
      function* namesGenerator() {
        yield 'tutu';
        yield 'xiaohong';
        yield 'xiaoming';
        return 'ending';
      };

      let names = namesGenerator();

      console.log(names.next()); // {value: "tutu", done: false}
      console.log(names.next()); // {value: "xiaohong", done: false}
      console.log(names.next()); // {value: "xiaoming", done: false}
      console.log(names.next()); // {value: "ending", done: true}
      console.log(names.next()); // {value: undefined, done: true}
      ```
      上面代码调用了四次`next`方法。

      每调用一次，Generator函数开始执行，直到遇到`yield`表达式为止。`next`方法返回的是一个对象，对象包含`value`和`done`属性。
      `value`属性就是当前`yield`表达式的值`tutu`、`xiaohong`、`xiaoming`，`done`属性的值`false`，表示遍历没有结束。如果`done`
      的值`为true`，表示遍历已结束。再次调用`next`方法会返回对象的`value`属性为`undefined`，`done`属性为`true`，之后再调用
      `next`方法，依旧都会返回这个值。

      调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。之后，每次调用遍历器对象的`next`方法，都会返回一个具有
      `value`和`done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面的那个表达式的值；`done`属性是一个布尔
      值，表示是否遍历结束。

      ES6并没有规定，`function`关键字与函数名之间的星号，写在哪个位置。这导致了一些写法都可以通过，看下面的例子。
      ```js
      function * fun(x, y) {  };
      function *fun(x, y) {  };
      function* fun(x, y) {  };
      function*fun(x, y) {  };
      ```
      由于Generator函数是一个普通函数，所以一般的写法是上面的第三种，星号紧跟在`function`后面。

      ### yield
      由于Generator函数返回的遍历器对象，只有调用`next`方法才会遍历下一个内部状态，所以提供了一种可以暂停执行的函数。`yield`表达式
      就是暂停标志。

      遍历器对象的`next`方法的运行逻辑有四点：
      1. 遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。
      2. 下次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。
      3. 如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的
        对象的`value`属性值。
      4. 如果函数没有`return`语句，则返回的对象的`value`属性为`undefined`。

      要注意的是，`yield`表达式后面的表达式，只有当调用`next`方法、内部指针指向该语句的时候才会执行，这样就等于可以手动的“惰性求值”
      的语法功能。
      ```js
      function* func() {
        yield 1 + 1;
      }

      const num = func();

      console.log(num.next()); // {value: 2, done: false}
      ```
      上面的代码中，`yield`后面的表达式`1 + 1`，不会立即求值，只会在`next`方法将指针移到这一句时，才会求值。
    */
    
  </script>
</body>
</html>