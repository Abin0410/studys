<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>window对象</title>
  <script>
    /**
      BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是
      通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页
      中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。

      全局作用域
      由于window对象同时扮演者ECMAScript中Global对象的角色，因此所有在全局作用域中声明的变量、
      函数都会变成window对象的属性和方法。来看下面的例子。

        var age = 29;
        function sayAge() {
          console.log(this.age);
        };
        console.log(window.age); // 29
        sayAge(); // 29
        window.sayAge(); // 29
      
      我们在全局作用域中定义了一个变量age和一个函数sayAge()，它们被自动归在了window对象名下。
      于是，可以通过window.age访问变量age，可以用过window.sayAge()访问函数sayAge()。由于
      sayAge()存在于全局作用域中，因此this.age被映射到window.age，最终显示的仍然是正确的结果。

      抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有
      有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。
      例如：

        var age = 29;
        window.color = "red";

        delete window.age;

        delete window.color;
        console.log(window.age); // 29
        console.log(window.color); // undefined

      刚才使用var语句添加的window属性有一个名为[[Configurable(可配置)]]的特性，这个特性的值
      被设置为false，因此这样定义的属性不可以用过delete操作符删除。

      另外，还要记住一件事：尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道
      某个可能未声明的变量是否存在。例如：

        // 这里会抛出错误，因为oldValue未定义
        var newValue = oldValue;

        // 这里不会抛出错误，因为这是一次属性查询
        // newValue的值是undefined
        var newValue = window.oldValue;
        console.log(newValue); // undefined

      后面还会讲到很多全局JavaScript对象（如location和navigator）实际上都是window对象的属性。

      窗口大小
      window.innerHeight和window.innerWidth获取浏览器窗口大小。
      document.documentElement.clientWidth和document.documentElement.clientHeight也是

      打开窗口
      使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法
      可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历
      史记录中当前加载页面的布尔值。通常只须传递第一个参数就行了，最后一个参数只在不打开新窗口
      的情况下使用。

        window.open("https://www.baidu.com/");

      关闭窗口使用window.close();

        window.close();

      间歇调用和超时调用
      JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。
      前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。
      超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表
      示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个包含JavaScript代
      码的字符串（就和eval()函数中使用的字符串一样），也可以是一个函数。例如，下面对setTime-
      out()的两次调用都会在一秒中后显示一个警告框。

        // 不建议传递字符串！
        setTimeout("alert('Hello world！')", 1000);

        // 推荐的调用方式
        setTimeout(function() {
          alert("Hello world!");
        }, 1000);

      虽然这两种调用方式都没有问题，但由于传递字符串可能导致性能损失，因此不建议以字符串作为
      第一个参数。
      第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定执行。JavaScript
      是一个单线程的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个Java-
      Script任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉
      JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；
      如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。

      调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码
      的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用clearTimeout()
      方法并将相应的超时调用ID作为参数传递给它，如下所示。

        var timeoutId = setTimeout(function() {
          alert("Hello world！");
          // 也可以写在这里面
          // clearTimeout(timeoutId);
        }, 1000);

        // 注意：把它取消
        clearTimeout(timeoutId);

      只要是在指定的时间尚未过去之前调用clearTimeout()，就可以完全取消超时调用。前面的代码在
      设置超时调用之后马上又调用clearTimeout()，结果就跟什么也没有发生一样。

      间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者
      页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同；要执行
      的代码（字符串或函数）和每次执行之前需要等待的毫秒数。下面来看一个例子。

        // 不建议传递字符串！
        setInterval("console.log('Hello world')",1000);

        // 推荐的调用方式
        setInterval(function() {
          console.log("Hello world");
        }, 1000);

      调用setInterval()方法同样也会返回一个间歇调用ID，该ID可用于在将来某个时刻取消间歇调用。
      要取消尚未执行的间歇调用，可以使用clearInterval()方法并传入相应的间歇调用ID。取消时歇
      调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面
      卸载。以下是一个常见的使用间歇调用的例子。

        var num = 0;
        var max = 10;
        var intervalId = null;

        function incrementNumber() {
          num++;
          // 如果执行次数达到了max设定的值，则取消后续尚未执行的调用
          if (num == max) {
            clearInterval(intervalId);
          }
        }

        intervalId = setInterval(incrementNumber, 500);

      在这个例子中，变量num每半秒钟递增一次，当递增到最大值就会取消先前设定的间歇调用。这个
      模式也可以使用超时调用来实现。如下所示。

        var num = 0;
        var max = 10;

        function incrementNumber() {
          num++;
          // 如果执行次数达到了max设定的值，则设置另一次超时调用
          if (num < max) {
            setTimeout(incrementNumber, 500);
          } else {
            alert("Done");
          }
        }

        setTimeout(incrementNumber, 500);

      可见，在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一
      次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在
      开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前
      启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。

      系统对话框
      浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框
      与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，
      而不是由css决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话
      框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。

    */
  </script>
</head>
<body>
  
</body>
</html>