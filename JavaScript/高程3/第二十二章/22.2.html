<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /**
      ## 防篡改对象
      JavaScript共享的本质一直是开发人员心头的痛。因为任何对象都可以被在同一环境中运行的代码
      修改。开发人员很可能会意外地修改别人的代码，甚至更糟糕地，用不兼容的功能重写原生对象。
      ECMAScript5致力于解决这个问题，可以让开发人员定义防篡改对象。

      :::warning 警告
      不过请注意：一旦把对象定义为防篡改，就无法撤销了。
      :::

      ### 不可扩展对象
      默认情况下，所有对象都是可以扩展的。任何时候都可以向对象中添加属性和方法。看下面的例子：
      ```js
      var person = { name: "xiaoli" };
      person.age = 22;
      console.log(person); // name: "xiaoli" age: 22
      ```
      即使第一行代码已经完整定义person对象，但第二行代码仍然能给它添加属性。但使用 **Object.preventExtensions()** 
      方法可以改变这个行为，让你不能再给对象添加属性和方法。看下面的例子：
      ```js
      var person = { name: "xiaoli" };
      Object.preventExtensions(person);
      person.age = 22;
      console.log(person.age); // undefined
      ```
      在调用了 **Object.preventExtensions()** 方法后，就不能给person对象添加新属性和方法了。
      
      虽然不能给对象添加新成员，但已有的成员则丝毫不受影响。。你仍然还可以修改删除已有的成员。另外，
      使用 **Object.isExtensible()** 方法还可以确定对象是否可以扩展。
      ```js
      var person = { name: "xiaoli" };
      console.log(Object.isExtensible(person)); // true

      Object.preventExtensions(person);
      console.log(Object.isExtensible(person)); // false
      ```

      ### 密封的对象
      ECMAScript5为对象定义的第二个保护级别是密封对象。密封对象不可扩展，而且已用成员的[[Configurable]]
      特性将被设置为false。这就意味着不能删除属性和方法，因为不能使用 **Object.defineProperty()** 把数
      据修改为访问器属性，或者相反。属性值是可以修改的。

      要密封对象，可以使用 **Object.seal()** 方法。
      ```js
      var person = { name: "xiaoli" };
      Object.seal(person);

      person.age = 19;

      console.log(person.age); // undefined

      delete person.name;
      console.log(person.name); // xiaoli
      ```
      这个例子中，添加age属性的行为被忽略了，而尝试删除name属性的操作也被忽略了，因此这个属性没有受到
      任何影响。

      使用 **Object.isSealed()** 方法可以确定对象是否被密封了，因为被密封的对象不可扩展，所以用
       **Object.isExtensible()** 检测密封的对象也会返回false。
      ```js
      var person = { name: "xiaoli" };
      console.log(Object.isExtensible(person)); // true
      console.log(Object.isSealed(person)); // false

      Object.seal(person);
      console.log(Object.isSealed(person)); // true
      console.log(Object.isExtensible(person)); // false
      ```

      :::warning 警告
      虽然对象被密封了，但是还是可以修改对象上原有的属性的值。
      :::

      ### 冻结的对象
      
      最严格的防篡改级别是冻结对象。冻结的对象既不可扩展，又是密封的，而且对象数据属性的[[Writable]]特
      性会被设置为false。如果定义[[Set]]函数，访问器属性仍然是可写的。ECMAScript5定义了 **Object.freeze()** 
      方法可以用来冻结对象。
      ```js
      var person = { name: "xiaoli" };
      Object.freeze(person);

      person.age = 29;
      console.log(person.age); // undefined

      delete person.name;
      console.log(person.name); // xiaoli

      person.name = "xiaohong";
      console.log(person.name); // xiaoli
      ```
      与密封和不可扩展一样，对冻结的对象执行非法操作在非严格模式下会被忽略，而在严格模式下会抛出错误。

      因为冻结对象既是密封的又是不可扩展的，所以用 **Object.isExtensible()** 和 **Object.isSealed()**
      检测冻结对象将分别返回false和true。
      ```js
      var person = { name: "xiaoli" };
      console.log(Object.isExtensible(person)); // true
      console.log(Object.isSealed(person)); // false
      console.log(Object.isFrozen(person)); // false

      Object.freeze(person);

      console.log(Object.isExtensible(person)); // false
      console.log(Object.isSealed(person)); // true
      console.log(Object.isFrozen(person)); // true
      ```
    **/
  </script>
</body>
</html>