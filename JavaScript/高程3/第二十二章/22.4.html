<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <script>
    /**
      ## 自定义事件

      事件是一种叫做观察者的设计模式，是一种创建松散耦合代码的技术。对象可以发布事件，用来表示在该对象
      的某一时刻到了。然后其他对象可以观察该对象，等待这某一时刻到来并通知运行代码来响应。

      观察者模式由两类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。
      该模式的一个关键概念是主体并不知道观察者的任何事情，也就是说它可以独自存在并正常运作即使观察者不
      存在。从另一个方面来说，观察者知道主体并能注册事件的回调函数。就拿DOM来说，DOM元素就是主体，而
      事件处理代码就是观察者。

      事件是与DOM交互的最常见方式，但它们可以用于非DOM代码中----通过实现自定义事件。自定义事件背后的
      概念是创建一个管理事件的对象，让其他对象监听那些事件。如下：
      ```js
      function EventTarget() {
        this.handlers = {};
      }

      EventTarget.prototype = {
        constructor:EventTarget,
        addHandler: function(type, handler) {
          if (typeof this.handlers[type] == "undefined") {
            this.handlers[type] = [];
          }

          this.handlers[type].push(handler);
        },

        fire: function(event) {
          if (!event.target) {
            event.target = this;
          }
          if (this.handlers[event.type] instanceof Array) {
            var handlers = this.handlers[event.type];

            for (var i = 0, len = handlers.length; i < len; i ++) {
              handlers[i](event);
            }
          }
        },

        removeHandler: function(type, handler) {
          if (this.handlers[type] instanceof Array) {
            var handlers = this.handlers[type];

            for (var i = 0, len = handlers.length; i < len; i++) {
              if (handlers[i] === handler) {
                break;
              }
            }

            handlers.splice(i, 1);
          }
        }
      }
      ```
      **EventTarget**类型有一个单独的属性handlers，用于储存事件处理程序。还有三个方法：addHander()：
      用于注册给定类型的事件，fire()：是用于触发一个事件，removeHandler()：用于注销某个事件类型的事件。

      **addHandler()** 方法接受两个参数：事件类型和用于处理该事件的函数。当调用该方法时，会进行一次检
      查，看看handlers属性中是否已经存在一个针对该事件类型的数组；如果没有，则创建一个新的。然后使用
      push()将该处理程序添加到数组末尾。

      如果要触发一个事件，要调用**fire()** 函数。该方法接受一个单独的参数，是一个至少包含type属性的对
      象。fire()方法先给event对象设置一个target属性，如果它尚未被指定的话。然后它就查找对应该事件类型
      的一组处理程序，调用各个函数，并给出event对象。因为这些都是自定义事件，所以event对象上需要的额外
      信息由你自己确定。

      **removeHandler()** 方法是addHandler()的辅助，接受的参数一样，这个方法搜索事件处理程序的数组
      找到要删除的处理程序的位置。如果找到了，则使用break退出for循环。然后用splice()方法将该项目从
      数组中删除。

      使用EventTarget类型的自定义事件如下使用：
      ```js
      function handleMessage(event) {
        console.log("Message received：" + event.message);
      }

      // 创建一个新对象
      var target = new EventTarget();

      // 添加一个事件
      target.addHander("message", handleMessage);

      // 执行一个事件
      target.fire({type: "message", message: "hello world！"});

      // 删除事件
      target.removeHandler("message", handleMessage);

      // 即使再次执行，也没有响应
      target.fire({type: "message", message: "hello world！"});
      ```
      在这段代码中，定义了handleMessage()函数用于处理message事件。它接受event对象并输出message属性。
      调用target对象的addHandler()方法并传给"message"以及handleMessage()函数。在接下来的一行上，调
      用了fire()函数，并传递了包含2个属性，即type和message的对象直接量。它会调用message事件的事件处理
      程序，这样就会在控制台打印了来自handleMessage()里打印的一段文字。然后删除了事件。这样即使事件再
      次触发，也没有看到控制台的任何响应。

      这种功能是封装在一种自定义类型中的，其他对象可以继承EventTarget并获得这个行为，如下所示：
      ```js
      function object(o) {
        function F() { };
        F.prototype = o;
        return new F();
      }

      function inheritPrototype(subType, superType) {
        var prototype = object(superType.prototype);
        prototype.constructor = subType;
        subType.prototype = prototype;
      };

      function Person(name, age) {
        EventTarget.call(this);
        this.name = name;
        this.age = age;
      };

      inheritPrototype(Person, EventTarget);

      Person.prototype.say = function(message) {
        this.fire({type: "message", message: message});
      }
      ```
      Person类型使用了寄生组合继承方法继承EventTarget。一旦调用say()方法，就会触发事件，它包含了消息
      的细节。在某类型的另外的方法中调用fire()方法是很常见的，同时它通常不是公开调用的，请看下面的使用：
      ```js
      function handleMessage(event) {
        console.log(event.target.name + "says：" + event.message);
      }

      // 创建新的对象
      var person = new Person("xiaoli", 19);

      // 添加一个事件
      person.addHander("message", handleMessage);

      // 在该对象上调用1个方法，并触发消息事件
      person.say("hello world");
      ```
      这个例子中的handleMessage()函数在控制台打印显示了某人姓名（通过event.target.name获得的）的一个
      消息正文。当调用say()方法并传递一个消息时，就会触发message事件。接着，它又会调用handleMessage()函数
      并在控制台打印出消息的正文。

      当代码中存在多个部分在特定时刻交互的情况下，自定义事件就非常有用了，这是，如果每个对象都有其他所有对象
      的引用，那整个代码就会紧密耦合，同时维护也变得困难，因为对某个对象的修改也会影响到其他对象。使用自定义
      事件有助于解耦相关对象，保持功能的隔绝。很多情况中，触发事件的代码和监听事件的代码是完全分离的。
    **/
    function EventTarget() {
      this.handlers = {};
    }

    EventTarget.prototype = {
      constructor:EventTarget,
      addHander: function(type, handler) {
        if (typeof this.handlers[type] == "undefined") {
          this.handlers[type] = [];
        }

        this.handlers[type].push(handler);
        console.log(this.handlers);
      },

      fire: function(event) {
        if (!event.target) {
          event.target = this;
        }
        if (this.handlers[event.type] instanceof Array) {
          var handlers = this.handlers[event.type];

          for (var i = 0, len = handlers.length; i < len; i ++) {
            handlers[i](event);
          }
        }
      },

      removeHandler: function(type, handler) {
        if (this.handlers[type] instanceof Array) {
          var handlers = this.handlers[type];

          for (var i = 0, len = handlers.length; i < len; i++) {
            if (handlers[i] === handler) {
              break;
            }
          }

          handlers.splice(i, 1);
        }
      }
    }

    function object(o) {
      function F() { };
      F.prototype = o;
      return new F();
    }

    function inheritPrototype(subType, superType) {
      var prototype = object(superType.prototype);
      prototype.constructor = subType;
      subType.prototype = prototype;
    };

    function Person(name, age) {
      EventTarget.call(this);
      this.name = name;
      this.age = age;
    };

    inheritPrototype(Person, EventTarget);

    Person.prototype.say = function(message) {
      this.fire({type: "message", message: message});
    }

    function handleMessage(event) {
      console.log(event.target.name + "says：" + event.message);
    }

    var person = new Person("xiaoli", 19);

    person.addHander("message", handleMessage);

    person.say("hello world");
  </script>
</body>
</html>