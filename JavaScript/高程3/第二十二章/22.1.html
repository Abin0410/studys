<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <button id="my-btn">click me</button>
  <script>
    /**
      # 高级技巧

      ## 高级函数

      函数是JavaScript中最有趣的部分之一。它们本质上是十分简单和过程化的，但也可以是非常复杂
      和动态的。一些额外的功能可以通过使用闭包来实现。

      ### 安全的类型检测

      在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]
      格式的字符串。每个类的内部都有一个[[Class]]属性，这个属性中就指定了上述字符串的构造函数
      名。举个例子：
      ```js
      var arr = [];
      var txt = "xiaohong";

      console.log(Object.prototype.toString.call(arr)); // [object Array]
      console.log(Object.prototype.toString.call(txt)); // [object String]
      ```

      由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。利用
      这一点，可以创建如下函数：
      ```js
      function isArray(value) {
        return Object.prototype.toString.call(value);
      }
      ```
      同样的，也可以基于这一思路来测试某个值是不是原生函数或正则表达式：
      ```js
      function isFunction(value) {
        return Object.prototype.toString.call(value) == "[object Function]";
      }

      function isRegExp(value) {
        return Object.prototype.toString.call(value) == "[object RegExp]";
      }
      ```
      这一技巧也广泛应用于检测原生JSON对象，Object的toString()方法不能检测非原生构造函数的
      构造函数名。因此，开发人员定义的任何构造函数都将返回[object Object]。
      :::warning 警告
      请注意，Object.prototype.toString()本身也可能会被修改。
      :::

      ### 作用域安全的构造函数

      构造函数其实就是一个使用new操作符调用的函数。当使用new调用时，构造函数内用到的this对象
      会指向新创建的对象实例，如下面的例子所示：
      ```js
      function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
      }

      var person = new Person("xiaohong", 19, "Front end Engineer");
      ```
      上面这个例子中，Person构造函数使用this对象给三个属性赋值：name、age和job。当和new操作
      符连用时，则会创建一个新的Person对象，同时会给它分配这些属性。问题出在当没有使用new操作
      符来调用该构造函数的情况上。由于该this对象是在运行时绑定的，所以直接调用Person()，this
      会映射到全局对象window上，导致错误对象属性的意外增加。例如：
      ```js
      var person = Person("xiaohong", 22, "Front end Engineer");

      console.log(window.name); // xiaohong
      console.log(window.age); // 22
      console.log(window.job); // Front end Engineer
      ```
      这里，原本针对Person实例的三个属性被加到window对象上，因为构造函数是作为普通函数调用的，
      忽略了new操作符。这个问题是由于this对象的晚绑定造成的，在这里this被解析成了window对象。
      由于window的name属性是用于标识链接目标的frame的，所以这里对该属性的偶然覆盖可能会导致
      该页面上出现其他错误。这个问题的解决方法就是创建一个作用域安全的构造函数。

      作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是，那么
      会创建新的实例并返回。看下面的例子：
      ```js
      function Person(name, age, job) {
        if (this instanceof Person) {
          this.name = name;
          this.age = age;
          this.job = job;
        } else {
          return new Person(name, age, job);
        }
      }

      var person1 = Person("xiaohong", 22, "Front end Engineer");
      console.log(window.name); // ""
      console.log(person1.name); // "xiaohong"

      var person2 = new Person("xiaoming", 23, "Back end Engineer");
      console.log(person2.name); // "xiaoming"
      ```
      这段代码中的Person构造函数添加了一个检查并确保this对象是Person实例的if语句，它表示要么
      使用new操作符，要么在现有的Person实例环境中调用构造函数。任何一种情况下，对象初始化都能
      正常进行。如果this并非Person的实例，那么会再次使用new操作符调用构造函数并返回结果。最后
      的结果是，调用Person构造函数时无论是否使用new操作符，都会返回一个Person的新实例，这就避
      免了在全局对象上意外设置属性。

      关于作用域安全的构造函数的贴心提示。实现这个模式后，你就锁定了可以调用构造函数的环境。如
      果你使用构造函数窃取模式的继承且不使用原型链，那么这个继承很可能被破坏。看个例子：
      ```js
      function Polygon(sides) {
        if (this instanceof Polygon) {
          this.sides = sides;
          this.getArea = function() {
            return 0;
          }
        } else {
          return new Polygon(sides);
        }
      };

      function Rectangle(width, height) {
        Polygon.call(this, 2);
        this.width = width;
        this.height = height;
        this.getArea = function() {
          return this.width * this.height;
        };
      }

      var rect = new Rectangle(5, 10);
      console.log(rect.sides); // undefined
      ```
      在这段代码中。Polygon构造函数是作用域安全的，然而Rectangle构造函数则不是。新创建一个Rectangle
      实例之后，这个实例应该通过Polygon.call()来继承Polygon的sides属性。但是，由于Polygon构造函数
      是作用域安全的，this对象并非Polygon的实例，所以会创建并返回一个新的Polygon对象。Rectangle构造
      函数中的this对象并没有得到增长，同时Polygon.call()返回的值也没有用到，所以Rectangle实例中就
      不会有sides属性。

      如果构造函数窃取结合使用原型链或者寄生组合则可以解决这个问题。考虑以下例子：
      ```js
      function Polygon(sides) {
        if (this instanceof Polygon) {
          this.sides = sides;
          this.getArea = function() {
            return 0;
          }
        } else {
          return new Polygon(sides);
        }
      };

      function Rectangle(width, height) {
        Polygon.call(this, 2);
        this.width = width;
        this.height = height;
        this.getArea = function() {
          return this.width * this.height;
        };
      }

      Rectangle.prototype = new Polygon();


      var rect = new Rectangle(5, 10);
      console.log(rect.sides); // 2
      ```
      上面这段重写的代码中，一个Rectangle实例也同时是一个Polygon实例，所以Polygon.call()
      会照原意执行，最终为Rectangle实例添加了sides属性。

      ### 惰性载入函数

      因为浏览器之间行为的差异，多数JavaScript代码包含了大量的if语句，将执行引导到正确的代码中。
      看一个简单的例子：
      ```js
      function createXHR() {
        if (typeof XMLHttpRequest != undefined) {
          return new XMLHttpRequest();
        } else if (typeof arguments.callee.activeXString != "string") {
          var versions = ["MSXML2.XMLHttp.6.0"] // ......
        } else {
          throw new Error ("No XHR object available.");
        }
      }
      ```
      每次调用createXHR()的时候，它都要对浏览器所支持的能力仔细检查。每次调用该函数都是这样，即
      使每次调用时分支的结果都不变：如果浏览器支持内置XHR，那么它就一直支持了，那么这种测试就变得
      没必要了。即使只有一个if语句的代码，也肯定比没有if语句的慢，所以如果if语句不必要每次执行，那
      么代码可以运行地更快一些。解决方案就是称之为惰性载入的技巧。

      惰性载入表示函数执行的分支仅会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调用时再
      处理函数。在第一次调用的过程中，该函数会覆盖为另外一个按合适方式执行的函数，这样任何对原函数
      的调用都不用再经过执行的分支了。例如，可以用下面的方式使用惰性载入重写createXHR()。
      ```js
      function createXHR() {
        if (typeof XMLHttpRequest != undefined) {
          createXHR = function() {
            return new XMLHttpRequest();
          }
        } else if (typeof arguments.callee.activeXString != "string") {
          createXHR = function() {
            var versions = ["MSXML2.XMLHttp.6.0"];
            // ......
          }
        } else {
          createXHR = function() {
            throw new Error("No XHR object available.");
          }
        }
      }
      ```
      这个惰性载入的createXHR()中，if语句的每一个分支都会为createXHR变量赋值，有效覆盖了原有的函
      数。最后一步便是调用新赋的函数。下一次调用createXHR()的时候，就会直接调用被分配的函数，这样
      就不用再次执行if语句了。

      第二种实现惰性载入的方式是在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损失性能
      了，而在代码首页加载时会损失一点性能。以下就是按照这一思路重写前面例子的结果。
      ```js
      var createXHR = (function() {
        if (typeof XMLHttpRequest != undefined) {
          return function() {
            return new XMLHttpRequest();
          }
        } else if (typeof arguments.callee.activeXString != "string") {
          return function() {
            var versions = ["MSXML2.XMLHttp.6.0"];
            // ......
          }
        } else {
          return function() {
            throw new Error("No XHR object available.");
          }
        }
      })();
      ```
      这个例子中使用的技巧是创建一个匿名、自执行的函数，用以确定应该使用哪一个函数实现。实际的逻辑
      都一样。不一样的地方就是第一行代码（使用var定义函数）、新增了自执行的匿名函数，另外每个分支都
      返回正确的函数定义，以便立即将其赋值给createXHR()。

      惰性载入函数的优点是只在执行分支代码时牺牲一点儿性能。至于哪种方式更合适，就要看具体的需求而定了。

      ### 函数绑定

      函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与
      事件一起使用。以便在将函数作为变量传递的同时保留代码的执行环境。看下面的例子：
      ```js
      var handler = {
        message: "Event handled",
        handleClick: function(event) {
          alert(this.message);
        }
      };

      var btn = document.getElementById("my-btn");
      btn.addEventListener('click', handler.handleClick, false);
      ```
      在上面的例子中，当按下该按钮时，就调用该函数，显示一个警告框，警告框应该显示Event handled，
      结果显示的是undefined。这个问题在于没有保存handler.handleClick()的环境，所以this对象最后
      是指向了DOM按钮而非handler，我们可以使用一个闭包来修正这个问题。
      ```js
      var handler = {
        message: "Event handled",
        handleClick: function(event) {
          alert(this.message);
        }
      };

      var btn = document.getElementById("my-btn");
      btn.addEventListener('click', function(e) {
        handler.handleClick(e);
      }, false);
      ```
      这个解决方案在onclick事件内使用了一个闭包直接调用handler.handleClick()。当然，这是特定于
      这段代码的解决方案。创建多个闭包可能会令代码变得难于理解和调试。因此，很多JavaScript库实现
      了一个可以将函数绑定到指定环境的函数。这个函数叫bind()。

      一个简单的bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且
      将所有参数原封不动传递过去。如下：
      ```js
      function bind(fn, context) {
        return function() {
          return fn.apply(context, arguments);
        }
      }
      ```
      这个函数看起来简单，但其功能是非常强大的，在bind()中创建了一个闭包，闭包使用apply()调用传
      入的函数，并给apply()传递context对象和参数。这里使用的arguments对象是内部函数的，而非bind()的。
      当调用返回函数时，它会给定环境中执行被传入的函数并给出所有参数。bind()函数按如下方式使用：
      ```js
      function bind(fn, context) {
        return function () {
          return fn.apply(context, arguments);
        }
      }

      handler = {
        message: "hello world",
        handleClick: function(e) {
          alert(this.message);
        }
      }

      var btn = document.getElementById("my-btn");
      btn.addEventListener("click", bind(handler.handleClick, handler));
      ```
      在这个例子中，我们用bind()函数创建了一个保持了执行环境的函数，并将其传给addEventListener()。
      event对象也被传给了该函数，如下所示：
      ```js
      function bind(fn, context) {
        return function () {
          return fn.apply(context, arguments);
        }
      }

      handler = {
        message: "hello world",
        handleClick: function(e) {
          alert(this.message + ":" + e.type);
        }
      }

      var btn = document.getElementById("my-btn");
      btn.addEventListener("click", bind(handler.handleClick, handler));
      ```
      handler.handleClick()方法和平时一样获得了event对象，因为所有的参数都通过被绑定的函数
      直接传给了它。

      但是有一种更简单的方法，使用ECMAScript5的原生bind()方法，你不用再自己定义bind()函数了，而是
      可以直接在函数上调用这个方法。例如：
      ```js
      var handler = {
        message: "hello world",
        handleClick: function(e) {
          alert(this.message + ":" + e.type);
        }
      };

      var btn = document.getElementById("my-btn");
      btn.addEventListener("click", handler.handleClick.bind(handler), false);
      ```
      只要是将某个函数指针以值的形式进行传递，同时该函数必须在特定环境中执行，被绑定函数的效用就突
      显出来了。它们主要用于事件以及定时器。被绑定函数与普通函数相比有更多开销，它们需要更多内存，同
      时也因为多重函数调用稍微慢一点，所以最好只在必要时使用。

      ### 函数柯里化

      与函数绑定紧密相关的是**函数柯里化**，它用于创建已经设置好了一个或多个参数的函数。函数柯里
      化的基本方法和函数绑定是一样的；使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，
      返回的函数还需要设置一些传入的参数。看以下例子：
      ```js
      function add(num1, num2) {
        return num1 + num2;
      }

      function curriedAdd(num2) {
        return add(5, num2);
      }

      console.log(add(2, 3)); // 5
      console.log(curriedAdd(3)); // 8
      ```
      这段代码定义了两个函数：add()和curriedAdd()。后者本质上是在任何情况下第一个参数为5的add()
      版本。尽管从技术上来说curriedAdd()并非柯里化的函数，但它很好地展示了其概念。

      柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。下面是创
      建柯里化函数的通用方式。
      ```js
      function curry(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          var innerArgs = Array.prototype.slice.call(arguments);
          var finalArgs = args.concat(innerArgs);
          return fn.apply(null, finalArgs);
        }
      }
      ```
      curry()函数的主要工作就是将被返回函数的参数进行排序。curry()的第一个参数是要进行柯里化的函
      数，其他参数是要传入的值。为了获取第一个参数之后的所有参数，在arguments对象上调用了slice()
      方法，并传入参数1表示被返回的数组包含从第二个参数开始的所有参数。然后args数组包含了来自外部
      函数的参数。在内部函数中，创建了innerArgs数组用来存放所有传入的参数（又一次用到了slice()）。
      有了存放来自外部函数和内部函数的参数数组后，就可以使用concat()方法将它们组合为finalArgs，然
      后使用apply()将结果传递给该函数。注意这个函数并没有考虑到执行环境，所以调用apply()时第一个
      参数是null。curry()函数可以按以下方式应用。
      ```js
      function add(num1, num2) {
        return num1 + num2;
      }

      var curriedAdd = curry(add, 5);
      console.log(curriedAdd(3)); // 8
      ```
      在这个例子中，创建了第一个参数绑定为5的add()的柯里化版本。当调用curriedAdd()并传入3时，3
      会成为add()的第二个参数，同时第一个参数依然是5，最后结果便是和8。也可以像下面例子这样给出
      所有的函数参数：
      ```js
      function add(num1, num2) {
        return num1 + num2;
      }

      var curriedAdd = curry(add, 5, 12);
      console.log(curriedAdd()); // 17
      ```

      函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数。例如：
      ```js
      function bind(fn, context) {
        var args = Array.prototype.slice.call(arguments, 2);
        return function() {
          var innerArgs = Array.prototype.slice.call(arguments);
          var finalArgs = args.concat(innerArgs);
          return fn.apply(context, finalArgs);
        };
      }
      ```
      对curry()函数的主要更改在于传入的参数个数，以及它如何影响代码的结果。curry()仅仅接受一个
      要包裹的函数作为参数，而bind()同时接受函数和一个object对象。这表示给被绑定的函数的参数是
      从第三个开始而不是第二个，这就要更改slice()的第一处调用。另一处更改是在倒数第3行将object
      对象传给apply()。当使用bind()时，它会返回绑定到给定环境的函数，并且可能它其中某些函数参数
      已经被设好。当你想除了event对象再额外给事件传递参数时，这非常有用，例如：
      ```js
      var handler = {
        message: "hello world",
        handleClick: function(name, e) {
          console.log(this.message + ":" + name + ":" + e.type);
        }
      }

      var btn = document.getElementById("my-btn");
      btn.addEventListener("click", bind(handler.handleClick, handler, "my-btn"));
      ```
      在这个更新过的例子中，handler.handleClick()方法接受了两个参数：要处理的元素的名字和e对象。
      作为第三个参数传递给bind()函数的名字，又被传递给了handler.handleClick()，而handler.handleClick()
      也会同时接收到e对象。

      用ECMAScript5中的bind()方法也能实现函数柯里化，只要在this的值之后再传入另一个参数即可。
      ```js
      var handler = {
        message: "hello world",
        handleClick: function(name, e) {
          console.log(this.message + ":" + name + ":" + e.type);
        }
      }

      var btn = document.getElementById("my-btn");
      btn.addEventListener("click", handler.handleClick.bind(handler, "my-btn"));
      ```
      JavaScript中的柯里化函数和绑定函数提供了强大的动态函数创建功能。使用bind()还是curry()要
      根据是否需要object对象响应来决定。它们都能用于创建复杂的算法和功能，当然两者都不应滥用，因
      为每个函数都会带来额外的开销。
    **/
  </script>
</body>
</html>