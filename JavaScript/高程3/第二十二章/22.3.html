<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <!-- <div id="myDiv" style="background: #ccc;"></div> -->
  <button id="debounce">点我防抖！</button>
  <script>
    /**
      ## 高级定时器

      ### 函数防抖
      浏览器中某些计算和处理要比其他的昂贵很多。例如，DOM操作比起非DOM交互需要更多的内存和
      CPU时间。连续尝试进行过多的DOM相关操作可能会导致浏览器挂了，有时候甚至会崩溃。尤其是
      使用 **onresize** 事件的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。在
      **onresize** 事件内部如果尝试进行DOM操作。其高频率的更改可能会让浏览器崩溃。为了解决
      这一问题，可以使用定时器对该函数进行 **防抖**。

      :::warning 警告
      在JavaScript高级程序设计3里面为函数节流，实际上是函数防抖。
      :::

      函数防抖背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，
      创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定
      时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一
      个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有执行函数的请求停止了一段
      时间之后才执行。以下是该模式的基本形式：
      ```js
      var processor = {
        timeoutId: null,

        // 实际进行处理的方法
        performProcessing: function() {
          // 实际执行的代码
          console.log("performProcessing");
        },

        // 初始处理调用的方法
        process: function() {
          clearTimeout(this.timeoutId);

          var that = this;
          this.timeoutId = setTimeout(function (){
            that.performProcessing();
          }, 100);
        }
      };

      // 尝试进行
      processor.process();
      ```
      这段代码中，创建了一个叫做processor对象。这个对象还有两个方法：process()和performProcessing()。
      前者是初始化任何处理所必须调用的，后者则实际进行应完成的处理。当调用了process()，第一步清除存好的
      timeoutId，来阻止之前的调用被执行。然后，创建一个新的定时器调用performProcessing()。由于setTimeout()
      中用到的函数的环境总是window，所以有必要保存this的引用以方便以后使用。

      时间间隔设为了100ms，这表示最后一个调用process()之后至少100ms后才会调用performProcessing()。
      所以如果100ms之内调用了process()共20次，performProcessing()仍只会被调用一次。

      这个模式可以使用debounce()函数来简化，这个函数可以自动进行定时器的设置和清除，如下所示：
      ```js
      function debounce(method, context) {
        clearTimeout(method.tId);
        method.tId = setTimeout(function() {
          method.call(context);
        }, 100);
      }
      ```
      **debounce()** 函数接收两个参数：要执行的函数以及在哪个作用域中执行。上面这个函数首先清除之前设
      置的任何定时器。定时器ID是存储在函数的tId属性中的，第一次把方法传递给debounce()的时候，这个属性
      可能并不存在。接下来，创建一个新的定时器，并将其ID储存在方法的tId属性中。如果这是第一次对这个方法
      调用debounce()的话，那么这段代码会创建该属性。定时器代码使用call()来确保方法在适当的环境中执行。
      如果没有给第二个参数，那么就在全局作用域内执行该方法。

      前面提到过，防抖在resize事件中是最常用的。如果你基于该事件来改变页面布局的话，最好控制处理的频率，
      以确保浏览器不会在极短的时间内进行过多的计算。例如，假设有一个`<div>`元素需要保持它的高度始终等
      同于宽度。那么实现这一功能的代码如下编写：
      ```js
      function debounce(method, context) {
        clearTimeout(method.tId);
        method.tId = setTimeout(function() {
          method.call(context);
        }, 100);
      }

      function resizeDiv() {
        var div = document.getElementById("myDiv");
        div.style.height = div.offsetWidth + "px";
      }

      window.onresize = function() {
        debounce(resizeDiv);
      }
      ```
      这里，调整大小的功能被放入了一个叫做 **resizeDiv()** 的单独函数中。然后onresize事件调用
      debounce()并传入 **resizeDiv**函数，而不是直接调用resizeDiv()。多数情况下，用户是感觉不
      到变化的，虽然给浏览器节省的计算可能会非常大。

      只要代码是周期性执行的。都应该使用防抖，但是你不能控制请求执行的速率。这里展示 **debounce()** 
      函数用了100ms作为间隔，当然可以根据自己的需要来修改它。

      下面的代码是通过模拟用户在频繁点击按钮，使用函数防抖进行性能优化的例子。
      ```js
      window.onload = function() {
        // 通过id获取按钮，并绑定一个click事件
        var myBtn = document.getElementById("debounce");
        myBtn.addEventListener("click", debounce(myDebounce));
      }

      // 这里的防抖功能函数，接受一个函数作为参数
      function debounce(fn) {
        // 声明一个变量用来存定时器的返回值
        let time = null;

        return function() {
          // 首先把前一个定时器先清除
          clearTimeout(time);

          // 设置一个新的定时器，用户如果还点击的话，重新设置定时器
          time = setTimeout(function() {
            fn.call(this, arguments);
          }, 1000);
        };
      }

      // 需要进行函数防抖的函数
      function myDebounce() {
        // 这里是需要做防抖的操作。
        console.log("hello debounce！");
      }
      ```

      ### 函数节流
      关于函数节流的代码实现有很多，下面的throttle函数的原理是，将即将被执行的函数用setTimeout延迟一段
      时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。throttle函数接受2个参数，第一个
      是要被延迟的函数，第二个参数是延迟执行的时间。
      ```js
      window.onload = function() {
        // 通过id获取按钮，并绑定一个click事件
        var myBtn = document.getElementById("throttle");
        myBtn.addEventListener("click", throttle(function() {
          console.log("hello throttle！");
        }, 1000));
      }

      function throttle(fn, interval) {
        var _self = fn,  // 保存需要延迟执行的函数
            timer, // 保存定时器的返回值
            firstTime = true; // 是否是第一次调用的值

        return function() {
          var args = arguments; // 这里的arguments其实就是event
          var that = this; // 这里的this直接指向button

          if (!firstTime) { // 如果是第一次调用，不需要延迟执行
            _self.apply(that, args);
            return firstTime = false;
          }

          // 如果定时器还在的话，就说明前一次还没有执行完，所以直接返回false，不往下执行
          // 也就是说timer一开始是为undefined的，如果timer有值的话，就说明定时器还在。
          if (timer) {
            return false;
          }

          timer = setTimeout(function() { // 延迟一段时间执行
            clearTimeout(timer);
            timer = null;
            _self.apply(that, args);
          }, interval || 500);
        }
      }
      ```
      下面这个函数节流是结合了时间戳的版本。接收三个参数：一个为需要节流的函数，第二个为设定时间间隔，
      第三个是执行间隔时长。
      ```js
      function throttle(fn, wait, time) {
        var previous = null; // 设置上一次的时间
        var timer = null; // 设置定时器的返回值

        return function() {
          // 获取当前时间戳
          var now = + new Date();

          if (!previous) {
            previous = now
          }

          // 如果当前时间减去上次的时间大于设置的执行时间间隔的话就执行一次
          if (now - previous > time) {
            clearTimeout(timer);
            fn.apply(this, arguments);
            previous = now;
          } else {
            clearTimeout(timer);
            timer = setTimeout(function() {
              fn.apply(this, arguments);
            }, wait);
          }
        }
      }
      ```
    **/

    window.onload = function() {
      // 通过id获取按钮，并绑定一个click事件
      var myBtn = document.getElementById("debounce");
      myBtn.addEventListener("click", throttle(function() {
        console.log("hello throttle！");
      }, 500, 2000));
    }

    // function throttle(fn, interval) {
    //   var _self = fn,  // 保存需要延迟执行的函数
    //       timer, // 保存定时器的返回值
    //       firstTime = true; // 是否是第一次调用的值

    //   return function() {
    //     var args = arguments; // 这里的arguments其实就是event
    //     var that = this; // 这里的this直接指向button

    //     if (!firstTime) { // 如果是第一次调用，不需要延迟执行
    //       _self.apply(that, args);
    //       return firstTime = false;
    //     }

    //     // 如果定时器还在的话，就说明前一次还没有执行完，所以直接返回false，不往下执行
    //     // 也就是说timer一开始是为undefined的，如果timer有值的话，就说明定时器还在。
    //     if (timer) {
    //       return false;
    //     }

    //     timer = setTimeout(function() { // 延迟一段时间执行
    //       clearTimeout(timer);
    //       timer = null;
    //       _self.apply(that, args);
    //     }, interval || 500);
    //   }
    // }

    function throttle(fn, wait, time) {
      var previous = null; // 设置上一次的时间
      var timer = null; // 设置定时器的返回值

      return function() {
        // 获取当前时间戳
        var now = + new Date();

        if (!previous) {
          previous = now
        }
        
        // 如果当前时间减去上次的时间大于设置的执行时间间隔的话就执行一次
        if (now - previous > time) {
          clearTimeout(timer);
          fn.apply(this, arguments);
          previous = now;
        } else {
          console.log("进入false");
          clearTimeout(timer);
          timer = setTimeout(function() {
            fn.apply(this, arguments);
          }, wait);
        }
      }
    }
  </script>
</body>
</html>