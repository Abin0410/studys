<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>WebGL</title>
</head>
<body>
  <canvas id="drawing" width="200" height="200"></canvas>
  <script>
    /**
      # WebGL
      WebGL是针对Canvas的3D上下文。

      ## 类型化数组
      类型化数组的核心就是一个名为 **ArrayBuffer** 的类型。每个 **ArrayBuffer** 对象表示的只是
      内存中指定的字节数，但不会指定这些字节用于保存什么类型数据。通过 **ArrayBuffer** 所能做的，
      就是为了将来使用而分配一定数量的字节。
      ```js
      var buffer = new ArrayBuffer(20); // 分配20B的内存
      ```
      **byteLength** 属性可以访问 **ArrayBuffer** 的字节数。
      ```js
      var bytes = buffer.byteLength;
      console.log(bytes);
      ```
      #### 视图
      使用 **ArrayBuffer** 来创建数组缓冲器视图。其中，最常见的视图是DataView，通过它可以选择
      **ArrayBuffer** 中一小段字节。可以在创建DataView实例的时候传入一个 **ArrayBuffer** 、
      一个可选的字节偏移量（从该字节开始选择）和一个可选的要选择的字节数。例如：
      ```js
      // 基于整个缓冲器创建一个新视图
      var view = new DataView(buffer);

      // 创建一个开始于字节9的新视图
      var view = new DataView(buffer, 9);

      // 创建一个从字节9开始到字节18的新视图
      var view = new DataView(buffer, 9, 10);
      ```
      DataView对象会把字节偏移量以及字节长度信息分别保存在 **byteOffset** 和 **byteLength**属性中。
      ```js
      var view = new DataView(buffer);

      console.log(view.byteOffset);
      console.log(view.byteLength);
      ```
      另外，通过buffer属性也可以取得数组缓冲器。

      读取和写入DataView的时候，要根据实际操作的数据类型，选择相应的getter和setter方法。下面列出了
      DataView支持的数据类型以及相应的读写方法。
      |数据类型|getter|setter|
      |----|----|----|
      |有符号8位整数|getInt8(byteOffset)|setInt8(byteOffset, value)|
      |无符号8位整数|getUint8(byteOffset)|setUint8(byteOffset, value)|
      |有符号16位整数|getInt16(byteOffset, littleEndian)|setInt8(byteOffset, value, littleEndian)|
      |无符号16位整数|getUint16(byteOffset, littleEndian)|setUint16(byteOffset, value, littleEndian)|
      |有符号32整数|getInt32(byteOffset, littleEndian)|setInt32(byteOffset, value, littleEndian)|
      |无符号32位整数|getUint32(byteOffset, littleEndian)|setUint32(byteOffset, value, littleEndian)|
      |32位浮点数|getFloat32(byteOffset, littleEndian)|setFloat32(byteOffset, value, littleEndian)|
      |64位浮点数|getFloat64(byteOffset, littleEndian)|setFloat64(byteOffset, value, littleEndian)|
      
      #### 类型化视图
      类型化视图也分几种，而且他们都继承了DataView。
      * Int8Array：表示8位二补整数。
      * Uint8Array：表示8位无符号整数。
      * Int16Array：表示16位二补整数。
      * Uint16Array：表示16位无符号整数。
      * Int32Array：表示32位二补整数。
      * Uint32Array：表示32位无无符号整数、
      * Float32Array：表示32位IEEE浮点值。
      * Float64Array：表示64位IEEE浮点值。
      这些视图都是继承自DataView，因而可以使用相同的构造函数参数来实例化。第一个参数是要使用 **ArrayBuffer** 
      对象，第二个参数是作为起点的字节偏移量（默认为0），第三个参数是要包含的字节。三个参数中只有第一个必需的
      来看几个例子：
      ```js
      // 创建一个新数组，使用整个缓冲器
      var int8s = new Int8Array(buffer);

      // 只使用从字节9开始的缓冲器
      var int16s = new Int16Array(buffer, 9);

      // 只使用从字节9到字节18的缓冲器
      var uint16s = new Uint16Array(buffer, 9, 10);
      ```


      ## WebGL上下文
      WebGL的名字叫 **"experimental-wegl"** ，一般把WebGL上下文对象命名为gl。
      ```js
      var drawing = document.getElementById("drawing");

      if (drawing.getContext) {
        var gl = drawing.getContext("experimental-webgl");
        if (gl) {
          // 使用WebGl
        }
      }
      ```

      取得了WebGL上下文之后，就可以开始3D绘图了。通过给getContext()传递第二个参数，可以为WebGL上下文
      设置一些选项。这个参数本身是一个对象，可以包含下列属性。
      * alpha：值为true，表示为上下文创建一个Alpha通道缓冲区，默认值为true。
      * depth：值为true，表示可以使用16位深缓冲区；默认值为true。
      * stencil：值为true，表示可以使用8位模板缓冲区；默认值为false。
      * antialias：值为true，表示将使用默认机制执行抗锯齿操作；默认值为true。
      * premultipliedAlpha：值为true，表示绘图缓冲区有预乘Alpha值；默认值为true。
      * perserveDrawingBuffer：值为true，表示在绘图完成后保留绘图缓冲区；默认值为false。

      #### 常量
      在WebGL中，保存在上下文对象中的这些常量都没有GL_前缀。比如说，GL_COLOR_BUFFER_BITCH常量在WebGL
      上下文中就是gl.COLOR_BUFFER_BITCH。

      #### 方法命名
      方法名的后缀会包含四个参数（1到4）和接收的数据类型（f表示浮点数，i表示整数）。例如，gl.uniform4f()
      意味着要接收4个浮点数，而gl.uniform3i()则表示接收3个整数。

      #### 准备绘图
      在实际操作WebGL上下文之前，一般都要使用某种实色清除`<canvas>`，为绘图做好准备。首先必须使用
       **clearColor** 方法来指定要使用的颜色值，该方法接收4个参数：红、绿、蓝和透明度。每个参数必
      须是一个0到1之间的数值，表示每种分量在最终颜色中的强度。来看个例子:
      ```js
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BTT);
      ```
      **clerar()** 方法，传入的参数gl.COLOR_BUFFER_BTT告诉WebGL使用之前定义的颜色来填充相应去域。

      #### 视口与坐标
      视口可以使用整个`<canvas>`区域。要改变视口大小，可以调用 **viewport()** 方法并传入4个参数：
      （视口相对于`<canvas>`元素的）x坐标、y坐标、宽度和高度。例如，下面的调用就使用了`<canvas>`元素：
      ```js
      var drawing = document.getElementById("drawing");

      if (drawing.getContext) {
        var gl = drawing.getContext("experimental-webgl");
        if (gl) {
          gl.viewport(0, 0, drawing.width, drawing.height);
        }
      }
      ```
      视口坐标的原点（0, 0）在`<canvas>`元素的左下角，x轴和y轴的正方向分别是向右和向上。
      ```js
      // 视口是`<canvas>`左下角的四分之一区域
      gl.viewport(0, 0, drawing.width/2, drawing.height/2);

      // 视口是`<canvas>`左上角的四分之一区域
      gl.viewport(0, drawing.height/2, drawing.width/2, drawing.height/2);

      // 视口是`<canvas>`右下角的四分之一区域
      gl.viewport(drawing.width/2, 0, drawing.width/2, drawing.height/2);
      ```

      #### 缓冲区
      要创建缓冲区，可以调用 **gl.createBuffer()** ，然后使用 **gl.bindBuffer()** 绑定到WebGL上下文。
      ```js
      var buffer = gl.createBuffer();

      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0.5, 1]), gl.STATIC_DRAW);
      ```
      **gl.bufferData()** 的最后一个参数用于指定使用缓冲区的方式，取值范围是如下几个变量。
      * gl.STATIC_DRAW：数据只加载一次，在多次绘图中使用。
      * gl.STREAM_DRAW：数据只加载一次，在几次绘图中使用。
      * gl.DYNAMIC_DRWA：数据动态改变，在多次绘图中使用。
      
      在包含缓冲区的页面重载之前，缓冲区始终保留在内存中。如果不想要某个缓冲区了，可以直接调用
       **gl.deleteBuffer()** 释放内存：
      ```js
      gl.deleteBuffer(buffer);
      ```

      #### 错误
      WebGL操作一般不会抛出错误。为了知道是否有错误发生，必须在调用某个可能出错的方法后，手动调用
       **gl.getError()** 方法。这个方法返回一个表示错误类型的常量。可能的错误常量如下：
      * gl.NO_ERROR：上一次操作没有发生错误（值为0）。
      * gl.INVALID_ENUM：应该给方法传入WebGL常量，但却传错了参数。
      * gl.INVALID_OPERATION：在当前状态下不能完成操作。
      * gl.OUT_OF_MEMORY：没有足够的内存完成操作。
      * gl.CONTEXT_LOST_WEBGL：由于外部事件（如设备断电）干扰丢失了当前WebGL上下文。
      
      ```js
      var errorCode = gl.getError();

      while(errorCode) {
        console.log("Error occurred： " + errorCode);
        errorCode = gl.getError();
      }
      ```

      #### 着色器
      WebGL中有两种着色器：顶点着色器和片段（或像素）着色器。订单着色器用于将3D顶点转换为需要渲染
      的2D点。片段着色器用于准确计算要绘制的每个像素的颜色。

      #### 编写着色器 GLSL语言
      每个着色器都有一个 **main()**方法，该方法会在绘图期间重复执行。为着色器传递数据的方式有两种：
      **Attribute** 和 **Uniform**。通过Attribute可以向顶点着色器中传入顶点信息，通过 **Uniform** 
      可以向任何着色器传入常量值。
      ```js
      // Attribute
      attribute vec2 aVertexPosition;

      void main() {
        gl_Position = vec4(aVertexPosition, 0.0, 1.0);
      }
      ```
      ```js
      uniform vec4 uColor;

      void main() {
        gl_FragColor = uColor;
      }
      ```

      #### 编写着色器程序
      通常把着色器包含在页面的`<script>`标签内，并为该标签指定一个自定义的type属性。
      ```html
      ！！！！代码在第二个<script>
      ```
      然后，可以通过text属性提取出`<script>`元素的内容：
      ```js
      var vertexGlsl = document.getElementById("vertexShader").text,
          fragmentGlsl = document.getElementById("fragmentShader").text;
      ```
      取得了GLSL字符串之后，接下来就是创建着色器对象。要创建着色器对象，调用 **gl.createShader()** 
      方法并传入要创建的着色器类型（gl.VERTEX_SHADER或gl.FRAGMENT_SHADER）。编译着色器使用
      **gl.compileShader()**。来看个例子：
      ```js
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vertexGlsl);
      gl.compileShader(vertexShader);

      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentGlsl);
      gl.compileShader(fragmentShader);
      ```
      使用下列代码，可以把这两个对象链接到着色器程序中。
      ```js
      var program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      ```
      链接完程序之后，就可以通过 **gl.useProgram()** 方法通知WebGL使用这个程序了。
      ```js
      gl.useProgram(program);
      ```

      #### 为着色器传入值
      为了给着色器传入这个值，必须先找到要接收这个值的变量。对于Uniform变量，可以使用 **gl.getUniformLocation()** ，
      这个方法返回一个对象，表示Uniform变量在内存中的位置。
      ```js
      var uColor = gl.getUniformLocation(program, "uColor");
      gl.uniform4fv(uColor, [0, 0, 0, 1]);
      ```
      要找到Attribute变量在内存中的位置，可以调用 **gl.getAttribLocation()**。
      ```js
      var aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
      gl.enableVertexAttribArray(aVertexPosition);
      gl.vertexAttribPointer(aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);
      ```

      #### 调试着色器和程序
      如果想知道着色器或程序执行中是否发生了错误，必须亲自询问WebGL上下文。

      对于着色器，可以在操作之后调用 **gl.getShaderParameter()**，取得着色器的编辑状态：
      ```js
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog(vertexShader));
      }
      ```
      如果着色器编译成功，会返回true。如果是false，说明编译期间发生了错误。

      程序也可能会执行失败，因此也有类似的方法--**gl.getProgramParmenter()**，可以用来检测执行状态。
      ```js
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.log(gl.getProgramInfoLog(program));
      }
      ```
      与 **gl.getShaderParameter()** 类似，返回true链接成功，返回false表示链接失败。

      #### 绘图
      WebGL只能绘制三种形态：点、线和三角。其他所有形态都是由这三种基本形态合成之后，再绘制到三维空间
      中的。执行绘图操作要调用 **gl.drawArrays()** 或 **gl.drawElements()** 方法，前者用于数组缓冲
      区，后者用于元素数组缓冲区。

      gl.drawArrays()或gl.drawElements()的第一个参数都是一个常量，表示要绘制的形状。可取值的常量范
      围包括以下这些：
      * **gl.POINTS**：将每个顶点当成一个点来绘制。
      * **gl.LINES**：将数组当成一系列顶点，在这些顶点间画线。每个顶点即是起点也是终点，因此数组中必
        须包含偶数个顶点才能完成绘制。
      * **gl.LINE_LOOP**：将数组当成一系列顶点，在这些顶点间画线。线条从第一个顶点到第二个顶点，再从
        第二个顶点到第三个顶点，依此类推，直至最后一个顶点。然后再从最后一个顶点到第一个顶点画一条线。
        结果就是一个形状的轮廓。
      * **gl.TRIANGLES**：将数组当成一系列顶点，在这些顶点间绘制三角形。除非明确指定，每个三角形都单
        独绘制，不与其他三角形共享顶点。
      * **gl.TRIANGLES_STRIP**：除了将前三个顶点之后的顶点当作第三个顶点与前两个顶点共同构成一个新三
        角形外，其他都与gl.TRIANGLES相同。例如，如果数组中包括A、B、C、D四个顶点，则第一个三角形连接
        ABC，而第二个三角形连接ABCD。
      * **gl.TRIANGLES_FAN**：除了将前三个顶点之后的顶点当作第三个顶点与前一个顶点及第一个顶点共同构
        成一个新三角形外，其他都与gl.TRIANGLES相同。例如，如果数组中包含A、B、C、D四个顶点，则第一个
        三角形连接ABC，而第二个三角形连接ACD。

      **gl.drawArrays()** 方法接收上面列出的常量中的一个作为第一个参数，接收数组缓冲区中的起始索引作
      为第二个参数，接收数组缓冲区中包含的顶点数（点的集合数）作为第三个参数。

      #### 纹理
      要创建一个新纹理，可以调用 **gl.createTexture()**，然后再将一副图像绑定到该纹理。

      #### 读取像素
      读取像素值的方法 **readPixels()**，即最后一参数必须是类型化数组。
    **/
    var drawing = document.getElementById("drawing");

    if (drawing.getContext) {
      var gl = drawing.getContext("experimental-webgl");
      if (gl) {
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexGlsl);
        gl.compileShader(vertexShader);

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentGlsl);
        gl.compileShader(fragmentShader);

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        var uColor = gl.getUniformLocation(program, "uColor");
        gl.uniform4fv(uColor, [0, 0, 0, 1]);

        var aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        gl.enableVertexAttribArray(aVertexPosition);
        gl.vertexAttribPointer(aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          console.log(gl.getShaderInfoLog(vertexShader));
        }

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.log(gl.getProgramInfoLog(program));
        }
      }
    }
  </script>
  <!-- <script type="x-webgl/x-vertex-shader" id="vertexShader">
  attribute vec2 aVertexPosition;

  void main() {
    gl_Position = vec4(aVertexPosition, 0.0, 1.0);
    }
  </script>
  <script type="x-webgl/x-vertex-shader" id="fragmentShader">
  uniform vec4 uColor;

  void main() {
    gl_FragColor = uColor;
    }
  </script> -->
</body>
</html>