<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>模仿块级作用域</title>
  <script>
    /**
      如前所述，JavaScript没有块级作用域的概念，这意味着在块语句中定义的变量，实际上是在包含
      函数中而非语句中创建的，来看下面的例子。

        function outputNumbers(count) {
          for (var i = 0; i<count; i++) {
            console.log(i);
          }
          console.log(i); // 计数
        }
      
      这个函数中定义了一个for循环，而变量i的初始值被设置为0。在java、c++等语言中，变量i只会
      在for循环的语句块中有定义，循环一旦结束，变量i就会销毁。可是JavaScript中，变量i是定义
      在ouputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即使像
      下面这样错误地重新声明同一个变量，也不会改变它的值。

        function outputNumbers(count) {
          for (var i = 0; i<count; i++) {
            console.log(i);
          }
          var i;
          console.log(i)
        };
      
      JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而
      不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个
      问题。
      用作块级作用域（通常称为私有作用域）的匿名函数的语法如下所示。

        (function() {

        })();
      
      以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函
      数表达式。而紧随其后的另一对圆括号会立即调用这个函数。如果有人感觉这种语法不太好理解，可
      以再看看下面这个例子。

        var count = 5;
        outputNumbers(count);

      这里初始化了变量count，将其值设置为5。当然，这里的变量是没有必要的，因为可以把值直接传给
      函数。为了让代码更简洁，我们在调用函数时用5来代替变量count，如下所示。

        outputNumbers(5);
      
      这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。再
      看下面的例子。

        var someFunction = function() {
          // 这里是块级作用域
        };
        someFunction()

      这个例子先定义了一个函数，然后立即调用了它。定义函数的方式是创建一个匿名函数，并把匿名函数
      赋值给变量someFunction。而调用函数的方式是函数名称后面添加一对圆括号，即someFunction()。
      通过前面的例子我们知道，可以使用实际的值来取代变量count，那在这里是不是可以用函数的值直接
      取代函数名呢？然后，下面的代码却会导致错误。

        function() {
          // 这里是块级作用域
        }(); // 出错！
      
      这段代码会导致语法错误，是因为JavaScript将function关键字当作一个函数声明的开始，而函数声
      明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，只要
      像下面这样给它加上圆括号即可。

        (function() {
          // 这里是块级作用域
        })();

      无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：

        function outputNumbers(count) {
          (function () {
            for (var i =0; i<count; i++) {
              console.log(i);
            }
          })();
          console.log(i); // error
        }

      在这个重写后的outputNumbers()函数中，我们在for循环外部插入了一个私有作用域。在匿名函数
      中定义的任何变量，都会在执行结束时被销毁。因此，变量i只能在循环中使用，使用后即被销毁。而
      在私有作用域中能够访问变量count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所
      有变量。

      这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一
      般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型
      应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既
      可以使用自己的变量，又不必担心搞乱全局作用域。例如：

        (function() {
          var now = new Date();
          if (now.getMonth() == 0 && now.getDate() == 1) {
            console.log("happy new year!");
          }
        })();

      把上面这段代码放到全局作用域中，可以用来确定哪一天是1月1日;如果到了这一天，就会向用户显
      示一条祝贺新年的消息。其中的变量now现在是匿名函数中的局部变量，而我们不必在全局作用域中创建它。
    */
    (function() {
      var now = new Date();
      if (now.getMonth() == 0 && now.getDate() == 1) {
        console.log("happy new year!");
      }
    })();

  </script>
</head>
<body>
  
</body>
</html>