<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>函数表达式</title>
  <script>
    /**
      函数表达式是JavaScript中的一个既强大又容易令人困惑的特征。之前介绍过，定义函数的
      方式有两种：一种是函数声明，另一种是函数表达式。函数声明的语法是这样的。
        function funciotnName(name, age) {
          // 函数体
        }

      首先是function关键字，然后是函数的名字，这就是指定函数名的方式。Firefox、Safari、Chrome
      和Opera都给函数定义了一个非标准的name属性，通过这个属性可以访问到给函数指定的名字。这个属
      性的值永远等于function关键字后面的标识符

      // 只在Firefox、Safari、Chrome和Opera有效
      function functionName() {
        console.log("hahaha");
      };
      console.log(functionName.name); // functionName

      关于函数声明，它的一个重要特征就是函数声明提升，意思是在执行代码之前会先读取函数声明。这就
      意味着可以把函数声明放在调用它的语句后面。

      sayHi();
      function sayHi() {
        alert("Hi!");
      };

      这个例子不会抛出错误，因为在代码执行之前会先读取函数声明。
      第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式。

        var functionName = function() {
          alert("hi!");
        };

      这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。这种情
      况下创建的函数叫做匿名函数，因为function关键字后面没有标识符。匿名函数的name属性是空字符串。

      函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误。

        functionName(); // error
        var functionName = function() {
          alert("hi!");
        };
      
      理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。例如，执行以下代码的结果可能会让
      人意想不到。

        // 不要这样做
        var condition = true;
        if (condition) {
          function sayHi() {
            alert("Hi");
          }
        } else {
          function sayHi() {
            alert("Yo!");
          }
        }
      
      表面上看，以上代码表示在condition为true时，使用一个sayHi()的定义；否则，就使用另一个定义。
      实际上，这在ECMAScript中属于无效语法，JavaScript引擎会尝试修正错误，将其转换为合理的状态。
      但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器返回第二个声明，忽略condition；
      Firefox、Chrome会在condition为true时返回第一个声明。因此这种使用方式很危险，不应该出现在
      你的代码中。不过，如果是使用函数表达式，那就没什么问题了。

        var sayHi;
        if (condition) {
          sayHi = function() {
            alert("Hi");
          }
        } else {
          sayHi = function() {
            alert("Yo");
          }
        };
      
      这个例子不会有什么意外，不同的函数会根据condition被赋值给sayHi。
      能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。之前写的那个
      createComparisonFunction()函数：

        function createComparisonFunction(properName) {
          return function(object1, object2) {
            var value1 = object1[properName];
            var value2 = object2[properName];
            if (value1 < value2) {
              return -1;
            } else if(value1 > value2) {
              return 1;
            } else {
              return 0;
            }
          };
        }
      createComparisFunction()就返回了一个匿名函数。返回的函数可能会被赋值给一个变量，
      或者以其他方式被调用；不过，在createComparisFunction()函数内部，它是匿名的。在
      把函数当成值来使用的情况下，都可以使用匿名函数。不过，这并不是匿名函数唯一的用途。
    */
  </script>
</head>
<body>
  
</body>
</html>