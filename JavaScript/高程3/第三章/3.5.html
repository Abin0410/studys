<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>操作符</title>
  <script>
    /**
      一元操作符
      只能操作一个值的操作符叫做一元操作符。
      递增和递减操作符，分为前置型和后置型。顾名思义，前置型应该位于要操作的变量之前，
      而后置型则应该位于要操作的变量之后。

        var age = 29;
        ++age;
        console.log(age); // 30

      在这个例子中，前置递增操作符把age的值变成了30。实际上，执行这个前置递增操作与
      执行以下操作的效果相同：

        var age = 29;
        age = age + 1;

      执行前置递减操作的方法也类似，结果会从一个数值中减去1。使用前置递减操作符，要
      把两个减号（--）放在相应变量的前面，如下所示：

        var age = 29;
        --age;
        console.log(age); // 28

      执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，
      这种情况通常被称作副效应。）看下面的例子。

        var age = 29;
        var anotherAge = --age + 2;
        console.log(age); // 28
        console.log(anotherAge); // 30

      这个例子中变量anotherAge的初始值等于变量age的值前置递减之后加2.由于先执行了减法
      操作，age的值变成了28，所以再加上2的结果就是30。
      ！由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。

      后置型递增和递减操作符的语法不变，只不过要放在变量的后面而不是前面。后置递增和递减
      与前置递增和递减一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才
      执行的。看下面的例子：

        var num1 = 2;
        var num2 = 20;
        var num3 = num1-- + num2;
        var num4 = num1 + num2;

        console.log(num3); // 22
        console.log(num4); // 21

      在这个例子中，num3等于22，num4等于21。这里在计算num3时使用了num1的原始值完成了加
      法计算，而num4则使用了递减后的值。

      所有这4个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用字符串、布尔值、浮
      点数值和对象。在应用于不同的值是，递增和递减操作符遵循下列规则。
        在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字
        符串变量变成数值变量。
        在应用一个不包括有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变成数值变量。
        在应用布尔值false时，先将其转换为再0执行加减1的操作。布尔值变量变成数值变量。
        在应用于布尔值true是，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。
        在应用于浮点数值时，执行加减1的操作。
        在应用于对象是，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述
        规则。如果结果是NaN，则调用toString()方法后再应用前述规则。对象变量变成数值变量。
      看下面的例子：
        var s1 = "2";
        var s2 = "z";
        var b = false;
        var f = 1.1;
        var o = {
          valueOf: function() {
            return -1;
          }
        };

        s1++;
        s2++;
        b++;
        f--;
        o--;

        console.log(s1); // 3
        console.log(s2); // NaN
        console.log(b); // 1
        console.log(f); // 0.10000000000000009（由于浮点数舍入错误所致）
        console.log(o); // -2

      一元加和减操作符
      一元加操作以一个加号表示，放在数值前面，对数值不会产生任何影响。看下面的例子：

        var num = 25;
        num = +num;
        console.log(num); // 25

      不过，在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个执行转换。
      换句话说，布尔值false和true将被转换为0和1，字符串只会被按照一组特殊的规则进行解析，而
      对象是线调用它们的valueOf()和toString()方法，再转换得到的值。
      下面的例子展示了对不同数据类型应用一元加操作符的结果：

        var s1 = "01";
        var s2 = "1.1";
        var s3 = "z";
        var b = false;
        var f = 1.1;
        var o = {
          valueOf: function() {
            return -1;
          }
        };

        s1 = +s1;
        s2 = +s2;
        s3 = +s3;
        b = +b;
        f = +f;
        o = +o;

        console.log(s1); // 1
        console.log(s2); // 1.1
        console.log(s3); // NaN
        console.log(b); // 0
        console.log(f); // -1.1
        console.log(o); // -1

      一元减操作符主要表示负数，例如将1转换成-1。下面的例子演示了这个简单的转换过程：

        var num = 25;
        num = -num;
        console.log(num); // -25

      在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，一元减操作遵
      循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下的例子所示：

        var s1 = "01";
        var s2 = "1.1";
        var s3 = "z";
        var b = false;
        var f = 1.1;
        var o = {
          valueOf: function() {
            return -1;
          }
        };

        s1 = -s1;
        s2 = -s2;
        s3 = -s3;
        b = -b;
        f = -f;
        o = -o;

        console.log(s1); // -1
        console.log(s2); // -1.1
        console.log(s3); // NaN
        console.log(b); // -0
        console.log(f); // -1.1
        console.log(o); // 1

      一元加和减操作符主要用于基于的算术运算，也可以像前面示例展示的一样用于转换数据类型。

      位操作符
      位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中的所有数
      值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换32
      位的整数，然后执行操作，最后再将结果转换回64位。

      对于有符号的整数，32位中的前31位用于表示整数的值。在第32位用于表示数值的符号：0表示正
      数，1表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他数值的格式。其中，正数
      以纯二进制格式存储，31位中的每一位都表示2的幂。第一位（叫做位0）2^0，第二位表示2^1，从
      此类推。没有用到的位以0填充，即忽略不计。例如，数值18的二进制表示是00000000000000000
      000000000010010，或者更简洁的10010。这是5个有效位，这5位本身就决定了实际的值（3-1图）。

      负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过一下
      三个步骤：
        1.求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码）；
        2.求二进制反码，即将0替换为1，将1替换0；
        3.得到的二进制反码加1。
      要根据这3个步骤求得-18的二进制码，首先就要求得18的二进制码，即：

        0000 0000 0000 0000 0000 0000 0001 0010

      然后，求其二进制反码，即0和1互换：

        1111 1111 1111 1111 1111 1111 1110 1101

      最后，二进制反码加1：

        1111 1111 1111 1111 1111 1111 1110 1101
                                              1
        ---------------------------------------
        1111 1111 1111 1111 1111 1111 1110 1110

      这样，就求得了-18的二进制表示，即1111 1111 1111 1111 1111 1111 1110 1110。
      要注意的是，在处理有符号整数是，是不能访问为31的。

      在以二进制字符串形式初始一个负数是，我们看到的只是这个负数绝对值的二进制码前
      面加上了一个负号。看下面的例子：

        var num = -18;
        console.log(num.toString(2)); // -10010

      要把数值-18转成二进制字符串，得到的结果是"-10010"。这说明转换过程理解了二进
      制补码并将其以更合乎逻辑的形式展示了出来。

      按位非（NOT）
      按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。

        var num1 = 25;
        var num2 = ~num1;
        console.log(num2); // -26

      这里，对25执行按位非操作，结果得到了-26。这也验证了按位非操作的本质：操作数的负值减1。

      按位与（AND）
      按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位操作就是将两个
      数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行AND操作：
      |第一个数值的位|第二个数值的位|结果|
      |----|----|----|
      |1|1|1|
      |1|0|0|
      |0|1|0|
      |0|0|0|
      简而言之，按位与操作只在两个数值的对应为都是1时才返回1，任何一位是0，结果都是0。
      下面看一个对25和3执行按位于操作的例子：

        var result = 25 & 3;
        console.log(result); // 1

      可见，对25和3执行按位与操作的结果是1。为什么呢？请看其底层操作：

        25 = 0000 0000 0000 0000 0000 0000 0001 1001
         3 = 0000 0000 0000 0000 0000 0000 0000 0011

      可以看出，25和3的二进制码对应微商只有一个位同时是1，而其他位的结果自然都是0，因此最终
      结果等于1。

      按位或（OR）
      按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。
      |第一个数值的位|第二个数值的位|结果|
      |----|----|----|
      |1|1|1|
      |1|0|1|
      |0|1|1|
      |0|0|0|
      由此可见，按位或操作在有一个位是1的情况下就返回1，而只有在两个为都是0的情况下才返回0。
      如果前面按位与的例子中对25和3执行按位或操作，则代码如下所示：

        var result = 25 | 3;
        console.log(result); // 27

      25与3按位或的结果是27：

      25 = 0000 0000 0000 0000 0000 0000 0001 1001
       3 = 0000 0000 0000 0000 0000 0000 0000 0011
      --------------------------------------------
      OR = 0000 0000 0000 0000 0000 0000 0001 1011

      这两个数值的都包含4个1，因此可以把每个1直接放到结果中。二进制码11011等于十进制27。

      按位异或（XOR）
      按位异或操作符有一个插入符号（^）表示，也有两个操作数。以下是按位异或的真值表。
      |第一个数值的位|第二个数值的位|结果|
      |----|----|----|
      |1|1|0|
      |1|0|1|
      |0|1|1|
      |0|0|0|
      按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个1时才返回1，如果
      对应的两位都是1或都是0，则返回0。
      对25和3执行按位异或操作的代码如下所示：

        var result = 25 ^ 3;
        console.log(result); // 26

      25与3按位异或的结果是26，其底层操作如下所示：

        25 = 0000 0000 0000 0000 0000 0000 0001 1001
         3 = 0000 0000 0000 0000 0000 0000 0000 0011
        ---------------------------------------------
       XOR = 0000 0000 0000 0000 0000 0000 0001 1010

      这两个数值都包含4个1，但第一位上则都是1，因此结果的第一位变成了0。而其他位上的1在
      另一个数值中都没有对应的1，可以直接放到结果中。二进制码11010等于十进制值26。

      左移
      左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。例
      如，如果将数值2（二进制码为10）向左移动5位，结果就是64，（二进制码为1000000），代
      码如下所示：

        var oldValue = 2;
        var newValue = oldValue << 5;
        console.log(newValue); // 64

      注意，在向左移动后，原数值的右侧多出了5个空位。左移操作会以0来填充这些空位，以便
      得到的结果是一个完整的32位进制数（图3-2）。

      注意，左移不会影响操作数的符号位。换句话说，如果将-2向做移动5位，结果将是-64，而非64。

      有符号的右移
      有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值右移动，但保留符号位（即
      正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2：

        var oldValue = 64;
        var newValue = oldValue >> 5;
        console.log(newValue); // 2

      同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位
      的右侧。同3-2图的原理，只不过是右移了。而此时ECMAScript会用符号位的值来填充所有空位，
      以便得到一个完整的值。

      无符号右移
      无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所有32位都向右移动。对正
      数来说，无符号右移的结果与有符号右移相同。如果将64无符号右移5位，结果仍然还是2：

        var oldValue = 64;
        var newValue = oldValue >>> 5;
        console.log(newValue); // 2

      但是对负数来说，情况就不一样了。首先，无符号右移是以0来填充空位，而不是像有符号右移那
      样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果
      就不一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数
      以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所
      示：

        var oldValue = -64;
        var newValue = oldValue >>> 5;
        console.log(newValue); // 134217726

      这里，当对-64执行无符号右移5位的操作后，得到的结果是134217726。之所以结果如此之大，是
      因为-64的二进制码为11111111111111111111111111000000，而且无符号右移操作会把这个二进
      制码当成正数的二进制码，换算成十进制就是4294967232。如果把这个值右移5位，结果就变成了
      00000111111111111111111111111110，即十进制的134217726。

      布尔操作符
      布尔操作符一共有3个：非（NOT）、与（AND）和或（OR）。

      逻辑非
      逻辑非操作符由一个感叹号（！）表示，可以应用于ECMAScript中的任何值。无论这个值是什么
      数据类型，这个操作符都返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，
      然后再对其求反，也就是说，逻辑非操作符遵循下列规则：
        如果操作数是一个对象，返回false；
        如果操作数是一个空字符串，返回true；
        如果操作数是一个非空字符串，返回false；
        如果操作数是数值0，返回true；
        如果操作数是任意非0数值（包括Infinity），返回false；
        如果操作数是null，返回true；
        如果操作数是NaN，返回true；
        如果操作数undefined，返回true；
      下面几个例子展示了应用上述规则的结果：

        console.log(!false); // true
        console.log(!"blue"); // false
        console.log(!0); // true
        console.log(!NaN); // true
        console.log(!""); // true
        console.log(!12345); // false

      逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际
      上就会模拟Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个
      布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，
      最终结果与对这个值使用Boolean()函数相同，如下面的例子所示：

        console.log(!!"blue"); // true
        console.log(!!0); // false
        console.log(!!NaN); // false
        console.log(!!""); // false
        console.log(!!12345); // true

      逻辑与
      逻辑与操作符由两个和号（&&）表示，有两个操作数，如下面的例子所示：
      |第一个数值的位|第二个数值的位|结果|
      |----|----|----|
      |true|true|true|
      |true|false|flase|
      |false|true|false|
      |false|false|false|
      逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作不是布尔值的情况
      下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：
        如果第一个操作数是对象，则返回第二个操作数；
        如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才返回该对象；
        如果两个操作数都是对象，则返回第二个操作数；
        如果第一个操作数是null，则返回null；
        如果第一个操作数是NaN，则返回NaN；
        如果第一个操作数是undefined，则返回undefined。
      逻辑与操作属于短路操作，即如果一个操作数能够决定结果，那么就不会再对第二个操作数求值。
      对于逻辑与操作而言，如果第一个操作数是false，则无论第二个操作数是什么值，结果都不再
      可能是true了。来看下面的例子：

        var found = true;
        var result = (found && someUndefinedVariable); // 这里发生错误
        console.log(result); // 这一行不会执行

      在上面的代码中，当执行逻辑与操作时会发生错误，因为变量someUndefinedVariable没有声
      明。由于变量found的值是true，所以逻辑与操作符会继续对变量someUndefinedVariable求值。
      但someUndefinedVariable未定义，因此导致错误。这说明不能在逻辑与操作中使用未定义的值。
      如果像下面这个例子一样，将found的值设置为false，就不会发生错误：

        var found = false;
        var result = (found && someUndefinedVariable);
        console.log(result); // false

      在这个例子中，无论变量someUndefinedVariable有没有定义，也永远不会对它求值，因为第一
      个操作数的值是false。而这也意味着逻辑与操作的结果必定是false，根本用不着再对&&右侧的
      操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。

      逻辑或
      逻辑或操作符由两个竖线符号（||）表示，有两个操作数，如下面的例子所示：

        var result = true || false;
      
      逻辑或的真值表如下：
      |第一个数值的位|第二个数值的位|结果|
      |----|----|----|
      |true|true|true|
      |true|false|true|
      |false|true|true|
      |false|false|false|
      与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循
      下列规则：
        如果第一个操作数是对象，则返回第一个操作数；
        如果第一个操作数的求值结果为false，则返回第二个操作数；
        如果两个操作数都是对象，则返回第一个操作数；
        如果两个操作数都是null，则返回null；
        如果两个操作数都是NaN，则返回NaN；
        如果两个操作数都是undefined，则返回undefined。
      与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果
      为true，就不会对第二个操作数求值了。下面看一个列子：

        var found = true;
        var result = (found || someUndefinedVariable);
        console.log(result); // true

      这个例子跟前面的例子一样。变量someUndefinedVariable没有定义的。但是，由于变量found
      的值是true。而someUndefinedVariable永远不会被求值，因此结果就会输出"true"。如果像
      下面这个例子一样，把found的值改为false，就会导致错误：

        var found = false;
        var result = (found || someUndefinedVariable); // 这里发生错误
        console.log(result); // 这一行不会执行

      我们可以利用逻辑或的这一行为来避免为变量赋null或undefined值。例如：
        
        var myObject = preferredObject || backupObject;
      
      在这个例子中，变量myObject将被赋予等号后面两个值中的一个。变量preferredObject中包
      含优先赋给变量myObject的值，变量backupObject负责在preferredObject中不包含有效值的
      情况下提供后备值。如果preferredObject的值不是null，那么它的值将被赋给myObject；如
      果是null，则将backupObject的值赋给myObject。

      乘性操作法
      ECMAScript定义了3个乘性操作符：乘法、除法和求模。在操作数为非数值的情况下会执行自动
      的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转
      换为数值。空字符串将被当作0，布尔值true将当作1。

      乘法
      乘法操作符由一个星号（*）表示，用于计算两个数值1乘积。如下面的例子：

        var result = 34 * 56;
        console.log(result); // 1904

      在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：
        如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而
          如果只有一个操作数有符号，那么结果就是负数。如果乘积超过ECMAScript数值的表示范围，
          则返回Infinity或-Infinity；
        如果有一个操作数是NaN，则结果是NaN；
        如果是Infinity与0相乘，则结果是NaN；
        如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
        如果是Infinity与Infinity相乘，则结果是Infinity；
        如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

      除法
      除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算，如下面的例子：

        var result = 66 / 11;
        console.log(result); // 6

      与乘法运算符相似，在处理特殊值时，除法运算符也有一些特殊行为：
        如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而
          如果只有一个操作数有符号，那么结果就是负数。如果商超过ECMAScript数值的表示范围，
          则返回Infinity或-Infinity；
        如果有一个操作数是NaN，则结果是NaN；
        如果是Infinity与0除，则结果是NaN；
        如果是零被零除，则结果是NaN；
        如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
        如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
        如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

      求模
      求模（余数）操作符由一个百分号（%）表示，用法如下：

        var result = 26 % 5;
        console.log(result); // 1

      与其他乘性运算符相似，对于特殊值，取模运算符也有特殊的行为：
        如果操作数都是数值，执行常规的除法计算，返回除得的余数；
        如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；
        如果被除数是有限打的数值而除数是零，则结果是NaN；
        如果是Infinity被Infinity除，则结果是NaN；
        如果被除数是有限打的数值而除数是无穷大的数值，则结果是被除数；
        如果被除数是零，则结果是零；
        如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

      加性操作符
      加性操作符，在ECMAScipt中，这两个操作符却都有一系列的特殊行为。

      加法
      加法操作符（+）的用法如下所示：

        var result = 1 + 2;
        console.log(result); // 3

      如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：
        如果有一个操作数是NaN，则结果是NaN；
        如果是Infinity加Infinity，则结果是Infinity；
        如果是-Infinity加-Infinity，则结果是-Infinity；
        如果是Infinity加-Infinity，则结果是NaN；
        如果是+0加+0，则结果是+0；
        如果是-0加-0，则结果是-0；
        如果是+0加-0，则结果是+0；
      不过，如果有一个操作数是字符串，那么就要应用如下规则：
        如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
        如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

      如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，
      然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得
      字符串"undefined"和"null"。
      
      下面来举几个例子：

        var result = 5 + 5; // 两个数值相加
        console.log(result); // 10 

        var result2 = 5 + "5"; // 一个数值和一个字符串相加
        console.log(result2); // 55

      以上代码演示了加法操作符在两种模式下的差别。第一行代码演示了正常的情况，即5+5等于10
      （数值）。但是，如果将一个操作符改为字符串"5"，结果就变成了"55"（字符串值），因为第
      一个操作数也被转换成了"5"。
      忽视加法操作中的数据类型是ECMAScript编程中最常见的一个错误。再来看一个例子：

        var num1 = 5;
        var num2 = 10;
        var message = "The sum of 5 and 10 is " + num1 + num2;
        console.log(message); // The sum of 5 and 10 is 510

      在这个例子中，变量message的值是执行两个加法操作之后的结果。有人可能以为最后得到字符
      串是"The sum of 5 and 10 is 15"，实际上的结果是"The sum of 5 and 10 is 510"。
      之所以会这样，是因为每个加法操作是独立执行的。第一个加法操作将一个字符串和一个数值
      （5）拼接了起来，结果是一个字符串。而第二个加法又用这个字符串去加另一个数值（10），
      当然也会得到一个字符串。如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应
      该像下面这样使用圆括号：

        var num1 = 5;
        var num2 = 10;
        var message = "The sum of 5 and 10 is " + (num1 + num2);
        console.log(message); // The sum of 5 and 10 is 15

      减法
      减法操作符（-）是另一个极为常用的操作符，其用法如下所示：

        var result = 2 - 1;
        console.log(result); // 1
      
      与加法操作符类似，在处理特殊值时，减法运算符也有一些特殊行为：
        如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
        如果有一个操作数是NaN，则结果是NaN；
        如果是Infinity减Infinity，则结果是NaN；
        如果是-Infinity减-Infinity，则结果是NaN；
        如果是Infinity减-Infinity，则结果是Infinity；
        如果是-Infinity减Infinity，则结果是-Infinity；
        如果是+0减+0，则结果是+0；
        如果是-0减+0，则结果是-0；
        如果是-0减-0，则结果是+0；
        如果一个操作数是字符串、布尔值、null或undefined。则先在后台调用Number()函数将
          其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结
          果就是NaN；
        如果一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到
          的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()
          方法并得到的字符串转换为数值。
      下面几个例子展示了上面的规则：

        var result1 = 5 - true;
        var result2 = NaN - 1;
        var result3 = 5 - 3;
        var result4 = 5 - "";
        var result5 = 5 - "2";
        var result6 = 5 - null;

        console.log(result1); // 4 因为true被转换成了1
        console.log(result2); // NaN
        console.log(result3); // 2
        console.log(result4); // 5 因为""被转换成了0
        console.log(result5); // 3 因为"2"被转换成了2
        console.log(result6); // 5 因为null被转换成了0

      关系操作符
      小于（<）、大于（>）、小于等于（<=）和大于等于这几个关系操作符用于对两个值进行比较，
      这几个操作符都返回一个布尔值，如下面的例子所示：

        var result1 = 5 > 3;
        var result2 = 5 < 3;
        console.log(result1); // true
        console.log(result2); // false

      当关系操作符的操作数使用了非数值是，也要进行数据转换或完成某些奇怪的操作。以下就是
      相应的规则。
        如果两个操作数都是数值，则执行数值比较。
        如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
        如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的执行
          行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前
          面的规则执行比较。
        如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

      在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人都会认为，在比较字符串
      值时，小于的意思是“在字母表中的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实
      际上完全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字
      符编码值。经过这么一番比较之后，再返回一个布尔值。由于大小写字符的字符编码全部小于小
      写字母的字符编码，因此我们就会看到如下所示的奇怪现象：

        var result = "Brick" < "alphabet";
        console.log(result); // true

      在这个例子中，字符串"Brick"被认为小于字符串"alphabet"。原因是字母B的字符编码为66，
      而字母a的字符编码是97.如果要真正按字母顺序比较字符串，就必须把两个操作数转换为相同
      大小写形式（全部大写或全部小写），然后再执行比较，如下所示：

        var result = "Brick".toLowerCase() < "alphabet".toLowerCase();
        console.log(result); // false

      通过将两个操作数都转换为小写形式，就可以得出"alphabet"按字母表顺序排在"Brick"之前
      的正确判断了。
      另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子：

        var result = "23" < "3";
        console.log(result); // true

      确实，当比较字符串"23"是否小于"3"时，结果居然是true。这是因为两个操作数都是字符串，
      而字符串比较的是字符编码（"2"的字符编码是50，而"3"的字符编码是51）。不过，如果像下
      面例子中一样，将一个操作数改为数值，比较的结果就正常了：

        var result = "23" < 3;
        console.log(result); // false

      此时，字符串"23"会被转换成数值23，然后再与3进行比较，因此就会得到合理的结果。在比较
      数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。当然，这个
      规则对前面的例子是适用的。可是，如果那个字符串不能被转换成一个合理的数值呢？比如：

        var result = "a" < 3;
        console.log(result); // false，因为"a"被转换成了NaN

      由于字母"a"不能转换成合理的数值，因此就被转换成了NaN。根据规则，任何操作数与NaN进行
      关系比较，结果都是false。于是，就出现了下面这个有意思的现象：

        var result1 = NaN < 3;
        var result2 = NaN >= 3;

        console.log(result1); // false
        console.log(result2); // false

      按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在于NaN进行比较
      时，这两个比较操作的结果都返回了false。

      相等操作符
      相等和不相等
      ECMAScript中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回true。而
      不相等操作符由叹号跟等于号（!=）表示，如果两个操作数不相等，则返回true。这两个操作符
      都会先转换操作数（通常称为强制转型），然后再比较他们的相等性。

      在转换不同的数据类型时，相等和不相等操作遵循下列基本规则：
        如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值--false转换为0，而true转换为1；
        如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
        如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本
          类型值按照前面的规则进行比较；
        这两个操作符在进行比较时则要遵循下列规则。
          null和undefined是相等。
          要比较相等性之前，不能将null和undefined转换成其他任何值。
          如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。
          如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
            则相等操作符返回true；否则，返回false。
      ！重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。
      下表列出了一些特殊情况及比较结果：
      |表达式|值|
      |----|----|
      |null == undefined|true|
      |"NaN" == NaN|false|
      |5 == NaN|false|
      |NaN == NaN|false|
      |NaN != NaN|true|
      |falst != 0|true|
      |true == 1|true|
      |true == 2|false|
      |undefined == 0|false|
      |null == 0|false|
      |"5" == 5|true|

      全等和不全等
      除了在比较值钱不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全
      等操作符由3个等于号（===）表示，它只在两个操作数未经转换就相等情况下返回true，如下面的
      例子所示：

        var result1 = ("55" == 55);
        var result2 = ("55" === 55);

        console.log(result1); // true 因为转换后相等
        console.log(result2); //false 因为不同的数据类型不相等

      在这个例子中，第一个比较使用的是相等操作比较字符串"55"和数值55，结果返回了true。如前
      所述，这是因为字符串"55"先被转换成了数值55，然后再与另一个数值55进行比较。第二个比较
      使用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下，字符串当然
      不等于数值，因此结果就是false。
      不全等与操作符由一个叹号后跟两个等于号（!==）表示，它在两个操作数未经转换就不相等的
      情况下返回true。例如：

        var result1 = ("55" != 55);
        var result2 = ("55" !== 55);

        console.log(result1); // false 因为转换后相等
        console.log(result2); // true 因为不同的数据类型不相等

      这个例子中，第一个比较使用了不相等操作符，而该操作符会将字符串"55"转换成55，结果就
      与第二个操作数（也是55）相等了。而由于这两个操作数被认为相等，因此就返回false了。第
      二个比较使用了不全等操作符。假如我们这样想：字符串55与数值55不相同吗？，答案一定是：
      是的（true）。

      记住：null == undefined 会返回true，因为它们是类似的值；但null === undefined会返
      回false，因为它们是不同类型的值。

      条件操作符
      条件操作符应该是ECMAScript中最灵活的一种操作符了，如下面的例子所示：

        var num1 = 5;
        var num2 = 4;
        var max = (num1 > num2) ? num1 : num2;
        console.log(max); // 5

      在这个例子中，max中将会保存一个最大的值。这个表示式的意思是：如果num1大于num2（关
      系表达式返回true），则将num1的值赋给max；如果num1小于或等于num2（关系表达式返回
      flase），则将num2的值赋给max。

      赋值操作符
      简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量，看下面的例子：
        
        var num = 10;

      如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。

        var num = 10;
        num += 10;
        console.log(num); // 20

      每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：
        乘法/赋值（*=）
        除法/赋值（/=）
        取模/赋值（%=）
        加法/赋值（+=）
        减法/赋值（-=）
        左移/赋值（<<=）
        有符号右移/赋值（>>=）
        无符号右移/赋值（>>>=）
      设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。

      逗号操作符
      使用逗号错座敷可以在一条语句中执行多个操作，如下面的例子所示：
        
        var num=1, num2=2, num3=3;

      逗号操作符多用于声明多个变量，但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号
      操作符总会返回表达式中的最后一项，如下面的例子所示：

        var num = (5, 1, 4, 8, 0);
        console.log(num); // 0

      
    **/
    
  </script>
</head>
<body>
  
</body>
</html>