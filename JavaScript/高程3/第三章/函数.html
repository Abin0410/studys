
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>函数</title>
  <script>
    // 最简单的函数使用这里就不说了;这里只说我平时没用到过的函数操作

    /**
     * 函数在定义时不必指定是否返回值
     * 任何函数在任何时候都可以通过return语句后
     * 跟要返回的值来实现返回值，但是切记的是return
     * 语句之后停止并立即退出，因此位于return语句
     * 之后的任何代码都不会执行这里就不做演示了
     * function sayHi(name,msg){
     *  return name + msg; 这里return回去了两个值，并且退出了这个函数之后的操作都不会被执行
     * console.log(name,msg); 上面已经return回去了，这里是不会被执行的 ！切记
     * }
     * console.log(sayHi("hello","word")); //helloword
     * **/
    /**
     * 另外，return语句也可以不带有任何返回值。
     * 在这种情况下，函数在停止执行后将返回一个undefined
     * 这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下
     * 要么就返回一个值，要么就永远都不要返回值
     * function sayHi(){
     *  return; 这里return任何返回值 所以得到的是一个undefined
     * }
     * console.log(sayHi()); // undefined
     * **/

    /**
     * 函数中的内置参数 arguments了解一下
     * 参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组
     * 而不关心数组包含哪些参数，如果这个数组中不包含任何元素，无所谓
     * 如果包含多个元素，也没问题。这时候就要靠我们的arguments对象来
     * 访问这个参数数组，从而获取传递给函数的每一个参数,arguments对象
     * 只是和数组类似而已，但是它并不是array的实例
     * 像下面这个例子，即使函数中不包含命名的参数。虽然已经没有name,msg标识符
     * 但是也可以通过arguments[0]这样的形式去访问参数
     * function f(){
     *  console.log("hello"+arguments[0] + "," + arguments[1]); // hello小黎你好
     * };
     * f("小黎","你好");
     * **/

    /**
     * 通过访问arguments对象的length属性可以获知有多少个参数传递给了函数，
     * 下面这个函数会在每次被调用时，输出传入其中的参数个数，分别显示了2,0,1
     * function fun(){
     *  console.log(arguments.length);
     * }
     * fun("string",45); // 2
     * fun(); // 0
     * fun(12); // 1
     * **/


    /**
      *像这里doAdd()函数会在只有一个参数的情况下给该参数加上10；
      *如果是两个参数的话则将那个参数简单的相加并返回结果。因此
      *下面的doAdd(10)得到了10，doAdd(30,20)得到了50
      *  function doAdd() {
      *   if (arguments.length == 1) {
      *     console.log(arguments[0] + 10); //10
      *   } else if (arguments.length == 2) {
      *      console.log(arguments[0] + arguments[1]); //50
      *    }
      * }
      *  doAdd(10);
      *  doAdd(30,20);
      **/
      
      /**
        重写后的这个doAdd()函数中，两个命名参数与arguments对象一起使用
        由于num1的值和arguments[0]的值是相同的，因此它们可以互换使用。
        function doAdd (num1,num2) {
          if (arguments.length == 1) {
            console.log(num1 + 10);  //20
          } else if(arguments.length == 2) {
            console.log(arguments[0] + 20); //30
          }
        }
        doAdd(10);
        doAdd(10,20);
      **/

      /**
       *关于arguments的行为，还有一点比较有意思的，那就是它的值永远与对应
       *命名参数的值保持同步每次执行这个doAdd()函数都会重写第二个参数，将第二个
       *参数的值修改为10，因为arguments对象中的值会自动会反映到对应的命名参数
       *所以修改了num2结果它们的值都会变成10,不过这并不是说读取这两个值会访问相同
       *的内存空间；它们的内存空间是独立的，但是它们的值会同步。另外还要记住如果只传入
       *一个参数，那么arguments[1]设置的值不会反映到命名参数中。这是因为arguments对象
       *的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。
       *还要记住最后一点:没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但
       *又没有初始化一样。例如如果给doAdd()函数传递了一个参数，那么num2中就会保存undefined
       *  function doAdd(num1, num2) {
       *    arguments[1] = 10;  //这里是把下面doAdd(10,20)中的20参数改变成了10;
       *    console.log(arguments[0] + num2); // 20
       *  }
       *  doAdd(10,20);
       **/

      // 最后补充一点在JavaScript里面是没有重载的，只要这两个定义的签名(接受的参数类型和数量)不同即可。在JavaScript里面函数是没有签名的，因为
      // 其参数是有包含零或多个值的数组来表示的。而没有函数签名，真正的重载时不可以做到的，如果在JavaScript
      // 中定义了两个名字相同的函数，则该名字只属于后定义的函数。下面的f()函数被定义了两次。第一个f()给参数
      // 加100，而第二个f()给参数加了200。由于后定义的函数覆盖了先定义的函数，因此当在最后一行代码中调用这个
      // 函数是，返回的结果是300
      // function f(num) {
      //   return num + 100;
      // };
      // function f(num) {
      //   return num + 200;
      // }
      // let result = f(100);
      // console.log(result); //300

  </script>
</head>
<body>
  
</body>
</html>