<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>理解对象</title>
  <script>
    /**
      之前已经讲过，创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加
      属性和方法，如下所示：

        var person = new Object();
        person.name = "xiaoli";
        person.age = "21";
        person.job = "buzhidao";
        person.sayName = function() {
          alert(this.name);
        }

      上面的例子创建了一个名为person的对象，并为它添加了三个属性（name、age和job）和一个
      方法（sayName()）。其中，sayName()方法用于显示this.name（将被解析为person.name）的值。
      早期的JavaScript开发人员经常使用这个模式创建新对象。几年后，对象字面量成为创建这种对象的
      首选模式。前面的例子用对象字面量语法可以写成这样：

        var person = {
          name: "xiaoli",
          age: 21,
          job: "buzhidao",
          sayName:function() {
            console.log(this.name);
          }
        }

      这个例子中的person对象与前面例子中的person对象是一样的，都有相同的属性和方法。这些属性在
      创建时都带有一些特征值，JavaScript通过这些特征值来定义它们的行为。

      属性类型
      ECMAScript中有两种属性：数据属性和访问器属性。
      "[[]]"指的是内部值
      数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。
        [[Configurable（可配置）]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性
        的特性，或者能否把属性修改为访问器属性。像前面的例子中那样直接在对象上定义的属性，它们
        的这个默认值为true。
        [[Enumerable（可枚举）]]：表示能否通过for-in循环返回属性。像前面例子中那样直接在对象
        上定义的属性，它们的这个特性默认值为true。
        [[Writable（可写的）]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，
        它们的这个特征默认值为true。
        [[Value（值）]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时
        候，把新值保存在这个位置。这个特性的默认值为undefined。

      要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接
      收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：
      configurable，enumerable，writable和value。设置其中的一或多个值，可以修改对应的特性
      值。例如：

        var person = {};
        Object.defineProperty(person,"name",{
          writable:false,
          value:"xiaoli"
        })
        alert(person.name); // xiaoli
        person.name = "小李";
        alert(person.name); // xiaoli

      这个例子创建了一个名为name的属性，它的值"xiaoli"是只读的。这个属性的值是不可修改的，如
      果尝试为它指定的新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致
      抛出错误。
        类似的规则也适用于不可配置的属性。例如：

        var person = {};
        Object.defineProperty(person,"name",{
          configurable: false,
          value: "xiaoli"
        });
        console.log(person.name); // "xiaoli"
        delete person.name;
        console.log(person.name); // "xiaoli"

      把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非
      严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的，就
      不能再把它变回可配置了，此时，再调用Object.defineProperty()方法修改除writable之外的特
      性，都会导致错误：

        var person = {};
        Object.defineProperty(person,"name",{
          configurable:false,
          value:"xiaoli"
        });
        // 报错
        Object.defineProperty(person,"name",{
          configurable:true,
          value:"xiaohong"
        });

      也就是说，可以多次调用Object.defineProperty方法修改同一个属性，但在把configurable特性
      设置为false之后就会有限制了。
      在调用Object.defineProperty()方法创建一个新的属性时，如果不指定，configurable、enumerable
      和writable特性的默认值都是false。如果调用Object.defineProperty()方法只是修改已定义的属性的
      特性，则无此限制。多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功
      能。不过，理解这些概念对理解JavaScript对象却非常有用。

      访问器属性
      访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在
      读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter
      函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特征。
        [[Configurable（可配置）]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，
        或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特征的默认值为true。
        [[Enumerable（可枚举）]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个
        特性的默认值为true。
        [[get]]：在读取属性时调用函数。默认值为undefined。
        [[set]]：在写入属性时调用的函数。默认值为undefined。
      访问器属性不能直接定义，必须使用Object.defineProperty()来定义。请看下面的例子。
        var book = {
          _year: 2004,
          edition: 1
        };
        Object.defineProperty(book, "year", {
          get:function() {
            return this._year
          },
          set:function(newValue) {
            if (newValue > 2004) {
              this._year = newValue;
              this.edition += newValue - 2004;
            }
          }
        });
        book.year = 2005;
        console.log(book.edition); // 2

        以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线
        是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year则包含一个getter函数
        和setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year
        属性修改为2005会导致_year变成2005，而edition变为2。这是使用访问器属性的常见方式，即设置
        一个属性的值会导致其他属性发生变化。

        定义多个属性
        由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。
        利用这个方法可以通过描述一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改
        其属性的对象，第二个对象的属性与第一个对象中要添加或者修改属性一一对应。例如：
          var book = {};
          Object.defineProperties(book, {
            _year: {
              writable: true,
              value: 2004
            },
            edition: {
              writable: true,
              value: 1
            },
            year: {
              get: function() {
                return this._year
              },
              set: function(newValue) {
                if (newValue > 2004) {
                  this._year = newValue;
                  this.edition += newValue - 2004;
                }
              }
            }
          });
          book.year = 2005;
          console.log(book.edition); // 2

        以上代码在book对象上定义了两个数据属性（_year和edition）和一个访问器属性（year）。最终的
        对象与之前中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。

        读取属性的特性
        使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个
        方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器
        属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性
        有configurable、enumerable、writable和value。例如：

        var book = {};
        Object.defineProperties(book, {
          _year: {
            value: 2004
          },
          edition: {
            value: 1
          },
          year: {
            get: function() {
              return this._year;
            },
            set: function(newValue) {
              if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
              }
            }
          }
        });
        var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
        console.log(descriptor.value); // 2004
        console.log(descriptor.configurable); // false
        console.log(typeof descriptor.get); // undefined

        var descriptor = Object.getOwnPropertyDescriptor(book, "year");
        console.log(descriptor.value); // undefined
        console.log(descriptor.enumerable); // false
        console.log(typeof descriptor.get); // "function"

        对于数据属性_year，value等于最初的值，configurable是false，而get等于undefined。对于访
        问器属性year，value等于undefined，enumberable是false，而get是一个指向getter函数的指针。
      */
  </script>
</head>
<body>
  
</body>
</html>