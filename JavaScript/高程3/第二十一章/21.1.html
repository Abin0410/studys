<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title></title>
</head>

<body>
  <script>
    /**
      # Ajax与Comet
      Ajax技术的核心是XMLHttpRequest对象（简称XHR）。

      ## XMLHttpRequest对象
      要创建XHR对象要像下面这样使用XMLHttpRequest构造函数。
      ```js
      var xhr = new XMLHttpRequest();
      ```

      ### XHR的用法
      在使用XHR对象时，要调用的第一个方法是 **open()**，它接受3个参数：要发送的请求的类型（"get"、"post"等）、
      请求的URL和表示是否异步发送请求的布尔值。来看个例子：
      ```js
      var xhr = new XMLHttpRequest();
      xhr.open("get", "localhost:8080/example.php", false);
      ```
      URL相对于执行代码的当前页面（也可以使用绝对路径）；调用open()方法并不会真正发送请求，而只是启动一个请求
      以备发送。
      :::warning
      只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求的页面有任何差别，都发生跨域。
      :::

      要发送特定的请求，必须像下面这样调用 **send()** 方法：
      ```js
      xhr.open("get", "localhost:8080/example.php", false);
      xhr.send(null);
      ```
      这里的send()方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入null，
      因为这个参数对有些浏览器来说是必需的。调用send()之后，请求就会被分派到服务器。

      由于这次请求是同步的，JavaScript代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR
      对象的属性，相关属性简介如下：
      * responseText: 作为响应主体被返回的文本。
      * responseXML: 如果响应的内容类型是"text/xml"或"application/xml"，这个属性中将保存包含着响应数据的XML DOM文档。
      * status：响应的HTTP状态。
      * stateusText：HTTP状态的说明。

      在接收到响应后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP状态代码为200作为成功
      的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也应该能够访问了。为
      确保接收到适当的响应，应该像下面这样检查上述这两种状态代码：
      ```js
      var xhr = new XMLHttpRequest();
      xhr.open("get", "localhost:8080/example.php", false);
      xhr.send(null);
      if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
        console.log(xhr.responseText);
      } else {
        console.log(xhr.status);
      }
      ```
      根据返回的状态代码，这个例子可能会显示由服务器返回的内容，也可能会显示一条错误消息。无论内容类型是什么，
      响应主体的内容都会保存到responseText属性中；而对于非XML数据而言，responseXML属性的值将为null。

      多数情况下，我们还是要发送异步请求，才能让JavaScript继续执行而不必等待响应。此时，可以检测XHR对象的 
      **readyState** 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下：
      * 0: 未初始化。尚未调用open()方法
      * 1: 启动。已经调用open()方法，但尚未调用send()方法。
      * 2: 发送。已经调用send()方法，但尚未接收到响应。
      * 3: 接收。已经接收到部分响应数据。
      * 4: 完成。已经接收到全部响应数据，而且已经可以在客户端使用了。
      
      只要readyState属性的值由一个值变成另一个值，都会触发一次readyStatechange事件。可以利用这个事件来检
      测每次状态变化后readyState的值。我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪。必
      须在调用 **open()**之前指定onreadystatechange事件才能确保跨浏览器兼容性。看下面的例子：
      ```js
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            console.log(xhr.responseText);
          } else {
            console.log(xhr.status);
          }
        }
      }
      xhr.open("get", "https://wr0359.cn/candle/listTemple", true);
      xhr.send(null);
      ```
      
      另外，在接收到响应之前还可以调用 **abort()** 方法来取消异步请求，如下所示: 
      ```js
      xhr.abort();
      ```
      调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何于响应有关的对象属性。在终止请求之后，在
      应该对XHR进行解引操作。由于内存原因，不建议重用XHR对象。

      ### HTTP头部信息
      每个HTTP请求和响应都会带有相应的头部信息，XHR对象也提供了操作这两种头部（即请求头部和响应头部）信息的方法。
      
      默认情况下，在发送XHR请求的同时，还会发送下列头部信息。
      * Accept：浏览器能够处理的内容类型。
      * Accept-Charset：浏览器能够显示的字符集。
      * Accept-Encodeing：浏览器能够处理的压缩编码。
      * Accept-Language：浏览器当前设置的语言。
      * Connection：浏览器与服务器之间连接的类型。
      * Cookie：当前页面设置的任何Cookie。
      * Host：发出请求的页面所在的域。
      * Referer：发送请求的页面的URI。注意，HTTP规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。
      * User-Agent：浏览器的用户代理字符串。

      使用 **setRequestHeader()** 方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部
      字段的值。要成功发送请求头部信息，必须在调用open()方法之后且调用send()方法之前调用 **setRequestHeader()**
      看下面的例子：
      ```js
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            console.log(xhr.responseText);
          } else {
            console.log(xhr.status);
          }
        }
      }
      var url = "https://www.easy-mock.com/mock/5dbc5cea9e771148eb1d91ba/example/getData";
      xhr.open("get", url, false);
      xhr.setRequestHeader("MyHeader", "MyValue");
      xhr.send(null);
      ```
      服务器在接收到这种自定义的头部信息之后，可以执行相应的后续操作。在使用自定义的头部字段名称时，不要使用浏览
      器正常发送的字段名称，否则有可能会影响服务器的响应。

      调用XHR对象的 **getResponseHeader()** 方法并传入头部字段名称，可以取得相应的响应头部信息。而调用
      **getAllResponseHeaders()** 方法则可以取得一个包含所有头部信息的长字符串。来看下面的例子：
      ```js
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            console.log(xhr.responseText);
          } else {
            console.log(xhr.status);
          }
        }
      }
      // 可以从easy-mock网站里自行模拟接口
      var url = "https://www.easy-mock.com/mock/5dbc5cea9e771148eb1d91ba/example/getData"
      xhr.open("get", url, false);
      xhr.setRequestHeader("MyHeader", "MyValue");
      xhr.send(null);
      var myHeader = xhr.getResponseHeader("MyHeader");
      var allHeaders = xhr.getAllResponseHeaders();
      console.log(allHeaders); // 可以自己打印出来在控制台可以看到
      ```

      ### GET请求
      使用GET请求经常发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用
      encodeURIComponent()进行编码，然后才能放到URL的末尾；而且所有名-值对儿都必须由和号（&）分隔，如下
      面的例子所示：
      ```js
      xhr.open("get", "https://www.easy-mock.com/mock/5dbc5cea9e771148eb1d91ba/example/getData?name1=1&name2=2", true);
      ```
      下面这个函数可以辅助向现有URL的末尾添加查询字符串参数：
      ```js
      function addURLParam(url, name, value) {
        url += (url.indexOf("?") == -1 ? "?" : "&");
        url += encodeURIComponent(name) + "=" + encodeURIComponent(value);
        return url;
      }
      ```
      使用这个函数来构建请求URL的示例：
      ```js
      var url = "https://www.easy-mock.com/mock/5dbc5cea9e771148eb1d91ba/example/getData";

      // 添加参数
      url = addURLParam(url, "name", "xiaoli");
      url = addURLParam(url, "age", "21");

      // 初始化请求
      xhr.open("get", url, false);
      ```

      ### POST请求
      POST请求应该把数据作为请求的主体提交，而GET请求传统上不是这样。POST请求的主体可以包含非常多的数据，
      而且格式不限。在open()方法第一个参数的位置传入"post"，就可以初始化一个POST请求，如下面的例子所示。
      ```js
      var url = "https://www.easy-mock.com/mock/5dbc5cea9e771148eb1d91ba/example/getData"
      xhr.open("post", url, false);
      ```
      我们可以模拟表单提交，看看POST的用法。
      ```js
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            console.log(xhr.responseText);
          } else {
            console.log(xhr.status);
          }
        }
      }
      // 可以从easy-mock网站里自行模拟接口
      var url = "https://www.easy-mock.com/mock/5dbc5cea9e771148eb1d91ba/example/getData"
      xhr.open("POST", url, true);

      // 设置请求头部
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      
      // 这里是假设form对象已经获取
      xhr.send(serialize(form));
      ```
    **/
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
          console.log(xhr.responseText);
        } else {
          console.log(xhr.status);
        }
      }
    }
    // 可以从easy-mock网站里自行模拟接口
    var url = "https://www.easy-mock.com/mock/5dbc5cea9e771148eb1d91ba/example/getData"
    xhr.open("POST", url, true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    // 这里是假设form对象已经获取
    xhr.send(serialize(form));
  </script>
</body>

</html>