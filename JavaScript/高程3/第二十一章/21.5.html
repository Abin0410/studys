<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title></title>
</head>
<body>
  <script>
    /**
      ## 其他跨域技术

      ### 图像Ping
      一个网页可以从任何网页中加载图像，不用担心跨不跨域。这也是在线广告跟踪浏览量的主要方式。

      动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。
      请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是是像素图或204响应。
      通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什
      么时候接收到的。看下面的例子：
      ```js
      var img = new Image();
      img.onload = img.error = function() {
        console.log("Done!");
      };
      img.src = "http://www.baidu.com/test?name=xiaoli";
      ```
      这里创建了一个Image的实例，然后将onload和onerror事件指定为同一个函数。这样无论是什么响应，
      只要请求完成，就能得到通知。

      图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。图像Ping有两个主要的缺点，一是只能发送
      GET请求，二是无法访问服务器的响应文本。因此，图像Ping只能用于浏览器与服务器的简单通信。

      ### JSONP
      JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，就像下面这样。
      ```js
      callback({"name": "xiaoli"});
      ```
      JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的
      名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。来看个JSONP的请求：
      ```js
      http://freegeoip.net/json/?callback=handleResponse
      ```
      这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很常见的，就
      想上面的URL所示，这里指定的回调函数的名字叫handleResponse()。

      JSONP是通过动态`<script>`元素来使用的，使用时可以为src属性指定一个跨域URL。和`<img>`元素类似。
      因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。
      来看一个例子：
      ```js
      function handleResponse(response) {
        console.log(response.ip + ", " + response.city + ", " + response.region_name);
      }

      var script = document.createElement("script");
      script.src = "http://freegeoip.net/json/?callback=handleResponse";
      document.body.insertBefore(script, document.body.firstChild);
      ```
      JSONP的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。
      JSONP的缺点：JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码。
      要确定JSONP请求是否失败并不容易。`<script>`元素新增一个onerror事件，但目前只是部分浏览器支持。
      为此，不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户
      上网的速度和带宽都一样。

      ### Comet
      Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理
      体育比赛的分数和股票报价。

      有两种实现Comet的方式：**长轮询** 和 **流**。长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览
      器定时向服务器发送请求，看有没有更新的数据。下图是短轮询的时间线。
      21-1图

      长轮询：页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，
      浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。下图是长轮询
      的时间线。
      21-2图
      
      无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接。两者最大的区别在于服务器
      如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。轮询的优势是
      所有浏览器都支持，因为使用XHR对象和setTimeout()就能实现。

      第二种流行的Comet实现是HTTP流。流不同于上面说的轮询，因为它在页面的整个生命周期内只使用一个HTTP
      连接。就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。

      通过侦听readystatechange事件及检测readyState的值是否为3，就可以利用XHR对象实现HTTP流。当
      readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的
      数据，决定从什么位置开始取得最新的数据。来看个例子：
      ```js
      function createStreamingClient(url, progress, finished) {
        var xhr = new XMLHttpRequest(),
            received = 0;

        xhr.open("get", url, true);
        xhr.onreadystatechange = function() {
          var result;

          if (xhr.readyState == 3) {
            // 只取得最新数据并调整计数器
            result = xhr.responseText.substring(received);
            received += result.length;

            // 调用progress回调函数
            progress(result);
          } else if (xhr.readyState == 4) {
            finished(xhr.responseText);
          }
        };
        xhr.send(null);
        return xhr;
      }

      var client = createStreamingClient("streaming.php", function(data) {
        console.log(data);
      }, function(data) {
        console.log("Done!");
      })
      ```
      这个createStreamingClient()函数接收三个参数：要连接的URL、在接收到数据时调用的函数以及关闭
      连接时调用的函数。有时候，当连接关闭时，很可能还需要重新建立，所以关注连接什么时候关闭还是有必要的。

      只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。
      这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。通过progress回
      调函数来处理传入的新数据。而当readyState值为4时，则执行finished回调函数，传入响应返回的全部内容。

      ### 服务器发送事件
      SSE和事件流

      ### Web Sockets
      Web Sockets的目标是在一个单独的持久连接提供全双工、双向通信。

      #### Web Sockets API
      要创建Web Socket，先实例一个WebSocket对象传入要连接的URL:
      ```js
      // 必须给WebSocket构造函数传入绝对URL。
      var socke = new WebSocket("ws://www.example.com/server.php");
      ```
      与XHR类似，WebSocket也有一个表示当前状态的readyState属性。但是，这个属性的值和XHR并不相同，如下所示：
      * WebSocket.OPENING：正在建立连接。
      * WebSocket.OPEN：已经建立连接。
      * WebSocket.CLOSING：正在关闭连接。
      * WebSocket.CLOSE：已经关闭连接。

      WebSocket没有readystatechange事件。它有其他事件，对应着不同的状态。readyState的值永远从0开始。

      要关闭Web Socket连接，可以在任何时候调用close()方法。
      ```js
      socket.close();
      // 调用close()之后，readyState的值变为2，而在关闭连接后就变成3。
      ```

      #### 发送和接收数据
      要向服务器发送数据，使用send()方法并传入任意字符串，例如：
      ```js
      var socke = new WebSocket("ws://www.example.com/server.php");
      socke.send("hello world！");
      ```
      对于复杂的数据结构，可以在连接发送之前，必须进行序列化。看下面的例子：
      ```js
      var message = {
        time: new Date(),
        text: "Hello world！",
        clientId: "asdfp8734rew"
      }
      socke.send(JSON.stringify(message));
      ```
      当服务器向客户端发来消息时，WebSocket对象就会触发message事件。这个message事件与其他传递消息的协议
      类似。也是把返回的数据保存在event.data属性中。
      ```js
      socke.onmessage = function(event) {
        var data = event.data;

        // 处理数据
      }
      ```
      event.data中返回的数据也是字符串。如果想得到其他格式数据，必须手工解析这些数据。

      #### 其他事件
      WebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发。
      * **open**：在成功建立连接时触发。
      * **error**：在发生错误时触发。连接不能持续。
      * **close**：在连接关闭时触发。

      必须使用DOM 0级语法分别定义每个事件。
      ```js
      var socke = new WebSocket("ws://www.example.com/server.php");
      socket.onopen = function() {
        console.log("成功连接");
      }

      socket.onerror = function() {
        console.log("连接失败");
      }

      socket.onclose = function() {
        console.log("连接已断开");
      }
      ```
      只有close事件的event对象有额外的信息。这个事件的事件对象有三个额外的属性：**wasClean**、**code** 和
      **reason**。wasClean是一个布尔值，表示连接是否已经明确地关闭；code是服务器返回的数值状态码；而reason
      是一个字符串，包含服务器发回的消息。可以打印出来以便将来分析。
    **/
    var socke = new WebSocket("ws://www.example.com/server.php");
    socket.onopen = function() {
      console.log("成功连接");
    }

    socket.onerror = function() {
      console.log("连接失败");
    }

    socket.onclose = function() {
      console.log("连接已断开");
    }
  </script>
</body>
</html>