<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    
  </body>
  <script>
    /* // 构造函数
  function Person(age, height) {
    this.age = age
    this.height = height
  }

  // 每创建一个函数，都会有一个原型对象prototype。
  console.log(Person.prototype)

  // 构造函数的原型对象有个constructor属性，引用这个构造函数，两者是循环引用
  console.log(Person.prototype.constructor)

  // 原型链都会终止于Object的原型对象
  console.log(Person.prototype.__proto__ === Object.prototype)

  // object原型的原型是null
  console.log(Object.prototype.__proto__)

  // 每次调用构造函数创建实例时，这个实例的内部[[prototype]]指针会被赋值为构造函数的原型对象，通过这个属性可以访问对象的原型。
  const person1 = new Person(18, '173')

  // 实例可以通过__proto__找到原型对象。
  console.log(person1.__proto__)

  // 构造函数通过prototype属性找到原型对象，实例和构造函数没有直接关系，和原型对象有直接关系
  console.log(Person.prototype) */
    /*   function SuperType(name, age) {
    this.name = name
    this.age = age
  }

  function SubType() {}

  SubType.prototype = new SuperType('图图', 20)

  const person = new SubType()
  console.log(person.__proto__ === SubType.prototype)
  console.log(SubType.prototype.constructor) */

    /* function curry(fun) {
    return function curried(...args) {
      if (args.length >= fun.length) {
        return fun.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2))
        }
      }
    }
  }

  function sum(a, b, c) {
    return a + b + c
  }

  let curriedSum = curry(sum)
  console.log(curriedSum(1)(2)(3)) */
    /**
     * @description: 递归
     * @param {*} arr 原数组
     * @param {*} child 子数组名
     * @param {*} key 目标属性名
     * @param {*} value 目标值
     * @return {*}
     */ 
    function circulate(arr, child, key, value) {
      if (Object.prototype.toString.call(arr) !== '[object Array]') {
        throw new Error(`传入的不是一个数组`);
      }
      let val = null;
      for (let index = 0; index < arr.length; index++) {
        if (arr[index][key] === value) {
          val = arr[index][key];
          break;
        }

        let hasCondition = arr[index][child] instanceof Array && arr[index][child].length > 0;
        return hasCondition ? circulate(arr[index][child], key, child, value) : '没找到你想要的值';
      }
      return val;
    }

    const tree = [
      {
        name: 1,
        arr: [
          {
            name: 2,
            arr: [
              {
                name: 3,
                arr: [
                  {
                    name: 4,
                    arr: [
                      {
                        name: 5,
                        arr: [
                          {
                            name: 6,
                            arr: [
                              {
                                name: 7,
                                arr: [
                                  {
                                    name: 8,
                                    arr: [],
                                  },
                                ],
                              },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
    ];
    console.log(circulate(tree, 'arr', 'name', 9));
  </script>
</html>
