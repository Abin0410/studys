## HTTP 诞生

HTTP 译为 "超文本传输协议"，诞生于 1989 年 3 月。是一位名叫蒂姆伯纳斯-李这位哥儿们提出的，最初设想的基本理念是：借助多文档之间相互关联形成的超文本，连成可相互参阅的 W W W（World Wide Web，万维网）。 W W W 简称 Web。

HTTP 0.9 在 1990 年问世。那时的 HTTP 还没有作为正式的标准被建立。

HTTP 1.0 在 1996 年 5 月正式作为标准。现在该协议标准直到现在还被广泛使用在服务器端。

HTTP 1.1 在 1997 年 1 月公布为目前主流的 HTTP 协议版本。

HTTP 2.0 在 2014 年 11 月实现标准化。

## TCP/IP

一般使用的网络（包括互联网）是在 TCP/IP 协议的基础上运作的。HTTP 属于它内部的一个子集。

计算机和网络设备要互相通信，双方都必须基于相同的方法。例如，如何探测到通信目标、是哪一边先发起通信、使用哪种语言进行通信、怎么样结束通信等规则都是需要先确定的。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而这种规则称为协议。

协议中包括：从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。把这些相关联的协议集合起来总称为 TCP/IP。

TCP/IP 重要的点就是分层。有以下 4 层：应用层、传输层、网络层和数据链路层。

### TCP/IP 各层作用

#### 应用层

应用层决定了向用户提供应用服务是通信的活动。比如，FTP 文件传输协议和 DNS。HTTP 协议也在该层。

#### 传输层

传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。该层有两个不同的协议：TCP 传输控制协议和 UDP 用户数据报协议。

#### 网络层

网络层用来处理在网络上流动的数据包。

#### 数据链路层

用来处理连接网络的硬件部分。

TCP/IP 层次化的好处是：如果互联网由一个协议统一规划，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层只需要把变动的层替换掉。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动。层次化之后，处于应用层的应用可以只考虑分派给自己的任务，不需要其他问题。

### TCP/IP 通信传输流

TCP/ IP 协议进行通信时，会通过分层顺序和对方进行通信。客户端从应用层往下走，接收端则从链路层往上走。举个例子：

1. 首先客户端在应用层发出一个想看某个 Web 页面的 HTTP 请求。
2. 接着，在传输层把应用层接收到的数据进行分割，在每个报文上打上标记好以及端口号后转发给网络层。
3. 在网络层，将 MAC 地址转发给链路层。
4. 接收端的服务器在链路层接收到数据后，按次序往上层发送，直到应用层。传输到应用层才算真正接收到客户端发过来的 HTTP 请求。

看下图展示整过过程。
![](./images/1/1.3.1.jpg)

客户端在每层传输数据的时候，每经过一层就会打上一个该层的首部信息。而接收层在每层传输数据的时候，每经过一层都会把对应的首部去除。

## IP、TCP 和 DNS

IP、TCP 和 DNS 这三个协议，都是和 HTTP 密不可分的。

### IP 网络协议

IP 地址指的是节点被分配到的地址，MAC 地址指的是网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址是可变的，MAC 地址是不可变的。

### ARP 协议

IP 间的通信依赖 MAC 地址。在网络上通信的双方在同一局域网内的情况很少，一般都是经过多台计算机或者网络设备中转才能连接到对方。而在中转时，会利用
下一站中转设备的 MAC 地址进行搜索下一个中转目标。而这时，会采用 ARP 协议。ARP 协议是一种用来解析的地址的协议，通过通信方的 IP 地址就能反查出
对应的 MAC 地址。

在到达通信目标前的中转过程中，计算机和路由器只能获取很粗略的传输路线。这种机制叫做路由选择。

### 可靠性的 TCP 协议

TCP 位于传输层，提供可靠性的字节流服务。字节流服务指的是，为了方便传输，将大块数据分割以报文段为单位的数据包进行管理。而可靠性的传输服务指的是，能
把数据准确可靠地传给对方。

为了准确地把数据传送给对方，这时 TCP 协议的三次握手就出现了。

- 第一次握手：发送端先发送一个带 SYN 标志的数据包给对方。
- 第二次握手：接收端收到之后，回传一个带有 SYN/ACK 标志的数据包表示传达确认信息。
- 第三次握手：最后，发送端再传回一个带 ACK 标志的数据包，表示 “握手” 结束。

下图展示这个过程。

![](./images/1/1.4.1.jpg)

### DNS 服务

DNS 服务是和 HTTP 协议一样，位于应用层。它的作用是，将域名解析成 IP 地址。DNS 协议可以通过域名查找 IP 地址，也可以通过 IP 地址反查域名的服务。
![](./images/1/1-5-1.jpg)

下图展示每个协议跟 HTTP 协议的关系。
![](./images/1/1-6-1.jpg)

## URI 和 URL

### 什么是 URI

**URL**（统一资源定位符） 是访问 Web 页面需要输入的网站地址。例如，`http://www.tutu.com/`就是 **URL**。

**URI**（统一资源标识符）。全称叫 `Uniform Resource Locator`。 它的作用是区分互联网上不同的资源，而 **URL** 表示资源的地点。URL 是 URI 的子集。

### URI 格式

`http://user:pass@www.tutu.com:8080/html/index.html?userId=1#cn1`

- **协议名**：`http:`或`https:`表示协议名称。不区分字母大小写，最后要加上`://`。
- **登录信息**：**user:pass@** 表示获取服务器资源的用户名和密码。不推荐使用，不安全，也没用过。
- **服务器地址**：服务器地址可以是三种：
  - 以域名的形式`www.tutu.com`；
  - 以 IPv4 `192.168.0.1`地址名；
  - 以`[0:0:0:0:0:0:1]`这种方括号括起来 IPv6 地址名；
- **服务器端口**：`:8080`表示端口号。
- **文件路径**：`/html/index.html`指的是服务器文件路径，资源的访问位置。
- **查询字符串**：`?userId=1`指的是文件路径中参数。`?`后面以`key=value`的形式。如果后面还需要加参数，用`&`拼接。
- **片段标识符**：`#cn1`指的是文件中的某个位置。相当于一个锚点。

## HTTP 基础

HTTP 是一种无状态的协议，对发送过的请求或响应都不做持久化处理。它不对之前发生过的请求和响应的状态进行管理。

### HTTP 的请求方法

- GET：获取服务器资源。
- POST：提交信息给服务器。
- PUT：传输文件。
- HEAD：和 GET 方法一样，但是只返回响应首部。作用是确定 URL 的有效性和资源更新的日期时间。
- DELETE：按请求的 URL 删除指定的资源。
- OPTIONS：查询请求服务器指定的资源支持的方法。
- TRACE：用来确认连接过程中发生的一些操作。
- CONNECT：建立连接渠道，用于代理服务器。

### 持久化连接

HTTP 1.1 中的所有连接都是默认开启的，而在 HTTP1.0 中是默认关闭的。它的特点是，只要有一端没有提出断开连接，那么就会保持 TCP 连接状态。好处是，减少 TCP 连接的重复建立和断开连接造成的额外开销，减轻服务器压力。这样可以使得 HTTP 请求和响应更快结束，也提高了页面的显示速度。

### 管线化

管线化不用等待响应即可发送下一个请求。也就是并行处理，不用一个接一个的等待响应，管线化比持久化连接要还要快。但现在这项技术并没有成熟。

## 内容协商

内容协商机制是指客户端和服务器端就响应的资源内容进行互相协商，然后提供给客户端最适合的资源。内容协商会以语言、字符集、编码方式等为标准判断响应的资源。

主要使用的请求头有：

- Accept
- Accept-Charset
- Accept-Language
- Content-Language

后面的 HTTP 头部信息有讲到。

内容协商技术有下面三种类型。

- 服务器驱动协商（Server-driven Negotiation）
  由服务器进行内容协商。
- 客户端驱动协商 （Agent-driven Negotiation）
  由客户端进行内容协商的方式。
- 透明协商（Transparent Negotiation）
  服务器驱动和客户端驱动的结合体，由服务器端和客户端各自进行内容协商的一种方法。

## HTTP 请求状态码

#### 1XX

`1XX`表示接收的请求正在处理;

#### 2XX 成功

- `200 OK`： 表示客户端发来的请求在服务器端被正常处理了。
- `204 No Content`：表示请求被处理成功，但没有资源可返回。
- `206 Partial Content`：表示客户端进行了范围请求，而服务器成功执行了这部分的`GET`请求。响应报文中含`Content-Range`指定范围的实体内容。

#### 3XX 重定向

- `301 Moved Permanently`：永久重定向。表示请求的资源已经被分配了新的 URL ，以后应使用资源现在所指的 URL。
- `302 Found`：临时重定向。表示请求的资源被分配了新的 URL 。
- `303 See Other`：表示请求对应的资源存着另一个 URL，应使用`GET`方法获取请求的资源。
- `304 Not Modified`：表示请求已经找到，但不符合条件请求。还有一种含义是服务器端资源没变，可以直接使用客户端未过期的缓存。注意的是，`304`和重定向没有任何关系。
- `307 Temporary Redirect`：临时重定向，和`302`类似。但是不能改变请求方法。

#### 4XX 客户端错误

- `400 Bad Request`：表示请求报文中存在语法错误。
- `401 Unauthorized`：表示发送的请求要通过 HTTP 认证的认证信息。如果之前有请求过`1`次，就表示用户认证失败。
- `403 Forbidden`：表示对请求资源的访问被服务器拒绝。
- `404 Not Found`：表示服务器上无法找到请求的资源。

#### 5XX 服务器错误

- `500 Internal Serve Error`：表示服务器端在执行请求时发生错误。
- `503 Service Unavailable`：表示服务器暂处于超负荷或正在进行停机维护。

## HTTP 请求头和响应头的通用信息

### HTTP 报文

HTTP 一共有两种报文：请求报文、响应报文，而报文可分为报文头部和报文主体。但不一定要有报文主体。下图展示这两种报文的结构。

客户端的 HTTP 报文叫做请求报文。

![]("./images/请求报文.jpg")

服务器端的 HTTP 报文 叫做响应报文。

![]("./images/响应报文.jpg")

这两种报文都由以下数据所组成。

#### 请求行

请求行由三部分组成：请求方法、请求 URL（不包括域名） 和 HTTP 协议版本。

#### 状态行

状态行包括响应结果和状态码，原因短语和 HTTP 版本。

#### 头信息

头信息包括了请求和响应的各种条件和属性的各类头部。一般有 4 种头部：通用头部、请求头部、响应头部和实体头部。

#### 其他

可能会包含 HTTP 的 RFC 里未定义的头部。

下面列出请求报文和响应报文都会用到的一些信息。

### Cache-Control

通过`Cache-Control`字段，可以进行缓存的操作。参数都是可选的，如果有多个参数的话，以`，`分隔开。

#### 客户端

在请求中使用到`Cache-Control`时，它的可选值：

- `no-cache`：不接收缓存过的响应，要求直接向源服务器发起请求。
- `no-store`：不使用任何缓存。
- `max-age`：如果缓存资源的时间没有超过指定的时间，客户端从缓存中获取资源。以秒为单位。
- `min-fresh`：要求服务器返回还没过指定时间的缓存资源。以秒为单位。
- `max-stale`：即使是过期的资源，也照样接收。
- `only-if-cached`：告诉服务器，从缓存中获取资源（如果有）。
- `no-transform`：不能对资源进行转换。这样做可以防止缓存或代理压缩图片等类似操作。

#### 服务器端

在响应中使用到`Cache-Control`时，它的可选值：

- `public`：不管是浏览器还是代理服务器都可以缓存。
- `private`：资源只能被浏览器缓存。
- `no-cache`：可以缓存，但每次使用前要向源服务器进行验证缓存的有效性。
- `no-store`：不使用任何缓存。
- `s-maxage`：只适用于代理服务器，表示代理服务器中的过期时长，私有缓存会忽略它，使用`s-maxage`后，会忽略`max-age`和`Expires`字段。
- `max-age`：设置缓存时间，如果没有超过该时间，不需要进行请求。如果超过该时间，被视为资源已过期。以秒为单位。如果响应头出现 Expires 字段，在 HTTP1.1 中会优先处理`max-age`，而 HTTP1.0 中则相反。
- `must-revalidate`：可以缓存，但必须向源服务器再次验证。如果请求失败，则返回 504。`must-revalidate`会忽略`max-stale`。
- `proxy-revalidate`：要求缓存服务器对缓存的响应有效性进行确认。
- `no-transform`：不能对资源进行转换。这样做可以防止缓存或代理压缩图片等类似操作。

### Connection

`Connection`字段可以管理持久化连接。 有两个值：`keep-Alive`和`close`，`keep-Alice`表示持久连接。而`close`表示关闭该连接。

### Date

`Date`字段表示 HTTP 报文创建的时间和日期。

### Pragma

`Pragma` 是用来向后兼容只支持 HTTP1.0 协议的缓存服务器。它的效果和`Cache-Control: no-cache`一样。

### Transfer-Encoding

`Transfer-Encoding`规定了传输报文主体时采用的编码方式。

- `chunked`：数据以分块的形式进行发送。
- `compress`：UNIX 系统的标准压缩算法。
- `gzip`：`GNU gzip`
- `deflate`：使用`zlib`结构。
- `identity`：不进行编码。

### Upgrade

`Upgrade`用于查看 HTTP 协议或者其他协议是否可以使用更高的版本进行通信。

### Via

`Via`用于跟踪客户端与服务端之间的请求和响应报文的传输路径，可以避免请求循环的发生。

### Warning

`Warning`是告诉用户一些跟缓存相关的问题警告。格式如下：

```http
Waring：警告码 [警告的主机: 端口号] ["警告内容"] [日期时间]
```

警告码如下所示：

- `110`（Response Is Stale）：缓存服务器返回的资源已过期
- `111`（Revalidation Failed）：无法访问服务器，验证资源有效性失败
- `112`（Disconnected Operation）：缓存服务器切断连接
- `113`（Heuristic Expiration）：响应的使用期超过 24 小时（有效缓存的设置时间大于 24 小时的情况下）
- `199`（Miscellaneous Warning）：任意的警告内容
- `214`（Transformation Applied）：代理服务器对内容编码或媒体类型执行了某些处理时
- `299`（Miscellaneous Warning）：和`199`类似，只不过指的是持久化警告

### 请求头字段

#### Accept

`Accept`请求头用来告诉服务器，客户端可以处理的内容类型。下面列出几种媒体类型。

- 文本文件

  `text/html`、`text/plain`、`text/css`、`application/xhtml+xml`、`application/xml`等。

- 图片文件

  `image/jpeg`、`image/gif`、`image/png`

- 视频文件

  `video/mpeg`、`video/quicktime`

- 二进制文件

  `application/octet-stream`、`application/zip`等

当值为`*/*`，表示客户端可以是任意内容类型。当值为`image/*`，可以用来指代任何其他图片类型。

如果想给显示的谋体类型增加优先级，通过用`q=`表示权重值，用分号（`;`）分隔开。权重值的范围是`0~1`，可以精确到小数点后`3`位，`1`是最大值。没有指定权重`q`值时，默认权重是`q=1.0`。

```http
Accept: text/html, application/json;q=0.9
```

#### Accept-Charset

`Accept-Charset`请求头用来告诉服务器，客户端可以处理的字符集类型。另外，可以一次性指定多种字符集。和`Accept`一样，通过`q`值来表示优先级。该头部应用于内容协商机制的服务器驱动协商。

```http
Accept-Charset: iso-8859-1

Accept-Charset: iso-8859-1;q=0.5
```

#### Accept-Encoding

`Accept-Encoding`请求头用来告诉服务器，客户端能理解的内容编码方式。可以一次性指定多种内容编码。

下面列出几种内容编码例子。

- gzip
  由文件压缩程序 gzip 生成的编码格式，使用 Lempel-Ziv 算法及 32 位循环冗余验证。

- compress
  由 UNIX 文件压缩程序`compress`生成的编码格式，采用 Lempel-Ziv-Welch 算法。

- deflate
  组合使用 zlib 格式以及有`deflate`压缩算法生成的编码格式。

- identity
  不执行压缩或不会变化的默认编码格式。

```http
Accept-Encoding: gzip, deflate
```

和`Accept`一样，通过`q`值来表示优先级。还可以用星号（`*`），表示指定任意的编码格式。

#### Accept-Language

`Accept-Language`请求头用来告诉服务器，客户端可以理解的自然语言集（指中文和英文等），以及自然语言级的优先级。可一次指定多种自然语言集。和`Accept`一样，用权重值`q`来表示优先级。

```http
zh-CN,zh;q=0.9,en;q=0.8
```

客户端在服务器有中文版资源的情况下，会请求并返回中文版对应的响应，如果没有中文版，那就返回英文版响应。

#### Authorization

`Authorization`用来告诉服务器，用户代理的认证信息（证书值）。通常会在服务器返回`401`状态码响应后，将头部字段`Authorization`添加到请求中。

#### Expect

`Expect`用来告诉服务器，只有在满足这个期望条件的情况下才能妥善地处理请求。如果服务器不能满足客户端的期望条件的话，会返回`417`状态码。目前只规定了`100-continue`这条期望条件。

```http
Expect: 100-continue
```

#### From

`From`字段是用来告诉服务器，使用用户代理的用户的电子邮箱地址。

#### Host

`Host`请求头指明了请求的资源所在的服务器主机名和端口号。

#### If-Match

像`If-xxxx`这种样式的请求头字段，都是条件请求。服务器收到附带条件的请求之后，只有判断条件为真才会执行请求。

`If-Match`字段用于和服务器资源的`ETag`值做比对，`ETag`值和`If-Match`字段的值相等时才会处理该请求。否则返回`412`状态码。还可以用星号（`*`）表示，这种情况下，服务器会忽略`ETag`的值，只要资源存在就处理请求。

```http
If-Match: "123456"
```

#### If-Modified-Since

`If-Modified-Since`用于确定代理服务器或客户端的本来资源的有效性。在指定的时间之后，请求的资源发生修改，就处理请求。如果在指定的时间之后，请求的资源都没有修改过，则返回`304`状态码。

#### If-None-Match

`If-None-Match`和`If-Match`相反，只有服务器资源的`ETag`值和`If-None-Match`不一样时，才处理该请求。在`GET`和`HEAD`请求方法中加入该字段可以获取最新的资源。

#### If-Range

`If-Range`用于告诉服务器，如果`If-Range`字段的值和请求资源的`ETag`值或者时间一样时，那么就作为范围请求处理（`Range`字段规定请求多少字节的数据）。否则，忽略范围请求，返回全部资源。

#### If-Unmodified-Since

`If-Unmodified-Since`字段用来告诉服务器，只有当请求资源在指定的时间之后没有进行修改的情况下，才处理请求。如果在指定的时间后发生了修改，则返回`412`状态码。

#### Proxy-Authorization

`Proxy-Authorization`字段包含了用户代理提供给代理服务器的用于身份验证的凭证。

#### Range

`Range`用于告诉服务器，返回文件的哪一部分。服务器接收到带有`Range`字段的请求后，会在处理请求之后返回`206`状态码。如果无法处理范围请求，则会返回`200`状态码并将全部资源返回。

```http
Range: bytes=5001-10000 <!-- bytes=5001-10000为资源的字节 -->
```

#### Referer

`Referer`字段告诉服务器，请求的原始资源的 URL。服务器端一般用`Referer`字段来识别访问来源，可能会以此进行统计分析、日志记录和缓存优化。

#### TE

`TE`用来告诉服务器端，客户端能够处理响应的传输编码方式以及相对优先级。

#### User-Agent

`User-Agent`字段用于把请求的浏览器和用户代理名称等信息传给服务器。

### 响应头字段

#### Accept-Ranges

`Accept-Ranges`用于告诉客户端，服务器端能处理指定范围内的资源。有两个值：`bytes`和`none`。`none`表示不能处理指定范围内的资源。

```http
Accept-Ranges: bytes
```

#### Age

`Age`用于告诉客户端，源服务器在多久前返回过资源。单位为秒。

#### ETag

`ETag`表示资源的特定标识符，服务器会为每份资源都分配对应的`ETag`值。当资源发生变化时，`ETag`的值也会改变。比如，访问同一个 URL 的网站同时有中文版和英文版，当点击中文时，会返回中文版的资源（`ETag: user-chi`），而点击英文版时，返回的是英文版的资源（`ETag: user-US`）。

##### 强 ETag 和弱 ETag

##### 强 ETag 值

强 ETag 值，不管资源发生多细微的裱花都会改变其值。

```http
ETag: "user-123456"
```

##### 弱 ETag 值

弱 ETag 值只用于资源是否相同。只有资源发生了根本改变，产生差异时才会改变`ETag`值。字段值最开始会添加`W/`。

```http
ETag: W/"user-123456"
```

#### Location

`Location`字段表示的是需要将页面重定向到某个地址，一般都是响应码为`3xx`的响应才有用。

#### Proxy-Authenticate

`Proxy-Authenticate`字段用于告诉客户端，获取代理服务器的资源要通过身份验证的方式。

#### Retry-After

`Retry-After`字段用于告诉客户端，应该在多久之后再次请求。配合`503`和`3xx`状态码响应一起使用。

#### Server

`Server`字段表示处理请求的源服务器所用到的软件相关信息。

#### Vary

`Vary`字段可以对缓存进行控制。从代理服务器收到源服务器返回含有`Vary`指定项的响应后，如果要进行缓存，只对请求中含有相同`Vary`指定头部字段的请求返回缓存。即使对相同资源发起请求，如果`Vary`指定的头部字段不相同，那么就必须从源服务器重新获取资源。

```http
Vary: Accept-Language <!-- 只对持有相同自然语言Accept-Language的请求返回缓存 -->
```

#### WWW-Authenticate

`WWW-Authenticate`响应头定义了使用哪种验证方式去获取对资源的连接。状态码`401`响应中，都有带有该字段。

### 实体头部字段

#### Allow

`Allow`用于通知客户端，资源所支持的 HTTP 方法。如果服务器收到不支持的 HTTP 方法时，会返回`405`状态码作响应。

#### Content-Encoding

`Content-Encoding`用于告诉客户端，服务器对实体的主体部分用的内容编码方式。内容编码在`Accept-Encoding`已经介绍过，一共有`4`种。

#### Content-Language

`Content-Language`字段用于告诉客户端，实体主体使用的自然语言。

```http
Content-Language: zh-CN
```

#### Content-Length

`Content-Length`表示实体主体部分的大小。以字节为单位。

#### Content-Location

`Content-Location`字段指的是要返回的数据的地址。

```http
Content-Length: 10000
```

#### Content-Range

`Content-Range`显示的是一个数据片段在整个文件中的位置。

```http
Content-Range: bytes 5001-10000/10000
```

#### Content-Type

`Content-Type`字段说明了实体主体中对象的媒体类型。

```http
Content-Type: text/html; charset=UTF-8
```

#### Expires

`Expires`字段会把资源失效的日期告诉客户端。在这个日期后，资源过期。也就是说，在指定的日期内可以从缓存获取资源，如果超过了这个时间，就向服务器请求资源。如果头部存在`Cache-Control: max-age`时，会优先处理`max-age`指令。

#### Last-Modified

`Last-Modified`字段表示最后修改资源的时间。

#### End-to-end 头部和 Hop-by-hop 首部

HTTP 头部字段将定义成缓存代理和非缓存代理。分成两种类型。

- 端到端头部（End-to-end）
  分在这个类别中的头部会转发给请求或响应对应的最终接收目标，而且必须保存在由缓存生成的响应中，另外规定它必须被转发。

- 逐跳首部（Hop-by-hop）
  分在这个类别中的头部只对单次转发有效，会因通过缓存或代理而不转发。在 HTTP 1.1 和之后的版本中，如果使用 Hop-by-hop 头部，就要提供 Connection 头部字段。

除了以下 8 个头部字段外，其他所有字段都属于端到端头部。

- `Connection`
- `Keep-Alive`
- `Proxy-Authenticate`
- `Proxy-Authorization`
- `Trailer`
- `TE`
- `Transfer-Encoding`
- `Upgrade`

## Cookie

在讲 `Cookie` 头字段之前，先来聊聊`Cookie`的作用。前面也说了，HTTP 是无状态的协议，它不会对之前发生过的请求和响应的状态进行管理。假设，客户端的用户发送一个请求，服务端收到请求后想知道这个请求是哪个用户发的，那么要有一个状态进行管理。这时就需要用到`Cookie`来记录到底是哪个家伙发送的请求。`Cookie`通过在请求和响应头信息中写入`Cookie`信息来控制客户端的状态。

从服务器端发送的响应头信息中有一个`Set-Cookie`的字段信息，告诉客户端保存`Cookie`。在下次客户端向服务器端发送请求时，客户端会自动在请求头信息中加入`Cookie`的值发送出去。

服务器端收到客户端发送过来的`Cookie`之后，会检查到底是从哪个客户端发过来的请求，然后对比服务器上的记录，最后就得到了之前的状态信息。

#### Set-Cookie

`Set-Cookie`是属于响应头部中的一个字段，它包含以下的值。

- `NAME=VALUE`：`Cookie`的名称和值
- `expires=DATE`：`Cookie`的有效期。如果没设置有效期，默认为浏览器关闭前有效。
- `path=PATH`：把服务器上的文件目录作为`Cookie`的适用对象，如果没有设置，默认是文档所在的文件目录
- `domain=域名`：作为`Cookie`适用对象的域名，如果没有设置，默认是创建`Cookie`的服务器的域名。
- `Secure`：只在 HTTPS 时才会发送`Cookie`。
- `HttpOnly`：JavaScript 不能访问`Cookie`。主要为了防止跨站脚本攻击对 `Cookie` 的信息窃取。

#### Cookie

`Cookie`是请求头信息中的一个字段，它包含服务器通过`Set-Cookie`头部设置并存到客户端的值。如果接收到多个`Cookie`时，可以以多个`Cookie`形式发送回去。

## HTTP 缓存

HTTP 缓存算是前端经常接触的缓存机制之一，它分为强制缓存和协商缓存。主要用于加快资源获取速度，提高用户体验，减少网络传输，缓解服务器压力。

### 强缓存

对强缓存而言，如果浏览器判断请求的资源是在有效期内，可以直接从缓存中读取资源，不用向服务器端发送资源请求。由`Expires`、`Cache-Control`和`Pragma`这三个头部字段设置强缓存。

#### Expires

`Expires`字段的值是一个`GMT`的时间格式，把资源失效的日期告诉客户端，客户端收到带有该字段的响应体后进行缓存。之后客户端发起相同的资源请求，会用`Expires`的值和本地时间进行对比，如果该请求的本地时间小于`Expires`的值，可以直接使用缓存中的资源，不用向服务器发起请求。这就遇到了一个问题。如果修改了本地的时间，就导致客户端和服务器端的时间不一致，那么对于缓存过期的判断可能就无法和预期相符。`Expires`在三者中是优先级最低。

#### `Cache-Control`

`Cache-Control`头部字段是 HTTP 1.1 中新加入的属性，请求头和响应头双方都可以使用。下面列出它各端所具备的属性值。

- `public`：该资源可以被浏览器和代理服务器进行缓存。
- `private`：该资源只可以被浏览器缓存，其他都不可以。
- `no-cache`：不使用强缓存，强制向源服务器再次验证缓存的有效性。
- `no-store`：不使用任何缓存。每次都向服务器获取最新资源。
- `max-age`：缓存的资源没有超过指定的时间，客户端就从缓存中获取资源。以秒为单位。
- `s-maxage`：只适用于代理服务器，表示代理服务器中的过期时长，使用`s-maxage`后，会忽略`max-age`和`Expires`字段。

#### Pragma

`Pragma` 是用来向后兼容只支持 HTTP1.0 协议的缓存服务器，它的效果和 `Cache-Control: no-cache` 一样，如果`Pragma`和`Cache-Control`同时存在，前者的优先级比后者高。

#### 注意

在 Chrome 中返回`200`状态码有两种情况。

1. `memory cache`
   只要页面不关闭，都会从浏览器内存中读取资源。

2. `disk cache`
   从磁盘中读取缓存资源。

![]("./images/强缓存.jpg")

使用了强缓存之后，会出现一个问题，如果服务器端对资源进行了修改，客户端是不知道的，依然会使用缓存中的资源。可以通过 Ctrl + F5 对页面进行强制刷新。

### 协商缓存

协商缓存是在使用本地缓存之前，向服务器端发送一次 GET 请求，验证浏览器保存的本地资源是否已过期。

#### last-modified/if-unmodified-since

一般情况下是采用请求资源的最近一次修改时间戳来进行判断。来举个例子：假设客户端向服务器端请求一个 index.js 文件资源，为了让资源被再次请求时能通过协商缓存的机制使用本地缓存，那么首次返回该资源的响应头中包含一个`last-modified`的字段，该字段的值表示资源最终修改的时间。当刷新网页时，该资源使用的是协商缓存，浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次 GET 请求，进行缓存有效性的协商，这次的 GET 请求的请求头中包含一个`if-unmodified-since`字段，该字段的值是上次响应头中的`last-modified`字段的值。

服务器收到请求后会用该请求的资源当前修改时间和`if-unmodified-since`的值做对比，如果两者相等说明缓存没有过期，继续使用浏览器缓存。这时返回的响应状态码是`304`。

#### last-modified 的不足之处

`last-modified`也存在两个缺陷：

- 它只是根据资源最后的修改时间进行判断，虽然请求的文件资源进行了编辑，但是内容却没变，时间也会更新，这就导致了协商缓存时关于有效性的判断验证失效。就需要重新进行资源的请求。
- 由于文件资源修改的时间单位是秒，如果文件修改很频繁。比如，几百毫秒内修改一次，就无法识别出该文件资源的更新。

#### ETag/If-None-Match

为了弥补通过时间判断的不足，HTTP 1.1 加入了`ETag`（实体标签）的头信息。

`ETag`表示资源的特定标识符，类似于文件指纹。服务器会为每份资源都分配对应的`ETag`值。当资源发生变化时，`ETag`的值也会改变。比如，访问同一个 URL 的网站同时有中文版和英文版，当点击中文时，会返回中文版的资源（`ETag: user-chi`），而点击英文版时，返回的是英文版的资源（`ETag: user-US`）。

当响应头同时存在`last-modified`和`ETag`字段时，会以`ETag`为准。再次对该资源发送请求时，会把之前的响应头中`ETag`的值当作这次请求头中`If-None-Match`字段的值，提供给服务器进行缓存有效性验证。如果验证缓存有效，就返回`304`状态码响应重定向到本地缓存。

#### ETag 的不足之处

`ETag`的出现并不是`last-modified`替代方案，而是一种补充方案，它还是存在一些弊端的。

- 如果资源比较大，数量较多而且修改频繁的话，那么生成`ETag`的过程就会影响到服务器的性能。
- `ETag`还有强`ETag`值和弱`ETag`值之分。
  - 强`ETag`值是根据资源内容进行生成，保证每个字节都相同。
  - 弱`ETag`值是根据资源的部分属性值来生成，生成速度快但无法保证每个字节都相同。

### 总结

1. 首先通过`Cache-Control`查看，是否启用了强缓存。如果启动了强缓存则从缓存中获取资源，返回`200`状态码。
2. 否则，进入协商缓存，发起 GET 请求，服务器通过`if-unmodified-since/If-None-Match`请求头字段检查资源是否有更新。
3. 如果没有，则返回`304`状态码，告诉浏览器资源没更新，可以从缓存中获取资源。
4. 否则返回资源，状态码为`200`。

## HTTP 的不足

HTTP 的主要不足之处有以下几点。

- **通信使用明文，内容会被窃听**
- **不验证通信方的身份，所以可能遭遇伪装**
- **无法证明报文的完整性，所以可能已遭到篡改**

### 通信使用明文，内容会被窃听

HTTP 协议本身没有加密的功能，所以无法做到对通信请求和响应内容进行加密。

#### TCP/IP 是会被窃听的网络

由于 TCP/IP 协议的工作机制，通信内容在所有通信线路上都有可能遭到窥视。不管是世界的哪个角落的服务器在跟客户端进行通信，通信的线路上的一些设备都不可能是个人的物品。所以不排除在某个环节上遭到恶意窥视的行为。即使进行加密处理，也会被窥视到通信内容。窃听相同段上的通信并不是难事，只需要收集在网络上流动的数据包就行。对于收集来的数据包的解析工作，可以使用抓包和嗅探器工具。

#### 解决方案：加密处理防止被窃听

最常见的两种加密方式是通信加密和内容加密。

##### 通信加密

HTTP 协议中本身没有加密机制，但可以通过 SSL（Secure Socket Layer 安全套阶层） 或 TLS（Transport Layer Security 安全传输层协议） 的组合使用，加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信。和 SSL 组合使用的 HTTP 叫做 HTTPS（HTTP Secure 超文本传输安全协议）或 HTTP over SSL。

##### 内容加密

由于 HTTP 协议中没有加密机制，那就对 HTTP 协议传输的内容本身加密。也就是把 HTTP 报文中所包含的内容进行加密处理。在这种情况下，客户端需要对 HTTP 报文主体（`body`）进行加密处理后再发送请求。

要做到内容的加密，前提是客户端和服务器同时具备加密和解密的机制，主要应用在 Web 服务。该方式不同于 SSL 或 TLS 把整个通信路线加密处理，所以内容仍然有被篡改的可能。

### 不验证通信方的身份可能遭遇伪装

HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在服务器是否就是发送请求中 URL 真正的指定主机，返回的响应是否真的返回实际提出请求的客户端等问题。

#### 任何人都可以发起请求

在 HTTP 协议通信时，由于不存在确认同新方的处理步骤，任何人都可以发起请求。服务器只要接收到请求，不管对方是谁都会返回一个响应（仅限发送端的 IP 地址和端口号没被 Web 服务器设定限制访问的前提下）。也就是来者不拒。

HTTP 协议的实现本身很简单，不管是谁发送过来的请求都会返回响应，因此不确认通信方，会存在下面几点问题。

- 无法确定请求发送到目标的 Web 服务器是否是按照真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。
- 无法确定响应返回到的客户端是否是按照真实意图接收响应的那个客户端。有可能是已伪装的客户端。
- 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存有重要的信息，只想发给特定用户通信的权限。
- 无法判断请求是来自哪里、出自谁手。
- 即使是无意义的请求也会照单全收。无法阻止大量请求下的 DoS 攻击（Denial of Service，拒绝服务器攻击）。

#### 解决方案：查明对方的证书

虽然使用 HTTP 协议无法确定通信方，但使用 SSL 可以。SSL 不仅提供加密处理，还使用了一种证书的手段，可用于确认通信方。证书是由值得信任的第三方机构颁发，用来证明服务器和客户端是真实存在的。

通过使用证书，以证明通信方就是意料中的服务器，对使用的个人来说，减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。

### 无法证明报文完整性，可能已篡改

#### 收到的内容可能有误

没有任何办法确认，发出去的请求或响应和接收到的请求或响应是前后相同的。有可能在中途已经被篡改为其他的内容，即使内容是真的被改了，接收方也无法察觉得到。

#### 解决方案：如何防止篡改

可以通过 MD5 和 SHA-1 等散列值校验方法，以及用来确认文件的数字签名方法（PGP 签名）。但是用这些方法也无法保证正确。因为 MD5 和 PGP 本身被修改的话，用户也无法意识到。

## HTTPS

### HTTP + 加密 + 认证 + 完整性保护 = HTTPS

HTTP 加上加密处理和认证以及完整性保护机制就是 HTTPS。

### HTTPS 是身披 SSL 外壳的 HTTP

HTTPS 不是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。之前是 HTTP 和 TCP 进行通信，在使用 SSL 后，就变成了 HTTP 先和 SSL 通信，之后 SSL 和 TCP 通信。

![]("./images/HTTPS.png");

用了 SSL 后，HTTP 就有了 HTTPS 的加密、证书、和完成保护性这些功能。

### 加密方式

SSL 用的是公开密钥加密的处理方式。加密方法中的加密算法是公开的，密钥则是保密的。通过这种方式可以保持加密方法的安全性。

加密和解密都会用到密钥。没有密钥就没办法对密码解密，任何人只要有密钥就可以进行解密，如果密钥被攻击者获得，那么加密就失去了意义。

#### 对称加密

加密和解密同用一个密钥的方式叫做共享密钥加密。也叫对称密钥加密。也就是说，客户端和服务器端共用一个密钥来对消息进行加密，客户端在发送消息时，用密钥对消息加密。服务器端收到之后，再用密钥对消息进行解密。

##### 缺点

共享加密虽然保证了消息保密性，但客户端和服务器端用的都是同一个密钥，如果说传输的过程出现了中间人或者攻击者，密钥就有可能落到攻击者的手中，这样就失去了加密的意义。

#### 非对称加密

公开密钥加密方式解决了共享密钥加密的缺点。公开密钥加密用的是一对非对称的密钥，一把叫做私有密钥，另一把叫做公开密钥。私有密钥只能是自己持有，而公开密钥则是任何人都可以拿到。

当客户端发送消息前，使用公共密钥进行加密，而服务器收到消息后，使用私有密钥进行解密。

##### 缺点

非对称加密需要在发送端在发送消息时，用公钥加密。但公钥是任何人都可以拿到，中间人也可以。中间人虽然不知道接收方的私钥是什么，但可以截获发送端的公钥，自己另外生成一把公钥或者篡改公钥，把公钥发给接收端。而且公密处理起来要比共享密钥加密方式更加复杂，这样就导致了效率极低。

#### 混合加密机制

HTTPS 采用了对称加密和非对称加密两者并用的混合加密。使用对称加密的好处是解密的效率快，使用非对称加密的好处是在传输的消息过程中不能被破解。即使截获了数据，没有相应的私钥
，也不能对消息进行破解。所以充分利用各自的优势，把多种方法组合起来用于传输数据。在交换密钥时使用非对称加密方式，之后的建立通信交换报文阶段使用对称加密方式。

### 摘要算法

数字摘要是采用 Hash 函数把需要加密的明文 “摘要”成一串固定长度（128 位）的密文，这串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同，而同样的明文摘要必须一致。数字摘要是 HTTPS 能确保数据完成行和防篡改的根本原因。

### 数字签名

数字签名是非对称密钥加密和数字摘要两项技术的应用，它将摘要信息用发送者的私钥加密，和原文一起发送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 Hash 函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果一样，那就说明收到的信息是完整的。否则说明信息被修改过，因此数字签名能够验证信息的完整性。

#### 签名是加密的校验码

数字签名是附加在报文上的特殊加密校验码。使用数字签名有以下两点好处。

- 签名能确定消息是由发送方签名并发过来的，因为别人假冒不了发送方的签名。
- 签名能确定消息的完整性，证明数据没有被篡改过。

数字签名的过程如下：

`明文 -> hash运算 -> 摘要 -> 私钥加密 -> 数字签名`

### 数字证书

数字证书（CA）就像我们人的身份证一样，其中的信息都是唯一的，它是属于可信任的一些第三方机构所有。证书包含了以下的信息。

- 证书的发布机构 CA
- 证书的有效期
- 公钥
- 证书所有者
- 签名

数字证书还包括对象的公钥，对象和所用签名算法的描述信息。所有人都可以创建一个数字证书，但并不是所有人都能获得签发权，从而为证书信息担保，并用它私有密钥签发证书。

<!-- ### HTTPS 的通信机制

1. 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的版本、加密组件列表。

2. 服务器通过 SSL 通信时，以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本之类的东西。加密组件内容是从接收到的客户端加密组件中筛选出来的。

3. 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。

4. 最后服务器发送 Serve Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。

5. SSL 第一次握手结束后，客户端以 Client Key Exchange 报文做回应。报文中包含通信加密使用的随机密码串。

6. 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用密钥加密。

7. 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否成功，要以服务器是否能够正确解密该报文作为判定标准。

8. 服务器同样发送 Change Cipher Spec 报文。

9. 服务器同样发送 Finished 报文。

10. 服务器和客户端的 Finished 报文交换完毕后，SSL 连接就建立完成。之后就开始了 HTTP 请求。

11. 应用层协议通信，发送 HTTP 响应。

12. 最后由客户端断开连接。同时，发送`close_notify`报文。这步之后进入 TCP 的四次挥手阶段。关闭通信。 -->

### HTTPS 的工作流程

1. 首先是客户端向服务器端发起一个 HTTPS 请求。
2. 服务器端返回公钥证书给客户端。
3. 客户端收到公钥证书后，用证书的公钥验证数字签名，以确认服务器的公钥的真实性。
4. 客户端用随机数生成器生成临时的会话密钥，然后用服务器的公钥对该会话密钥进行加密，发送给服务器端。
5. 服务器端收到后，用自己的私钥对会话密钥解密。
6. 之后客户端和服务器端就开始了 HTTPS 通信。

> 注意一点，HTTP 的默认端口号为 80。HTTPS 的默认端口号则是 443。

### SSL 和 TSL

HTTPS 用的是 SL（Secure Socket Layer 安全套阶层） 和 TLS（Transport Layer Security 安全传输层协议）这两个协议。SSL 最开始是由网景先倡导，后来网景崩盘了，就转移给了 IETF 的手里。IETF 以 SSL3.0 为准，之后又定制了 TLS1.0、TLS1.1 和 TLS1.2。TSL 是以 SSL 为原型开发的协议，有时候统一称该协议为 SSL。

### 为什么不一直用 HTTPS

凡事具有两面性，不是说 HTTPS 安全了就没有问题了，其实它还是存在一些问题的。在使用 SSL 时，它的处理速度会变慢。它变慢的原因有两种，一是通信慢，二是每次都进行加密通信就会消耗大量的 CPU 和内存资源，导致处理速度变慢。

- 除了和 TCP 连接、发送请求和响应之外，还要和 SSL 进行通信。
- 另外是 SSL 要进行加密处理，在服务器和客户端都要进行加密和解密的运算处理。
- 要进行 HTTPS 通信，购买证书是必不可少的。

当然可以用 SSL 加速（专用服务器）硬件来改善这个问题。可以提高 SSL 的计算速度，分担负载。但只有在 SSL 处理时发挥 SSL 加速器的功效。像一些非敏感的信息就用 HTTP 进行通信，对于敏感信息才用 HTTPS 通信，以节约资源。

## HTTP 和 HTTPS 的区别

1. HTTP 是以明文的方式进行传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
2. HTTP 和 HTTPS 用的是两种不同的方式进行连接，用的端口号也不一样，前者是 80，而后者是 443。
3. HTTPS 需要购买证书（CA），而免费的证书一般很少，所以需要支付一定的费用。
4. HTTPS 对搜索引擎更加友好，有利于 SEO，优先索引 HTTPS 的网页。
5. HTTP 的连接简单，是无状态的。HTTPS 是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议更安全。

## HTTP2.0

HTTP2.0 的出现解决了 HTTP1.x 的一些瓶颈。

### HTTP1.x 的缺点

HTTP1.x 主要有以下几个缺点：

1. HTTP1.0 只允许在一个 TCP 连接上只能发送一个请求，HTTP1.1 中默认允许多个 TCP 连接，但是同一个 TCP 连接中，所有数据通信都是按次序进行的，服务器一般都是处理完一个响应之后，再继续处理下一个，这就造成了队首阻塞问题。
2. 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
3. 请求/响应头部不进行压缩就发送。头部信息越多延迟越大。
4. 发送冗长的头部，每次互相发送相同的头部造成的浪费较多。
5. 可随意选择数据压缩格式，非强制压缩发送。

### 解决 HTTP1.x 瓶颈的 SPDY

SPDY 是由谷歌开发的基于 TCP 协议的应用层协议。目标是为了优化 HTTP 协议的性能，通过压缩、多路福永和优先级技术，缩短网页的加载时间并提高安全性。SPDY 协议的核心思想是尽量减少 TCP 的连接数。SPDY 并不是一种代替 HTTP 的协议，而是对 HTTP 协议的增强。

SPDY 没有改写 HTTP 协议，而是在 TCP/IP 的应用层和传输层之间通过新加会话层的形式运作。同时，考虑到安全问题，SPDY 规定通信中使用 SSL。

![]("./images/SPDY.jpg")

SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可以照常使用 HTTP 的请求方法、Cookie 以及 HTTP 报文等。

### HTTP2.0 新增功能

下面就简单的介绍一下 HTTP2.0 新增的功能。之后我会用一篇文章单独讲讲 HTTP2.0。

- **二进制分帧层**：HTTP2.0 性能增强的核心是新增的二进制分帧层，HTTP1.x 是以换行符作为纯文本的分隔符，而 HTTP2.0 将所有传输的信息分割成更小的消息和帧，并对它们采用二进制格式的编码。

- **多向请求和响应**：HTTP2.0 中新的二进制分帧层，将 HTTP 消息分解成独立的帧，交错发送，然后在另一端根据流标识符和头部把它们重新组装。解决了 HTTP1.x 中的队首阻塞问题。

- **请求优先级**：把 HTTP 消息分解成很多独立的帧后，就可以通过优化这些帧的交错和传输顺序，进一步优化性能。

- **服务器推送**：服务器可以对一个客户端请求发送多个响应。服务器还可以向客户端推送资源而且无需客户端明确的请求。

- **头部压缩**：在 HTTP2.0 中，使用了 HPACK（HTTP2 头部压缩算法）压缩格式对传输的头部进行编码，减少了头部的大小。并在两端维护了索引表，用于记录出现过的头部，后面在传输过程中就可以传输已经记录过的头部的键名，对端收到数据后就可以通过键名找到对应的值。

## 参考

- [《图解 HTTP》]("https://book.douban.com/subject/25863515/")
