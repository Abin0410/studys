## HTTP 诞生

HTTP 译为 "超文本传输协议"，诞生于 1989 年 3 月。是一位名叫蒂姆伯纳斯-李这位哥儿们提出的，最初设想的基本理念是：借助多文档之间相互关联形成的超文本，连成可相互参阅的 W W W（World Wide Web，万维网）。 W W W 简称 Web。

HTTP 0.9 在 1990 年问世。那时的 HTTP 还没有作为正式的标准被建立。

HTTP 1.0 在 1996 年 5 月正式作为标准。现在该协议标准直到现在还被广泛使用在服务器端。

HTTP 1.1 在 1997 年 1 月公布为目前主流的 HTTP 协议版本。

## TCP/IP

一般使用的网络（包括互联网）是在 TCP/IP 协议的基础上运作的。HTTP 属于它内部的一个子集。

计算机和网络设备要互相通信，双方都必须基于相同的方法。例如，如何探测到通信目标、是哪一边先发起通信、使用哪种语言进行通信、怎么样结束通信等规则都是需要先确定的。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而这种规则称为协议。

协议中包括：从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。把这些相关联的协议集合起来总称为 TCP/IP。

TCP/IP 重要的点就是分层。有以下 4 层：应用层、传输层、网络层和数据链路层。

### TCP/IP 各层作用

#### 应用层

应用层决定了向用户提供应用服务是通信的活动。比如，FTP 文件传输协议和 DNS。HTTP 协议也在该层。

#### 传输层

传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。该层有两个不同的协议：TCP 传输控制协议和 UDP 用户数据报协议。

#### 网络层

网络层用来处理在网络上流动的数据包。

#### 数据链路层

用来处理连接网络的硬件部分。

TCP/IP 层次化的好处是：如果互联网由一个协议统一规划，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层只需要把变动的层替换掉。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动。层次化之后，处于应用层的应用可以只考虑分派给自己的任务，不需要其他问题。

### TCP/IP 通信传输流

TCP/ IP 协议进行通信时，会通过分层顺序和对方进行通信。客户端从应用层往下走，接收端则从链路层往上走。举个例子：

1. 首先客户端在应用层发出一个想看某个 Web 页面的 HTTP 请求。
2. 接着，在传输层把应用层接收到的数据进行分割，在每个报文上打上标记好以及端口号后转发给网络层。
3. 在网络层，将 MAC 地址转发给链路层。
4. 接收端的服务器在链路层接收到数据后，按次序往上层发送，直到应用层。传输到应用层才算真正接收到客户端发过来的 HTTP 请求。

看下图展示整过过程。
![](./images/1/1.3.1.jpg)

客户端在每层传输数据的时候，每经过一层就会打上一个该层的首部信息。而接收层在每层传输数据的时候，每经过一层都会把对应的首部去除。

## IP、TCP 和 DNS

IP、TCP 和 DNS 这三个协议，都是和 HTTP 密不可分的。

### IP 网络协议

IP 地址指的是节点被分配到的地址，MAC 地址指的是网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址是可变的，MAC 地址是不可变的。

### ARP 协议

IP 间的通信依赖 MAC 地址。在网络上通信的双方在同一局域网内的情况很少，一般都是经过多台计算机或者网络设备中转才能连接到对方。而在中转时，会利用
下一站中转设备的 MAC 地址进行搜索下一个中转目标。而这时，会采用 ARP 协议。ARP 协议是一种用来解析的地址的协议，通过通信方的 IP 地址就能反查出
对应的 MAC 地址。

在到达通信目标前的中转过程中，计算机和路由器只能获取很粗略的传输路线。这种机制叫做路由选择。

### 可靠性的 TCP 协议

TCP 位于传输层，提供可靠性的字节流服务。字节流服务指的是，为了方便传输，将大块数据分割以报文段为单位的数据包进行管理。而可靠性的传输服务指的是，能
把数据准确可靠地传给对方。

为了准确地把数据传送给对方，这时 TCP 协议的三次握手就出现了。

- 第一次握手：发送端先发送一个带 SYN 标志的数据包给对方。
- 第二次握手：接收端收到之后，回传一个带有 SYN/ACK 标志的数据包表示传达确认信息。
- 第三次握手：最后，发送端再传回一个带 ACK 标志的数据包，表示 “握手” 结束。

下图展示这个过程。

![](./images/1/1.4.1.jpg)

### DNS 服务

DNS 服务是和 HTTP 协议一样，位于应用层。它的作用是，将域名解析成 IP 地址。DNS 协议可以通过域名查找 IP 地址，也可以通过 IP 地址反查域名的服务。
![](./images/1/1-5-1.jpg)

下图展示每个协议跟 HTTP 协议的关系。
![](./images/1/1-6-1.jpg)

## URI 和 URL

### 什么是 URI

**URL**（统一资源定位符） 是访问 Web 页面需要输入的网站地址。例如，`http://www.tutu.com/`就是 **URL**。

**URI**（统一资源标识符）。全称叫 `Uniform Resource Locator`。 它的作用是区分互联网上不同的资源，而 **URL** 表示资源的地点。URL 是 URI 的子集。

### URI 格式

`http://user:pass@www.tutu.com:8080/html/index.html?userId=1#cn1`

- **协议名**：`http:`或`https:`表示协议名称。不区分字母大小写，最后要加上`://`。
- **登录信息**：**user:pass@** 表示获取服务器资源的用户名和密码。不推荐使用，不安全，也没用过。
- **服务器地址**：服务器地址可以是三种：
  - 以域名的形式`www.tutu.com`；
  - 以 IPv4 `192.168.0.1`地址名；
  - 以`[0:0:0:0:0:0:1]`这种方括号括起来 IPv6 地址名；
- **服务器端口**：`:8080`表示端口号。
- **文件路径**：`/html/index.html`指的是服务器文件路径，资源的访问位置。
- **查询字符串**：`?userId=1`指的是文件路径中参数。`?`后面以`key=value`的形式。如果后面还需要加参数，用`&`拼接。
- **片段标识符**：`#cn1`指的是文件中的某个位置。相当于一个锚点。

## HTTP 基础

HTTP 是一种无状态的协议，对发送过的请求或响应都不做持久化处理。它不对之前发生过的请求和响应的状态进行管理。

### HTTP 报文

HTTP 一共有两种报文：请求报文、响应报文，而报文可分为报文头部和报文主体。但不一定要有报文主体。下图展示这两种报文的结构。

客户端的 HTTP 报文叫做请求报文。

![]("./images/请求报文.jpg")

服务器端的 HTTP 报文 叫做响应报文。

![]("./images/响应报文.jpg")

这两种报文都由以下数据所组成。

#### 请求行

请求行由三部分组成：请求方法、请求 URL（不包括域名） 和 HTTP 协议版本。

#### 状态行

状态行包括响应结果和状态码，原因短语和 HTTP 版本。

#### 头信息

头信息包括了请求和响应的各种条件和属性的各类头部。一般有 4 种头部：通用头部、请求头部、响应头部和实体头部。

#### 其他

可能会包含 HTTP 的 RFC 里未定义的头部。

### HTTP 的请求方法

- GET：获取服务器资源。
- POST：提交信息给服务器。
- PUT：传输文件。
- HEAD：和 GET 方法一样，但是只返回响应首部。作用是确定 URL 的有效性和资源更新的日期时间。
- DELETE：按请求的 URL 删除指定的资源。
- OPTIONS：查询请求服务器指定的资源支持的方法。
- TRACE：用来确认连接过程中发生的一些操作。
- CONNECT：建立连接渠道，用于代理服务器。

### 持久化连接

HTTP 1.1 中的所有连接都是默认开启的，而在 HTTP1.0 中是默认关闭的。它的特点是，只要有一端没有提出断开连接，那么就会保持 TCP 连接状态。好处是，减少 TCP 连接的重复建立和断开连接造成的额外开销，减轻服务器压力。这样可以使得 HTTP 请求和响应更快结束，也提高了页面的显示速度。

### 管线化

管线化不用等待响应即可发送下一个请求。也就是并行处理，不用一个接一个的等待响应，管线化比持久化连接要还要快。但现在这项技术并没有成熟。

## HTTP 请求头和响应头的通用信息

下面列出请求报文和响应报文都会用到的一些信息。

### Cache-Control

通过`Cache-Control`字段，可以进行缓存的操作。参数都是可选的，如果有多个参数的话，以`，`分隔开。

#### 客户端

在请求中使用到`Cache-Control`时，它的可选值：

- `no-cache`：不接收缓存过的响应，要求直接向源服务器发起请求。
- `no-store`：不使用任何缓存。
- `max-age`：如果缓存资源的时间没有超过指定的时间，客户端从缓存中获取资源。以秒为单位。
- `min-fresh`：要求服务器返回还没过指定时间的缓存资源。以秒为单位。
- `max-stale`：即使是过期的资源，也照样接收。
- `only-if-cached`：告诉服务器，从缓存中获取资源（如果有）。
- `no-transform`：不能对资源进行转换。这样做可以防止缓存或代理压缩图片等类似操作。

#### 服务器端

在响应中使用到`Cache-Control`时，它的可选值：

- `public`：不管是浏览器还是代理服务器都可以缓存。
- `private`：资源只能被浏览器缓存。
- `no-cache`：可以缓存，但每次使用前要向源服务器进行验证缓存的有效性。
- `no-store`：不使用任何缓存。
- `s-maxage`：只适用于代理服务器，表示代理服务器中的过期时长，私有缓存会忽略它，使用`s-maxage`后，会忽略`max-age`和`Expires`字段。
- `max-age`：设置缓存时间，如果没有超过该时间，不需要进行请求。如果超过该时间，被视为资源已过期。以秒为单位。如果响应头出现 Expires 字段，在 HTTP1.1 中会优先处理`max-age`，而 HTTP1.0 中则相反。
- `must-revalidate`：可以缓存，但必须向源服务器再次验证。如果请求失败，则返回 504。`must-revalidate`会忽略`max-stale`。
- `proxy-revalidate`：要求缓存服务器对缓存的响应有效性进行确认。
- `no-transform`：不能对资源进行转换。这样做可以防止缓存或代理压缩图片等类似操作。

### Connection

`Connection`字段可以管理持久化连接。 有两个值：`keep-Alive`和`close`，`keep-Alice`表示持久连接。而`close`表示关闭该连接。

### Date

`Date`字段表示 HTTP 报文创建的时间和日期。

### Pragma

`Pragma` 是用来向后兼容只支持 HTTP1.0 协议的缓存服务器。它的效果和`Cache-Control: no-cache`一样。

### Transfer-Encoding

`Transfer-Encoding`规定了传输报文主体时采用的编码方式。

- `chunked`：数据以分块的形式进行发送。
- `compress`：UNIX 系统的标准压缩算法。
- `gzip`：`GNU gzip`
- `deflate`：使用`zlib`结构。
- `identity`：不进行编码。

### Upgrade

`Upgrade`用于查看 HTTP 协议或者其他协议是否可以使用更高的版本进行通信。

### Via

`Via`用于跟踪客户端与服务端之间的请求和响应报文的传输路径，可以避免请求循环的发生。

### Warning

`Warning`是告诉用户一些跟缓存相关的问题警告。格式如下：

```http
Waring：警告码 [警告的主机: 端口号] ["警告内容"] [日期时间]
```

警告码如下所示：

- `110`（Response Is Stale）：缓存服务器返回的资源已过期
- `111`（Revalidation Failed）：无法访问服务器，验证资源有效性失败
- `112`（Disconnected Operation）：缓存服务器切断连接
- `113`（Heuristic Expiration）：响应的使用期超过 24 小时（有效缓存的设置时间大于 24 小时的情况下）
- `199`（Miscellaneous Warning）：任意的警告内容
- `214`（Transformation Applied）：代理服务器对内容编码或媒体类型执行了某些处理时
- `299`（Miscellaneous Warning）：和`199`类似，只不过指的是持久化警告

## 请求头字段

### Accept

`Accept`请求头用来告诉服务器，客户端可以处理的内容类型。下面列出几种媒体类型。

- 文本文件

  `text/html`、`text/plain`、`text/css`、`application/xhtml+xml`、`application/xml`等。

- 图片文件

  `image/jpeg`、`image/gif`、`image/png`

- 视频文件

  `video/mpeg`、`video/quicktime`

- 二进制文件

  `application/octet-stream`、`application/zip`等

当值为`*/*`，表示客户端可以是任意内容类型。当值为`image/*`，可以用来指代任何其他图片类型。

如果想给显示的谋体类型增加优先级，通过用`q=`表示权重值，用分号（`;`）分隔开。权重值的范围是`0~1`，可以精确到小数点后`3`位，`1`是最大值。没有指定权重`q`值时，默认权重是`q=1.0`。

```http
Accept: text/html, application/json;q=0.9
```

### Accept-Charset

`Accept-Charset`请求头用来告诉服务器，客户端可以处理的字符集类型。另外，可以一次性指定多种字符集。和`Accept`一样，通过`q`值来表示优先级。该头部应用于内容协商机制的服务器驱动协商。

```http
Accept-Charset: iso-8859-1

Accept-Charset: iso-8859-1;q=0.5
```

### Accept-Encoding

`Accept-Encoding`请求头用来告诉服务器，客户端能理解的内容编码方式。可以一次性指定多种内容编码。

下面列出几种内容编码例子。

- gzip
  由文件压缩程序 gzip 生成的编码格式，使用 Lempel-Ziv 算法及 32 位循环冗余验证。

- compress
  由 UNIX 文件压缩程序`compress`生成的编码格式，采用 Lempel-Ziv-Welch 算法。

- deflate
  组合使用 zlib 格式以及有`deflate`压缩算法生成的编码格式。

- identity
  不执行压缩或不会变化的默认编码格式。

```http
Accept-Encoding: gzip, deflate
```

和`Accept`一样，通过`q`值来表示优先级。还可以用星号（`*`），表示指定任意的编码格式。

### Accept-Language

`Accept-Language`请求头用来告诉服务器，客户端可以理解的自然语言集（指中文和英文等），以及自然语言级的优先级。可一次指定多种自然语言集。和`Accept`一样，用权重值`q`来表示优先级。

```http
zh-CN,zh;q=0.9,en;q=0.8
```

客户端在服务器有中文版资源的情况下，会请求并返回中文版对应的响应，如果没有中文版，那就返回英文版响应。

### Authorization

`Authorization`用来告诉服务器，用户代理的认证信息（证书值）。通常会在服务器返回`401`状态码响应后，将头部字段`Authorization`添加到请求中。

### Expect

`Expect`用来告诉服务器，只有在满足这个期望条件的情况下才能妥善地处理请求。如果服务器不能满足客户端的期望条件的话，会返回`417`状态码。目前只规定了`100-continue`这条期望条件。

```http
Expect: 100-continue
```

### From

`From`字段是用来告诉服务器，使用用户代理的用户的电子邮箱地址。

### Host

`Host`请求头指明了请求的资源所在的服务器主机名和端口号。

### If-Match

像`If-xxxx`这种样式的请求头字段，都是条件请求。服务器收到附带条件的请求之后，只有判断条件为真才会执行请求。

`If-Match`字段用于和服务器资源的`ETag`值做比对，`ETag`值和`If-Match`字段的值相等时才会处理该请求。否则返回`412`状态码。还可以用星号（`*`）表示，这种情况下，服务器会忽略`ETag`的值，只要资源存在就处理请求。

```http
If-Match: "123456"
```

### If-Modified-Since

`If-Modified-Since`用于确定代理服务器或客户端的本来资源的有效性。在指定的时间之后，请求的资源发生修改，就处理请求。如果在指定的时间之后，请求的资源都没有修改过，则返回`304`状态码。

### If-None-Match

`If-None-Match`和`If-Match`相反，只有服务器资源的`ETag`值和`If-None-Match`不一样时，才处理该请求。在`GET`和`HEAD`请求方法中加入该字段可以获取最新的资源。

### If-Range

`If-Range`用于告诉服务器，如果`If-Range`字段的值和请求资源的`ETag`值或者时间一样时，那么就作为范围请求处理（`Range`字段规定请求多少字节的数据）。否则，忽略范围请求，返回全部资源。

### If-Unmodified-Since

`If-Unmodified-Since`字段用来告诉服务器，只有当请求资源在指定的时间之后没有进行修改的情况下，才处理请求。如果在指定的时间后发生了修改，则返回`412`状态码。

### Proxy-Authorization

`Proxy-Authorization`字段包含了用户代理提供给代理服务器的用于身份验证的凭证。

### Range

`Range`用于告诉服务器，返回文件的哪一部分。服务器接收到带有`Range`字段的请求后，会在处理请求之后返回`206`状态码。如果无法处理范围请求，则会返回`200`状态码并将全部资源返回。

```http
Range: bytes=5001-10000 <!-- bytes=5001-10000为资源的字节 -->
```

### Referer

`Referer`字段告诉服务器，请求的原始资源的 URL。服务器端一般用`Referer`字段来识别访问来源，可能会以此进行统计分析、日志记录和缓存优化。

### TE

`TE`用来告诉服务器端，客户端能够处理响应的传输编码方式以及相对优先级。

### User-Agent

`User-Agent`字段用于把请求的浏览器和用户代理名称等信息传给服务器。

## 响应头字段

### Accept-Ranges

`Accept-Ranges`用于告诉客户端，服务器端能处理指定范围内的资源。有两个值：`bytes`和`none`。`none`表示不能处理指定范围内的资源。

```http
Accept-Ranges: bytes
```

### Age

`Age`用于告诉客户端，源服务器在多久前返回过资源。单位为秒。

### ETag

`ETag`表示资源的特定标识符，服务器会为每份资源都分配对应的`ETag`值。当资源发生变化时，`ETag`的值也会改变。比如，访问同一个 URL 的网站同时有中文版和英文版，当点击中文时，会返回中文版的资源（`ETag: user-chi`），而点击英文版时，返回的是英文版的资源（`ETag: user-US`）。

#### 强 ETag 和弱 ETag

##### 强 ETag 值

强 ETag 值，不管资源发生多细微的裱花都会改变其值。

```http
ETag: "user-123456"
```

##### 弱 ETag 值

弱 ETag 值只用于资源是否相同。只有资源发生了根本改变，产生差异时才会改变`ETag`值。字段值最开始会添加`W/`。

```http
ETag: W/"user-123456"
```

### Location

`Location`字段表示的是需要将页面重定向到某个地址，一般都是响应码为`3xx`的响应才有用。

### Proxy-Authenticate

`Proxy-Authenticate`字段用于告诉客户端，获取代理服务器的资源要通过身份验证的方式。

### Retry-After

`Retry-After`字段用于告诉客户端，应该在多久之后再次请求。配合`503`和`3xx`状态码响应一起使用。

### Server

`Server`字段表示处理请求的源服务器所用到的软件相关信息。

### Vary

`Vary`字段可以对缓存进行控制。从代理服务器收到源服务器返回含有`Vary`指定项的响应后，如果要进行缓存，只对请求中含有相同`Vary`指定头部字段的请求返回缓存。即使对相同资源发起请求，如果`Vary`指定的头部字段不相同，那么就必须从源服务器重新获取资源。

```http
Vary: Accept-Language <!-- 只对持有相同自然语言Accept-Language的请求返回缓存 -->
```

### WWW-Authenticate

`WWW-Authenticate`响应头定义了使用哪种验证方式去获取对资源的连接。状态码`401`响应中，都有带有该字段。

## 实体头部字段

### Allow

`Allow`用于通知客户端，资源所支持的 HTTP 方法。如果服务器收到不支持的 HTTP 方法时，会返回`405`状态码作响应。

### Content-Encoding

`Content-Encoding`用于告诉客户端，服务器对实体的主体部分用的内容编码方式。内容编码在`Accept-Encoding`已经介绍过，一共有`4`种。

### Content-Language

`Content-Language`字段用于告诉客户端，实体主体使用的自然语言。

```http
Content-Language: zh-CN
```

### Content-Length

`Content-Length`表示实体主体部分的大小。以字节为单位。

### Content-Location

`Content-Location`字段指的是要返回的数据的地址。

```http
Content-Length: 10000
```

### Content-Range

`Content-Range`显示的是一个数据片段在整个文件中的位置。

```http
Content-Range: bytes 5001-10000/10000
```

### Content-Type

`Content-Type`字段说明了实体主体中对象的媒体类型。

```http
Content-Type: text/html; charset=UTF-8
```

### Expires

`Expires`字段会把资源失效的日期告诉客户端。在这个日期后，资源过期。也就是说，在指定的日期内可以从缓存获取资源，如果超过了这个时间，就向服务器请求资源。如果头部存在`Cache-Control: max-age`时，会优先处理`max-age`指令。

### Last-Modified

`Last-Modified`字段表示最后修改资源的时间。

## Cookie

在讲 `Cookie` 头字段之前，先来聊聊`Cookie`的作用。前面也说了，HTTP 是无状态的协议，它不会对之前发生过的请求和响应的状态进行管理。假设，客户端的用户发送一个请求，服务端收到请求后想知道这个请求是哪个用户发的，那么要有一个状态进行管理。这时就需要用到`Cookie`来记录到底是哪个家伙发送的请求。`Cookie`通过在请求和响应头信息中写入`Cookie`信息来控制客户端的状态。

从服务器端发送的响应头信息中有一个`Set-Cookie`的字段信息，告诉客户端保存`Cookie`。在下次客户端向服务器端发送请求时，客户端会自动在请求头信息中加入`Cookie`的值发送出去。

服务器端收到客户端发送过来的`Cookie`之后，会检查到底是从哪个客户端发过来的请求，然后对比服务器上的记录，最后就得到了之前的状态信息。

### Set-Cookie

`Set-Cookie`是属于响应头部中的一个字段，它包含以下的值。

- `NAME=VALUE`：`Cookie`的名称和值
- `expires=DATE`：`Cookie`的有效期。如果没设置有效期，默认为浏览器关闭前有效。
- `path=PATH`：把服务器上的文件目录作为`Cookie`的适用对象，如果没有设置，默认是文档所在的文件目录
- `domain=域名`：作为`Cookie`适用对象的域名，如果没有设置，默认是创建`Cookie`的服务器的域名。
- `Secure`：只在 HTTPS 时才会发送`Cookie`。
- `HttpOnly`：JavaScript 不能访问`Cookie`。主要为了防止跨站脚本攻击对 `Cookie` 的信息窃取。

### Cookie

`Cookie`是请求头信息中的一个字段，它包含服务器通过`Set-Cookie`头部设置并存到客户端的值。如果接收到多个`Cookie`时，可以以多个`Cookie`形式发送回去。

## HTTP 缓存

HTTP 缓存算是前端经常接触的缓存机制之一，它分为强制缓存和协商缓存。主要用于加快资源获取速度，提高用户体验，减少网络传输，缓解服务器压力。

### 强缓存

对强缓存而言，如果浏览器判断请求的资源是在有效期内，可以直接从缓存中读取资源，不用向服务器端发送资源请求。由`Expires`、`Cache-Control`和`Pragma`这三个头部字段设置强缓存。

#### Expires

`Expires`字段的值是一个`GMT`的时间格式，把资源失效的日期告诉客户端，客户端收到带有该字段的响应体后进行缓存。之后客户端发起相同的资源请求，会用`Expires`的值和本地时间进行对比，如果该请求的本地时间小于`Expires`的值，可以直接使用缓存中的资源，不用向服务器发起请求。这就遇到了一个问题。如果修改了本地的时间，就导致客户端和服务器端的时间不一致，那么对于缓存过期的判断可能就无法和预期相符。`Expires`在三者中是优先级最低。

#### `Cache-Control`

`Cache-Control`头部字段是 HTTP 1.1 中新加入的属性，请求头和响应头双方都可以使用。下面列出它各端所具备的属性值。

- `public`：该资源可以被浏览器和代理服务器进行缓存。
- `private`：该资源只可以被浏览器缓存，其他都不可以。
- `no-cache`：不使用强缓存，强制向源服务器再次验证缓存的有效性。
- `no-store`：不使用任何缓存。每次都向服务器获取最新资源。
- `max-age`：缓存的资源没有超过指定的时间，客户端就从缓存中获取资源。以秒为单位。
- `s-maxage`：只适用于代理服务器，表示代理服务器中的过期时长，使用`s-maxage`后，会忽略`max-age`和`Expires`字段。

#### Pragma

`Pragma` 是用来向后兼容只支持 HTTP1.0 协议的缓存服务器，它的效果和 `Cache-Control: no-cache` 一样，如果`Pragma`和`Cache-Control`同时存在，前者的优先级比后者高。

#### 注意

在 Chrome 中返回`200`状态码有两种情况。

1. `memory cache`
   只要页面不关闭，都会从浏览器内存中读取资源。

2. `disk cache`
   从磁盘中读取缓存资源。

![]("./images/强缓存.jpg")

使用了强缓存之后，会出现一个问题，如果服务器端对资源进行了修改，客户端是不知道的，依然会使用缓存中的资源。可以通过 Ctrl + F5 对页面进行强制刷新。

### 协商缓存

协商缓存是在使用本地缓存之前，向服务器端发送一次 GET 请求，验证浏览器保存的本地资源是否已过期。

#### last-modified/if-unmodified-since

一般情况下是采用请求资源的最近一次修改时间戳来进行判断。来举个例子：假设客户端向服务器端请求一个 index.js 文件资源，为了让资源被再次请求时能通过协商缓存的机制使用本地缓存，那么首次返回该资源的响应头中包含一个`last-modified`的字段，该字段的值表示资源最终修改的时间。当刷新网页时，该资源使用的是协商缓存，浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次 GET 请求，进行缓存有效性的协商，这次的 GET 请求的请求头中包含一个`if-unmodified-since`字段，该字段的值是上次响应头中的`last-modified`字段的值。

服务器收到请求后会用该请求的资源当前修改时间和`if-unmodified-since`的值做对比，如果两者相等说明缓存没有过期，继续使用浏览器缓存。这时返回的响应状态码是`304`。

#### last-modified 的不足之处

`last-modified`也存在两个缺陷：

- 它只是根据资源最后的修改时间进行判断，虽然请求的文件资源进行了编辑，但是内容却没变，时间也会更新，这就导致了协商缓存时关于有效性的判断验证失效。就需要重新进行资源的请求。
- 由于文件资源修改的时间单位是秒，如果文件修改很频繁。比如，几百毫秒内修改一次，就无法识别出该文件资源的更新。

#### ETag/If-None-Match

为了弥补通过时间判断的不足，HTTP 1.1 加入了`ETag`（实体标签）的头信息。

`ETag`表示资源的特定标识符，类似于文件指纹。服务器会为每份资源都分配对应的`ETag`值。当资源发生变化时，`ETag`的值也会改变。比如，访问同一个 URL 的网站同时有中文版和英文版，当点击中文时，会返回中文版的资源（`ETag: user-chi`），而点击英文版时，返回的是英文版的资源（`ETag: user-US`）。

当响应头同时存在`last-modified`和`ETag`字段时，会以`ETag`为准。再次对该资源发送请求时，会把之前的响应头中`ETag`的值当作这次请求头中`If-None-Match`字段的值，提供给服务器进行缓存有效性验证。如果验证缓存有效，就返回`304`状态码响应重定向到本地缓存。

#### ETag 的不足之处

`ETag`的出现并不是`last-modified`替代方案，而是一种补充方案，它还是存在一些弊端的。

- 如果资源比较大，数量较多而且修改频繁的话，那么生成`ETag`的过程就会影响到服务器的性能。
- `ETag`还有强`ETag`值和弱`ETag`值之分。
  - 强`ETag`值是根据资源内容进行生成，保证每个字节都相同。
  - 弱`ETag`值是根据资源的部分属性值来生成，生成速度快但无法保证每个字节都相同。

### 总结

1. 首先通过`Cache-Control`查看，是否启用了强缓存。如果启动了强缓存则从缓存中获取资源，返回`200`状态码。
2. 否则，进入协商缓存，发起 GET 请求，服务器通过`if-unmodified-since/If-None-Match`请求头字段检查资源是否有更新。
3. 如果没有，则返回`304`状态码，告诉浏览器资源没更新，可以从缓存中获取资源。
4. 否则返回资源，状态码为`200`。

## HTTP 的不足

HTTP 的主要不足之处有以下几点。

- **通信使用明文，内容会被窃听**
- **不验证通信方的身份，所以可能遭遇伪装**
- **无法证明报文的完整性，所以可能已遭到篡改**

### 通信使用明文，内容会被窃听

HTTP 协议本身没有加密的功能，所以无法做到对通信请求和响应内容进行加密。

#### TCP/IP 是会被窃听的网络

由于 TCP/IP 协议的工作机制，通信内容在所有通信线路上都有可能遭到窥视。不管是世界的哪个角落的服务器在跟客户端进行通信，通信的线路上的一些设备都不可能是个人的物品。所以不排除在某个环节上遭到恶意窥视的行为。即使进行加密处理，也会被窥视到通信内容。窃听相同段上的通信并不是难事，只需要收集在网络上流动的数据包就行。对于收集来的数据包的解析工作，可以使用抓包和嗅探器工具。

#### 解决方案：加密处理防止被窃听

最常见的两种加密方式是通信加密和内容加密。

##### 通信加密

HTTP 协议中本身没有加密机制，但可以通过 SSL（Secure Socket Layer 安全套阶层） 或 TLS（Transport Layer Security 安全传输层协议） 的组合使用，加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信。和 SSL 组合使用的 HTTP 叫做 HTTPS（HTTP Secure 超文本传输安全协议）或 HTTP over SSL。

##### 内容加密

由于 HTTP 协议中没有加密机制，那就对 HTTP 协议传输的内容本身加密。也就是把 HTTP 报文中所包含的内容进行加密处理。在这种情况下，客户端需要对 HTTP 报文主体（`body`）进行加密处理后再发送请求。

要做到内容的加密，前提是客户端和服务器同时具备加密和解密的机制，主要应用在 Web 服务。该方式不同于 SSL 或 TLS 把整个通信路线加密处理，所以内容仍然有被篡改的可能。

### 不验证通信方的身份可能遭遇伪装

HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在服务器是否就是发送请求中 URL 真正的指定主机，返回的响应是否真的返回实际提出请求的客户端等问题。

#### 任何人都可以发起请求

在 HTTP 协议通信时，由于不存在确认同新方的处理步骤，任何人都可以发起请求。服务器只要接收到请求，不管对方是谁都会返回一个响应（仅限发送端的 IP 地址和端口号没被 Web 服务器设定限制访问的前提下）。也就是来者不拒。

HTTP 协议的实现本身很简单，不管是谁发送过来的请求都会返回响应，因此不确认通信方，会存在下面几点问题。

- 无法确定请求发送到目标的 Web 服务器是否是按照真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。
- 无法确定响应返回到的客户端是否是按照真实意图接收响应的那个客户端。有可能是已伪装的客户端。
- 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存有重要的信息，只想发给特定用户通信的权限。
- 无法判断请求是来自哪里、出自谁手。
- 即使是无意义的请求也会照单全收。无法阻止大量请求下的 DoS 攻击（Denial of Service，拒绝服务器攻击）。

#### 解决方案：查明对方的证书

虽然使用 HTTP 协议无法确定通信方，但使用 SSL 可以。SSL 不仅提供加密处理，还使用了一种证书的手段，可用于确认通信方。证书是由值得信任的第三方机构颁发，用来证明服务器和客户端是真实存在的。

通过使用证书，以证明通信方就是意料中的服务器，对使用的个人来说，减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。

### 无法证明报文完整性，可能已篡改

#### 收到的内容可能有误

没有任何办法确认，发出去的请求或响应和接收到的请求或响应是前后相同的。有可能在中途已经被篡改为其他的内容，即使内容是真的被改了，接收方也无法察觉得到。

#### 解决方案：如何防止篡改

可以通过 MD5 和 SHA-1 等散列值校验方法，以及用来确认文件的数字签名方法（PGP 签名）。但是用这些方法也无法保证正确。因为 MD5 和 PGP 本身被修改的话，用户也无法意识到。

## HTTPS

### HTTP + 加密 + 认证 + 完整性保护 = HTTPS

HTTP 加上加密处理和认证以及完整性保护机制就是 HTTPS。

### HTTPS 是身披 SSL 外壳的 HTTP

HTTPS 不是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。之前是 HTTP 和 TCP 进行通信，在使用 SSL 后，就变成了 HTTP 先和 SSL 通信，之后 SSL 和 TCP 通信。

![]("./images/HTTPS.png");

用了 SSL 后，HTTP 就有了 HTTPS 的加密、证书、和完成保护性这些功能。

### 加密方式

SSL 用的是公开密钥加密的处理方式。加密方法中的加密算法是公开的，密钥则是保密的。通过这种方式可以保持加密方法的安全性。

加密和解密都会用到密钥。没有密钥就没办法对密码解密，任何人只要有密钥就可以进行解密，如果密钥被攻击者获得，那么加密就失去了意义。

#### 对称加密

加密和解密同用一个密钥的方式叫做共享密钥加密。也叫对称密钥加密。也就是说，客户端和服务器端共用一个密钥来对消息进行加密，客户端在发送消息时，用密钥对消息加密。服务器端收到之后，再用密钥对消息进行解密。

##### 缺点

共享加密虽然保证了消息保密性，但客户端和服务器端用的都是同一个密钥，如果说传输的过程出现了中间人或者攻击者，密钥就有可能落到攻击者的手中，这样就失去了加密的意义。

#### 非对称加密

公开密钥加密方式解决了共享密钥加密的缺点。公开密钥加密用的是一对非对称的密钥，一把叫做私有密钥，另一把叫做公开密钥。私有密钥只能是自己持有，而公开密钥则是任何人都可以拿到。

当客户端发送消息前，使用公共密钥进行加密，而服务器收到消息后，使用私有密钥进行解密。

##### 缺点

非对称加密需要在发送端在发送消息时，用公钥加密。但公钥是任何人都可以拿到，中间人也可以。中间人虽然不知道接收方的私钥是什么，但可以截获发送端的公钥，自己另外生成一把公钥或者篡改公钥，把公钥发给接收端。而且公密处理起来要比共享密钥加密方式更加复杂，这样就导致了效率极低。

#### 混合加密机制

HTTPS 采用了对称加密和非对称加密两者并用的混合加密。使用对称加密的好处是解密的效率快，使用非对称加密的好处是在传输的消息过程中不能被破解。即使截获了数据，没有相应的私钥
，也不能对消息进行破解。所以充分利用各自的优势，把多种方法组合起来用于传输数据。在交换密钥时使用非对称加密方式，之后的建立通信交换报文阶段使用对称加密方式。

### 数字签名

除了使用以上的加密方式之外，还可以用加密系统对报文进行签名，以说明是谁编写的报文，同时证明报文没有被篡改过。这种技术叫做数字签名。

#### 签名是加了密的校验码

数字签名是附加在报文上的特殊加密校验码。使用数字签名有以下两点好处。

- 签名能确定消息是由发送方签名并发过来的，因为别人假冒不了发送方的签名。
- 签名能确定消息的完整性，证明数据是否没有被篡改过。

假如，

### 数字证书

为了解决上面的问题，可以使用由数字证书认证机构和相关机关颁发的公开密钥证书。
