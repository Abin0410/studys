### HTTP 缓存

HTTP 缓存算是前端经常接触的缓存机制之一，它分为强制缓存和协商缓存。主要的作用是加快资源获取速度，提高用户体验，减少网络传输，缓解服务器压力。

#### 强缓存

对强缓存而言，如果浏览器判断请求的资源是在有效期内，可以直接从缓存中读取资源，不用向服务器端发送资源请求。由`Expires`、`Cache-Control`和`Pragma`这三个头部字段设置强缓存。

##### Expires

`Expires`字段的值是一个`GMT`的时间格式，把资源失效的日期告诉客户端，客户端收到带有该字段的响应体后进行缓存。之后客户端发起相同的资源请求，会用`Expires`的值和本地时间进行对比，如果该请求的本地时间小于`Expires`的值，可以直接使用缓存中的资源，不用向服务器发起请求。这就遇到了一个问题。如果修改了本地的时间，就导致客户端和服务器端的时间不一致，那么对于缓存过期的判断可能就无法和预期相符。`Expires`在三者中是优先级最低。

##### `Cache-Control`

`Cache-Control`头部字段是 HTTP 1.1 中新加入的属性，请求头和响应头双方都可以使用。下面列出它各端所具备的属性值。

- `public`：该资源可以被浏览器和代理服务器进行缓存。
- `private`：该资源只可以被浏览器缓存，其他都不可以。
- `no-cache`：不使用强缓存，强制向源服务器再次验证缓存的有效性。
- `no-store`：不使用任何缓存。每次都向服务器获取最新资源。
- `max-age`：缓存的资源没有超过指定的时间，客户端就从缓存中获取资源。以秒为单位。
- `s-maxage`：只适用于代理服务器，表示代理服务器中的过期时长，使用`s-maxage`后，会忽略`max-age`和`Expires`字段。

##### Pragma

`Pragma` 是用来向后兼容只支持 HTTP1.0 协议的缓存服务器，它的效果和 `Cache-Control: no-cache` 一样，如果`Pragma`和`Cache-Control`同时存在，前者的优先级比后者高。

##### 注意

在 Chrome 中返回`200`状态码有两种情况。

1. `memory cache`
   只要页面不关闭，都会从浏览器内存中读取资源。

2. `disk cache`
   从磁盘中读取缓存资源。

![]("./images/强缓存.jpg")

使用了强缓存之后，会出现一个问题，如果服务器端对资源进行了修改，客户端是不知道的，依然会使用缓存中的资源。可以通过 Ctrl + F5 对页面进行强制刷新。

#### 协商缓存

协商缓存是在使用本地缓存之前，向服务器端发送一次 GET 请求，验证浏览器保存的本地资源是否已过期。

##### last-modified/if-unmodified-since

一般情况下是采用请求资源的最近一次修改时间戳来进行判断。来举个例子：假设客户端向服务器端请求一个 index.js 文件资源，为了让资源被再次请求时能通过协商缓存的机制使用本地缓存，那么首次返回该资源的响应头中包含一个`last-modified`的字段，该字段的值表示资源最终修改的时间。当刷新网页时，该资源使用的是协商缓存，浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次 GET 请求，进行缓存有效性的协商，这次的 GET 请求的请求头中包含一个`if-unmodified-since`字段，该字段的值是上次响应头中的`last-modified`字段的值。

服务器收到请求后会用该请求的资源当前修改时间和`if-unmodified-since`的值做对比，如果两者相等说明缓存没有过期，继续使用浏览器缓存。这时返回的响应状态码是`304`。

##### last-modified 的不足之处

`last-modified`也存在两个缺陷：

- 它只是根据资源最后的修改时间进行判断，虽然请求的文件资源进行了编辑，但是内容却没变，时间也会更新，这就导致了协商缓存时关于有效性的判断验证失效。就需要重新进行资源的请求。
- 由于文件资源修改的时间单位是秒，如果文件修改很频繁。比如，几百毫秒内修改一次，就无法识别出该文件资源的更新。

##### ETag/If-None-Match

为了弥补通过时间判断的不足，HTTP 1.1 加入了`ETag`（实体标签）的头信息。

`ETag`表示资源的特定标识符，类似于文件指纹。服务器会为每份资源都分配对应的`ETag`值。当资源发生变化时，`ETag`的值也会改变。比如，访问同一个 URL 的网站同时有中文版和英文版，当点击中文时，会返回中文版的资源（`ETag: user-chi`），而点击英文版时，返回的是英文版的资源（`ETag: user-US`）。

当响应头同时存在`last-modified`和`ETag`字段时，会以`ETag`为准。再次对该资源发送请求时，会把之前的响应头中`ETag`的值当作这次请求头中`If-None-Match`字段的值，提供给服务器进行缓存有效性验证。如果验证缓存有效，就返回`304`状态码响应重定向到本地缓存。

##### ETag 的不足之处

`ETag`的出现并不是`last-modified`替代方案，而是一种补充方案，它还是存在一些弊端的。

- 如果资源比较大，数量较多而且修改频繁的话，那么生成`ETag`的过程就会影响到服务器的性能。
- `ETag`还有强`ETag`值和弱`ETag`值之分。
  - 强`ETag`值是根据资源内容进行生成，保证每个字节都相同。
  - 弱`ETag`值是根据资源的部分属性值来生成，生成速度快但无法保证每个字节都相同。

#### 总结

1. 首先通过`Cache-Control`查看，是否启用了强缓存。如果启动了强缓存则从缓存中获取资源，返回`200`状态码。
2. 否则，进入协商缓存，发起 GET 请求，服务器通过`if-unmodified-since/If-None-Match`请求头字段检查资源是否有更新。
3. 如果没有，则返回`304`状态码，告诉浏览器资源没更新，可以从缓存中获取资源。
4. 否则返回资源，状态码为`200`。
