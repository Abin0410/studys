## 事件循环

其他进程发送任务给让主进程执行，要将任务添加到消息队列中。

消息队列，先进先出的特性，所有执行的任务都来自消息队列。

消息队列中的任务为宏任务，每个宏任务包含一个微任务队列，当宏任务中的主要功能都完成之后，渲染引擎并不会着急着执行下一个宏任务，而是执行当前宏任务所产生都微任务。

chrome还有一个消息队列，这个队列主要是维护需要延迟执行的任务列表，创建一个定时器时，渲染进程会把该定时器对回调任务添加到延迟队列中。

当通过js调用setTimeout设置回调函数时，渲染进程将会创建一个回调任务，包括回调函数、当前发起时间、延迟执行时间。创建好回调任务之后，再把该任务添加到延迟执行队

async / await 是Generator的语法糖。创建一个async函数就代表着这是个异步函数，执行该异步函数，函数体内存在await操作符时，当执行await时会默认创建一个promise对象。调用resolve函数时，js引擎会把该任务提交给微任务队列。

```js
let _promise = new Promise((resolve, reject) => {
  resolve('xxxx')
})
```

然后js引擎会暂停当前async函数的执行，将执行权交会到父级，同时会把`_promise`对象返回给父级。接下来，父级执行结束，在执行结束之前，会进入微任务队列，微任务队列中有`resolve('xxx')`的任务等待执行，执行到这里的时候，会触发`_promise.then`中的回调函数。

```js
_promise.then((res) => {
  // 回调函数被激活后
  // 将控制权交给foo函数，并把res值传给foo
})
```
