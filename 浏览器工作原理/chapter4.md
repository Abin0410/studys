## 从输入 URL 到页面展示，这中间发生了什么？

### 从输入 URL 到页面展示

用户发出 URL 请求到页面开始解析这个过程，叫做导航。

#### 用户输入

在地址栏上输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容还是 URL。

1. 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，合成带新搜索关键字的 URL。
2. 如果是 URL，那么地址栏会根据规则，把这段内容加上协议。合成完整的 URL。

在按下回车键之后，当前页面如果有未提交完成的表单时，会执行一次`beforeUnload`事件来取消导航。如果没有，就进行下一个阶段。这时，浏览器会进入`loading`状态，还会展示之前打开的内容，并不会立即替换到要导航的页面。因为要等待提交文档阶段，页面内容才会被替换。

#### URL 请求过程

接下来，进入页面资源请求过程。

1. 网络进程先查找缓存，如果有缓存，直接返回资源给浏览器；如果没有，就发起网络请求。发起之前进行 DNS 解析。如果请求协议是 HTTPS，还要建立 TLS 连接。

2. 利用 IP 地址和服务器建立 TCP 连接，之后，客户端构建请求行等信息，并将该域名相关的 Cookie 加到请求头中，然后向服务器发送构建的请求信息。

3. 服务器收到请求后，根据请求信息生成响应数据，发给网络进程。网络进程接收到响应头后，解析响应头内容。

4. 接收服务器返回的响应头后，网络进程解析响应头，如果返回的状态码是`301`或`302`。则需要重定向到其他 URL。网络进程从响应头获取`Location`中的地址，再发起新的请求，重头开始。

5. 如果状态码是`200`，则继续往下处理请求。

- 检查响应类型`Content-Type`，如果是字节流类型，就提交给浏览器的下载管理器。如果是 HTML，就通知浏览器进程准备渲染进程。如果服务器端配置`Content-type`不正确，例如：`text/html`配置成`application/octet-stream`，会将一个本来需要展示的页面变成一个下载文件。

接下来，准备进入准备渲染进程。

#### 准备渲染进程

每个页面都会有自己的一个渲染进程。如果是同一站点（协议、根域名、包括该域名下的所有子域名和不同端口），都会在一个渲染进程中（`process-per-site-instance`）。不同站点，则会使用一个新的渲染进程。如果从一个空白页面输入到另一个页面还是会重新分配一个渲染进程。

下一步就是提交文档。

#### 提交文档

所谓提交文档指的是，浏览器进程把网络进程收到的 HTML 数据交给渲染进程。

1. 当浏览器进程收到网络进程的响应头数据后，向渲染进程发起“提交文档”的消息。
2. 渲染进程收到消息后，和网络进程简历传输数据的“管道”。
3. 等文档数据传输完成后，渲染进程返回“确认提交”的消息给浏览器进程。
4. 浏览器进程收到“确认提交”消息后，则更新浏览器界面状态，包含安全状态、地址栏 URL、前进后退的历史状态，并更新 web 页面。

到了这里，整个导航流程就完成了，接下来就是进入渲染阶段了。

### 渲染进程

浏览器将 HTML、CSS 和 JS 渲染成页面的整个过程：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

HTML 的内容由标记和文本组成，称为标签。
CSS 又称层叠样式，是由选择器和属性组成。
JS 主要作用是让页面动起来。

开始每个阶段都有其输入的内容
然后每个阶段都有其处理过程
最后每个阶段都有其输出的内容

#### 构建 DOM 树

由于浏览器无法解析直接 HTML，所以把 HTML 转换成————DOM 树。DOM 树就是一种树形结构，树数据结构。
DOM 树经过 HTML 解析器解析，最终输出树状结构的 DOM。DOM 保存在内存种的树状结构，通过 JS 操作可以进行增删改查。

#### 样式计算

如果给 DOM 添加或修改样式，就需要经过样式计算。样式计算分为三个步骤完成。

1. 将 CSS 转成浏览器能理解的结构。
   由于浏览器无法直接理解 CSS 的样式，所以当渲染引擎接收到 CSS 文本时，将 CSS 文本转换成浏览器可以理解的结构————styleSheets。
   可以通过`document.styleSheets`在控制台输出其结构。该结构具备了增加和修改。

2. 转换样式表中的属性值，使其标准化。
   例如，一个`<p>`标签上有一个`color:red`，而这个属性上的`red`值，渲染引擎并不会理解，所以要把值转换成渲染引擎容易理解的，标准化的计算值，这个过程叫做属性标准化。
   `red`就会被渲染引擎解析成`rgb(255, 0, 0)`。

3. 计算 DOM 树中每个节点的样式。涉及到两点： CSS 继承规则和层叠规则。
   - CSS 继承就是每个 DOM 节点都包含父节点的样式。比如，一个`body`节点的`font-size`属性是`32px`，那么`body`下的所有子节点的`font-size`都是`32px`。样式计算过程中，会根据 DOM 节点的继承关系合理计算节点的样式。
   - CSS 层叠规则是取决于选择器的优先级进行设置样式。

#### 布局

布局阶段需要完成两个任务：创建布局和布局计算。

1. 创建布局树只会遍历 DOM 树中可见的元素节点，并将其加到布局树中，而不可见的节点会被忽略掉，例如，`head`中的所有内容和标签上的样式属性中包含`display: none`的都不会被加到布局树中。

#### 分层

渲染引擎需要给特定的节点生成专用的图层并生成一棵对应的图层树。渲染引擎给页面分很多图层，这些图层按照顺序叠加在一起，形成最终的页面。
不是布局树的每个节点都包含一个图层，如果一个节点没有对应层，这个节点就属于父节点的图层。

如果让渲染引擎为特定的节点创建新的图层，需要满足两点。

1. 拥有层叠上下文属性的元素会被提升为单独的一层。
2. 需要剪裁的地方也会被创建为图层。

#### 图层绘制

渲染引擎会把一个图层的绘制拆分成很多个小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

#### 栅格化

绘制列表只是记录绘制顺序和绘制指令的列表，而绘制操作是由渲染引擎的合成线程所完成的。当图层绘制好了之后，主线程会把绘制列表提交给合成线程。
通常一个页面可能很大，但是只能看到其中的一部分，这部分称为视口。如果要将所有图层都绘制出来，就产生很大的开销，而且没有必要。
所以合成线程会把图层划分为图块。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行。栅格化就是将图块转换成位图。图块是栅格化执行的最小单位。
渲染进程维护了一个栅格化的线程池，所有图块栅格化都是在线程池里执行。

栅格化过程是使用 GPU 加速生成的，使用 GPU 生成位图的过程叫快速栅格化，生成的位图保存在 GPU 内存中。GPU 操作运行在 GPU 进程中。如果栅格化操作使用了 GPU，那么生成的位图的操作是在 GPU 中完成的。

#### 合成和显示

所有图块被光栅化后，合成线程就会生成一个绘制图块的命令———`DrawQuad`，然后将该命令提交给浏览器进程。浏览器进程里面有一个`viz`的组件，用来接收合成线程发过来的`DrawQuad`命令，根据`DrawQuad`命令，将其页面内容绘制到内存中，最后将内存显示到屏幕上。

### 相关概念

#### 重排

通过 JS 或者 CSS 修改元素的几何位置。比如，修改元素的宽高，浏览器就会触发重新布局，这个过程叫做重排。重排需要更新完成的渲染过程，开销最大。

#### 重绘

通过 JS 修改某个元素的背景颜色、边框等等只影响元素的外观和风格的都会产生重绘。相对于重排，重绘不会进入布局和分层阶段，执行效率比重排要高。

#### 直接合成阶段

使用 CSS 的`transform`实现动画效果，可以避免重排和重绘，直接进入合成阶段可以提升绘制效率。
